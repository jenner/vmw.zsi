#!/usr/bin/env python
############################################################################
# David W. Robertson, LBNL
# See LBNLCopyright for copyright notice!
###########################################################################

import sys
import ZSI

"""
Call:
    This module is used to pass parameters into and get results out of
    a method generated by genClientLib.py
"""

class Parameters:
    """Used to pass parameters into a method.
    """

    def assignTo(self, request, obj):
        """Adds attributes to a request object.
        """

        for name, value in obj.__dict__.items():
            setattr(request, name, value)

    def clear(self):
        """Clears parameters.
        """
        self.__dict__.clear()


class Results:
    """Extracts essential elements of a response from a method
       call.
    """

    def __init__(self):
        self.typelist = []
        self.resultDict = {}

    def extract(self, methodName, obj):
        """Used to extract elements from response.
        """

        self.methodName = methodName
        resultName = '_' + methodName + 'Result'
        result = obj.__dict__[resultName]
            # one top-level result is returned, with sub-structures
        setattr(self, '_result', result)
        ofwhat = getattr(result, 'ofwhat', None)
        if ofwhat:
            for item in ofwhat:
                self.resultDict[item.aname] = result.__dict__[item.aname]
                setattr(self._result, item.aname, result.__dict__[item.aname])
        else:
            try:
                self.resultDict[resultName] = result
                setattr(self._result, resultName, result)
            except AttributeError:
                pass
        return self

    def __repr__(self):
        '''Calls recurse_fields to generate string giving
           parameter names and their values.
        '''

        resultList = ['method:  ' + self.methodName + '\n\n']
        value = self.resultDict.values()[0]
        if ((len(self.resultDict) == 1) and
            (type(value) is not list)): 
            resultList.append('_result = %s\n' % self._result)
        else:
            for name, obj in self.resultDict.items():
                self.recurse_fields('self._result.', name, obj, resultList, 0)
        return ''.join(resultList)
        #return ''


    def recurse_fields(self, fieldStr, aname, obj, resultList, level):
        """Recursively generates list of parameter names and
           their values.
        """
        if (type(obj) is list):
            print 'list ', obj
            ctr = 0
            for item in obj:
                    # include list subscript
                appendStr = '%s[%d].' % (aname, ctr)
                self.recurse_fields(fieldStr + appendStr, aname, item,
                                    resultList, level+1)
                ctr += 1
            return
        pyclass = getattr(obj, 'pyclass', None)
        arrayType = False
            # check to see whether element is an array
        if pyclass:
            className = pyclass.__name__
            if className.find('ArrayOf') == 0:
                arrayType = True
        if arrayType:
            print 'array ', obj
            ctr = 0
            for item in obj.ofwhat:
                    # include list subscript
                appendStr = '%s[%d].%s' % (aname, ctr, item.aname)
                testStr = '%s.%s' % (aname, item.aname)
                    # don't go any further if field is None
                result = eval(fieldStr + testStr)
                if result:
                    self.recurse_fields(fieldStr + appendStr + '.', aname,
                                        item, resultList, level+1)
                ctr += 1
            return

                # if compound element, recurse
        if isinstance(obj, ZSI.TC.Struct):
            if type(obj.ofwhat) is tuple:
                for tc in obj.ofwhat:
                    if isinstance(tc, ZSI.TC.Struct):
                        appendStr = tc.aname + '.'
                        if self.checkName(fieldStr, aname):
                            appendStr = aname + '.' + tc.aname + '.'
                        else:
                            appendStr = tc.aname + '.'
                        self.recurse_fields(fieldStr + appendStr, tc.aname,
                                        tc, resultList, level+1)
                    else:
                        # simple type:  at leaf, get final value
                        if self.checkName(fieldStr, aname):
                            fname = fieldStr + aname + '.' + tc.aname
                        else:
                            fname = fieldStr + tc.aname
                        resultList.append('%s = %s\n' % (fname, eval(fname)))

            else:   # case of a bug in this code or because really happens?
                print "****************"
                appendStr = obj.ofwhat.aname + '.'
                self.recurse_fields(fieldStr + appendStr, obj.ofwhat.aname,
                                    obj.ofwhat, resultList, level+1)
            return

            # at leaf, may be typecode or Python type
        if isinstance(obj, ZSI.TC.TypeCode):
            fname = fieldStr + aname
                # print name and its value
            resultList.append('%s = %s\n' % (fname, eval(fname)))

        else:
            fname = fieldStr + aname
            resultList.append('%s =  %s\n' % (fname, obj))


        
    def checkName(self, fieldStr, aname):

        # Get name of previous field, stripping off any list
        # subscripts or trailing periods.
        indx = fieldStr[:-1].rfind('.')
        testname = fieldStr[indx+1:]
        indx = testname.find('[')
        if indx != -1:
            testname = testname[:indx]
        if testname[-1] == '.':
            testname = testname[:-1]
        if testname == aname:
            return False
        else:
            return True

