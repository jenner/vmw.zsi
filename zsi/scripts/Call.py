#!/usr/bin/env python
############################################################################
# David W. Robertson, LBNL
# See LBNLCopyright for copyright notice!
###########################################################################

import sys
import ZSI

"""
Call:
    This module is used to pass parameters into and get results out of
    a method generated by genClientLib.py
"""

class Parameters:
    """Used to pass parameters into a method.
    """

    def assignTo(self, request, obj):
        """Adds attributes to a request object.
        """

        for name, value in obj.__dict__.items():
            setattr(request, name, value)

    def clear(self):
        """Clears parameters.
        """
        self.__dict__.clear()


class Results:
    """Extracts essential elements of a response from a method
       call.
    """

    def __init__(self):
        self.typelist = []
        self.resultDict = {}

    def extract(self, methodName, obj):
        """Used to extract elements from response.
        """

        self.methodName = methodName
        resultName = '_' + methodName + 'Result'
        result = obj.__dict__[resultName]
            # one top-level result is returned, with sub-structures
        setattr(self, '_result', result)
        resultList = getattr(result, 'ofwhat', None)
        if resultList:
            for item in resultList:
                self.resultDict[item.aname] = result.__dict__[item.aname]
                setattr(self._result, item.aname, result.__dict__[item.aname])
        else:
            try:
                self.resultDict[resultName] = result
                setattr(self._result, resultName, result)
            except AttributeError:
                pass
        return self

    def __repr__(self):
        resultList = ['method:  ' + self.methodName + '\n\n']
        value = self.resultDict.values()[0]
        if ((len(self.resultDict) == 1) and
            (type(value) is not list)): 
            resultList.append('_result = %s\n' % self._result)
        else:
            for name, obj in self.resultDict.items():
                self.recurse_fields('self._result.', name, None, obj, resultList, 0)
        return ''.join(resultList)


    def recurse_fields(self, fieldStr, name, parent, obj, resultList, level):
        """Recursively generates list of parameter names and
           their values.
        """
        aname = getattr(obj, 'aname', None)
        if aname:
            if aname.find('__') == 0:
                objName = obj.aname[1:]
            else:
                objName = obj.aname
        pyclass = getattr(obj, 'pyclass', None)
        arrayType = False
        if pyclass:
            className = pyclass.__name__
            if className.find('ArrayOf') == 0:
                arrayType = True
        if (type(obj) is list):
            ctr = 0
            for item in obj:
                appendStr = '%s[%d].' % (name, ctr)
                self.recurse_fields(fieldStr + appendStr, name, obj, item,
                                    resultList, level+1)
                ctr += 1
            return
        if arrayType:
            ctr = 0
            for item in obj.ofwhat:
                appendStr = '%s[%d].%s' % (objName, ctr, item.aname)
                testStr = '%s.%s' % (objName, item.aname)
                result = eval(fieldStr + testStr)
                if result:
                    self.recurse_fields(fieldStr + appendStr + '.', name, obj,
                                        item, resultList, level+1)
                ctr += 1
            return
        indx = fieldStr[:-1].rfind('.')
        testName = fieldStr[indx+1:]
        indx = testName.find('[')
        if indx != -1:
            testName = testName[:indx]
        if testName[-1] == '.':
            testName = testName[:-1]
        if isinstance(obj, ZSI.TC.Struct):
            if type(obj.ofwhat) is tuple:
                for tc in obj.ofwhat:
                    if isinstance(tc, ZSI.TC.Struct):
                        if testName == name:
                            appendStr = tc.aname + '.'
                        else:
                            appendStr = name + '.' + tc.aname + '.'
                        self.recurse_fields(fieldStr + appendStr, tc.aname,
                                        obj, tc, resultList, level+1)
                    else:
                        if testName == name:
                            fname = fieldStr + tc.aname
                        else:
                            fname = fieldStr + name + '.' + tc.aname
                        print fname
                        resultList.append('%s = %s\n' % (fname, eval(fname)))
            else:
                if testName == name:
                    appendStr = obj.ofwhat.aname + '.'
                else:
                    appendStr = name + '.' + obj.ofwhat.aname + '.'
                self.recurse_fields(fieldStr + appendStr, obj.ofwhat.aname,
                                    obj, obj.ofwhat, resultList, level+1)
            return

        if isinstance(obj, ZSI.TC.TypeCode):
            fname = fieldStr + objName
            resultList.append('%s = %s\n' % (fname, eval(fname)))

        else:
            fname = fieldStr + name
            resultList.append('%s =  %s\n' % (fname, obj))

