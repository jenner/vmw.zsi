#!/usr/bin/env python
############################################################################
# David W. Robertson, LBNL
# See LBNLCopyright for copyright notice!
###########################################################################
import sys, re
import StringIO
import ZSI
import ZSI.wsdl2python
from ZSI.wstools import WSDLTools

"""
genClientLib:
    This module generates a higher-level client interface that is built
    on top of the code generated by wsdl2python.  It expects the
    two modules generated by wsdl2python to be already built.
    The file generated is given the name of the service + '_client.py'

    Each method that is generated has a docstring which gives the
    expected parameter names and return values and their types.
    This is one of the main benefits of this module, if you don't like
    reading WSDL.

    To generate the code, genClientLib.py serviceName

    Following is an example of how to use the code after it is
    generated, where the service name 'TerraService' is used as an example,
    and the generated module is named TerraService_client.py:

    from TerraService_services import *
    import TerraService_client
    import Call

    ...
    kw = {}   # or
    #kw = { 'tracefile': sys.stdout }
    library = TerraService_client.TerraServiceLibrary(kw)
    params = Call.Parameters()
        # ns1 is a namespace alias; see TerraService_services_types.py
    place = ns1.Place_Def()
    place._City = 'Oak Harbor'
    place._State = 'Washington'
    place._Country = 'United States'
    params._place = place
    response = library.ConvertPlaceToLonLatPt(params)   
    print response._result._Lat, response._result._Lon

    params.clear()
    params._point = response._result 
    place = library.ConvertLonLatPtToNearestPlace(params)  
    print place._result
    ...

    """

ID1 = '    '
ID2 = 2*ID1

ID2SP = '  '
NO_PARAM_INDIC = '%%%%'


class GenClientLib:
    """Writes out a library of all methods in a service with a more high-level
       interface.
    """

    def __init__(self):
        self.nspAliases = {}
        self.nsh = ZSI.wsdl2python.NamespaceHash()

    def write(self, serviceName, xFaceName):
        """Write high-level client library.
        """

        self.serviceName = serviceName
        self.xFaceName = xFaceName
        try:
            exec('import ' + self.xFaceName)
        except ImportError:
            print 'Stubs files were not generated.'
            sys.exit(0)
        clientName = self.serviceName + "_client"

        fd = open(clientName + ".py", "w")
        fd.write('#!/usr/bin/env python')
        header = '\n\n%s \n# %s.py \n# generated by %s \n# \n# \n%s\n\n'\
                  %('#'*50, clientName, 'genClientLib', '#'*50)
        fd.write(header)
        fd.write('\nimport sys\n\n')
        fd.write('from %s import *\n' % self.xFaceName)
        fd.write('from Call import Parameters, Results\n\n\n')
        self.getAliases()
        self.output_library(fd)


    def output_library(self, fd):
        """Output client library.  Assumptions are made about
           the structure of the code generated by wsdl2python.
           If wsdl2python changes, this code will need to
           change in parallel.
        """

        fd.write('class %sLibrary:' % self.serviceName)
        module = sys.modules[self.xFaceName]
        moduleDict = module.__dict__
            # fix
        locatorName = ''
        for name in moduleDict.keys():
            if name.endswith('Locator'):
                locatorName = name
                break
            # find port class
        for k in moduleDict[locatorName].__dict__.keys():
            if k.endswith('_address'):
                endIndex = k.rfind('_address')
                portClassName = k[:endIndex]
                break
        initList = []
        initList.append(ID1)
        initList.append('def __init__(self, kw):\n')
        initList.append(ID2)
        initList.append('"""\n' + ID2)
        initList.append('Initializes %s class library\n' % self.serviceName)
        initList.append(ID2)
        initList.append('"""\n\n')
        initList.append(ID2)
        initList.append('loc = %s()\n' % locatorName)
        initList.append(ID2)
        initList.append('self.portType = loc.get%s(**kw)' % portClassName)
        initList.append('\n\n\n')

        for name in moduleDict.keys():
                # need to check that is class and that no base classes
            if name.endswith('SOAP'):
                break
        portClassDict = moduleDict[name].__dict__
        self.methodNamesList = []
            # find all method names
        for key, value in portClassDict.items():
            if hasattr(value, 'func_name') and key != '__init__':
                self.methodNamesList.append(key)
        self.methodNamesList.sort()

            # write out code for all methods
        methodsList = self.writeMethods(moduleDict, portClassDict)
        fd.write('\n\n\n')
        fd.write(''.join(initList))
        if methodsList:
            fd.write(''.join(methodsList))


    def writeMethods(self, moduleDict, portClassDict):
        """Library methods generator for high-level client.
        """

        methodsList = []
        for name in self.methodNamesList:
            params, returnArgs, requestName = \
                self.methodInfo(moduleDict, portClassDict, name)
            methodsList.append(ID1)
            methodsList.append('def %s(self, params):\n' % name)
            methodsList.append(ID2)
            methodsList.append('"""\n')
            methodsList.append(ID2)
            methodsList.append('@param params:  A Call.Parameters instance, ')
            methodsList.append('with entries::\n\n')
                # adds parameter names and types to docstring
            methodsList.extend(params)
            methodsList.append('\n' + ID2)
            methodsList.append('@return: ')
            methodsList.append('A Call.Results instance, ') 
            methodsList.append('with entries::\n\n')
                # adds return value names and types to docstring
            methodsList.extend(returnArgs)
            methodsList.append(ID2)
            methodsList.append('"""\n\n')
            methodsList.append(ID2)
            methodsList.append('request = ')
            methodsList.append('%s(self.portType)\n' % requestName)
            methodsList.append(ID2)
                # copy parameters to request object
            methodsList.append('params.assignTo(request, params)\n')
            methodsList.append(ID2)
            methodsList.append('response = ')
            methodsList.append('self.portType.%s(request)\n' % name)
            methodsList.append(ID2)
                # get relevant attributes out of response
            methodsList.append(
                'return Results().extract("%s", response)' % name)
            methodsList.append('\n\n\n')

        return methodsList


    def methodInfo(self, moduleDict, portClassDict, methodName):
        """Generates code for one method.
        """
        params = {}
        returnArgs = {}
        methodObjs = {}
        docstring = StringIO.StringIO(portClassDict[methodName].__doc__)
        docstring.readline()
        line = docstring.readline()
        start = line.find(':')
        requestName = line[start+2:-1] + 'Wrapper'
        line = docstring.readline()
        start = line.find(':')
        outputName = line[start+2:-1] + 'Wrapper'
        docstring.close()

        inobj = moduleDict[requestName]()
        outobj = moduleDict[outputName]()

        params = []
        classList = []
        optString = 'optional'
            # generate names with associated types for docstring
        self.recurse_typecodes(inobj, params, optString, classList, -1)

        returnArgs = []
        classList = []
        optString = 'may be empty'
            # generate names with associated types for docstring
        self.recurse_typecodes(outobj, returnArgs, optString, classList, -1)

        return params, returnArgs, requestName


    def getAliases(self):
        """
        """
        ctr = 1
        alias = 'ns' + str(ctr)
        while sys.modules[self.xFaceName].__dict__.has_key(alias):
            self.nspAliases[sys.modules[self.xFaceName].__dict__[alias].__name__] = alias
            ctr += 1
            alias = 'ns' + str(ctr)


    def recurse_typecodes(self, obj, argList, optString, classList, level):
        """Recursively generates list of parameter names and
           their types.  Note that this depends on the structure
           of the code generated by wsdl2python.  At some point
           a more object-oriented method needs to be written.
        """
        ofwhat = getattr(obj, 'ofwhat', None)
        if ofwhat:
            if level >= 0:
                    # generate proper indentation
                argList.append(ID2 + ID2SP*level)

                    # Don't need full (long) result entry name for docstring
                if level == 0 and obj.aname.endswith('Result'):
                    argList.append('_result: ')
                else:
                    argList.append('%s: ' % (obj.aname))

                    # A list is returned instead of an ArrayOf**_Def
                    # structure.  The docstring reflects this.
                if obj.__class__.__name__.startswith('ArrayOf'):
                    argList.append('list of the following')
                else:   # print name
                    schema = getattr(obj, 'schema', None)
                    if not schema:
                        argList.append(obj.__class__.__name__)
                    else:
                        entryName = self.getFullName(obj.schema, obj.__class__.__name__)
                        argList.append(entryName)

                        # prints whether optional
                    if obj.optional:
                        argList.append(', %s' % optString)

                argList.append('\n')
                    # don't print the internals of a type if it's
                    # already been printed out once
                if obj.__class__ in classList:
                    return
                else:
                    classList.append(obj.__class__)
            try:
                for tc in ofwhat:
                    self.recurse_typecodes(tc, argList, optString,
                                           classList, level+1)
                return
            except TypeError:
                try:
                    self.recurse_typecodes(ofwhat, argList, optString,
                                           classList, level+1)
                    return
                except TypeError:
                    pass
            # if it's a type code
        if isinstance(obj, ZSI.TC.TypeCode):
                # tag gives the type to print
            tag = getattr(obj, 'tag', None)
            argList.append(ID2 + ID2SP*level)
            if tag:
                    # don't print out long name
                if level == 0 and obj.aname.endswith('Result'):
                    argList.append('_result: %s\n' % (tag))
                else:
                    if obj.aname:   # print out name and type
                        argList.append('%s: %s\n' % (obj.aname, tag))
                    else:
                        argList.append('%s\n' % (tag))
            elif obj.aname[1:] in self.methodNamesList:
                argList.append('No parameters\n')
            else:
                argList.append('%s: type is Any\n' % (obj.aname))
        else:
            print 'WARNING: % not handled' % ofwhat


    def getFullName(self, schema, aname):
        name = self.nsh.namespace_to_moduleName(schema)
        qname = self.nspAliases[name] + '.' + aname 
        return qname




def main():
    if ((sys.argv[1].find('http://') == 0) or
            (sys.argv[1].find('file://') == 0)):
        reader = WSDLTools.WSDLReader()
        if sys.argv[1].find('file://') == 0:
            wsdl = reader.loadFromFile(sys.argv[1])
        else:
            wsdl = reader.loadFromURL(sys.argv[1])
        wsm = ZSI.wsdl2python.WriteServiceModule(wsdl)
        wsm.write()
        xFaceName = wsm.get_module_names()[1]
        indx = xFaceName.find("_services")
        serviceName = xFaceName[:indx]
    else:
        serviceName = sys.argv[1]
        xFaceName = serviceName + '_services'
    c = GenClientLib().write(serviceName, xFaceName)
                  

if __name__ == "__main__" : main()
