#!/usr/bin/env python
############################################################################
# David W. Robertson, LBNL
# See LBNLCopyright for copyright notice!
###########################################################################
import sys, re
import StringIO
import ZSI
import ZSI.wsdl2python
from ZSI.wstools import WSDLTools

"""
genClientLib:
    This module generates a higher-level client interface that is built
    on top of the code generated by wsdl2python.  It expects a single
    command-line argument.  If the argument is a path to a URL or file,
    it uses the wsdl2python.write method to write out the 'services' and
    'types' files.  If not, it expects the name to be that of a service,
    and that the 'services' and 'types' files are already genereated.
    The file this module generates is given the name of the service plus
    '_client.py'

    Each method that is generated has a docstring which gives the
    expected parameter names and return values and their types.
    This is one of the main benefits of this module, if you don't like
    reading WSDL.

    Following is an example of how to use the code after it is
    generated, where the service name 'TerraService' is used as an example,
    and the generated module is named TerraService_client.py:

    from TerraService_services import *
    import TerraService_client
    import Call

    ...
    kw = {}   # or
    #kw = { 'tracefile': sys.stdout }
    library = TerraService_client.TerraServiceLibrary(kw)
    params = Call.Parameters()
        # ns1 is a namespace alias; see TerraService_services_types.py
    place = ns1.Place_Def()
    place._City = 'Oak Harbor'
    place._State = 'Washington'
    place._Country = 'United States'
    params._place = place
    response = library.ConvertPlaceToLonLatPt(params)   
        # prints out name of all result fields and their values
    print response

    params.clear()
    params._point = response._result 
    response = library.ConvertLonLatPtToNearestPlace(params)  
    print response
    ...

    """

ID1 = '    '
ID2 = 2*ID1

ID2SP = '  '


class GenClientLib:
    """Writes out a library of all methods in a service with a more high-level
       interface.
    """

    def __init__(self):
            # namespace alias dictionary
        self.nspAliases = {}
            # namespace handling class
        self.nsh = ZSI.wsdl2python.NamespaceHash()


    def write(self, serviceName, xFaceName):
        """Write high-level client library.
        """

        self.serviceName = serviceName
        self.xFaceName = xFaceName
        try:
            exec('import ' + self.xFaceName)
        except ImportError:
            print 'Stubs files were not generated.'
            sys.exit(0)
        clientName = self.serviceName + "_client"

        fd = open(clientName + ".py", "w")
        fd.write('#!/usr/bin/env python')
        header = '\n\n%s \n# %s.py \n# generated by %s \n# \n# \n%s\n\n'\
                  %('#'*50, clientName, 'genClientLib', '#'*50)
        fd.write(header)
        fd.write('\nimport sys\n\n')
        fd.write('from %s import *\n' % self.xFaceName)
        fd.write('from Call import Parameters, Results\n\n\n')
            # get namespace aliases
        self.getAliases()
            # output library methods
        self.output_library(fd)


    def output_library(self, fd):
        """Output client library.  Assumptions are made about
           the structure of the code generated by wsdl2python.
           If wsdl2python changes, this code will need to
           change in parallel.
        """

        module = sys.modules[self.xFaceName]
        moduleDict = module.__dict__

            # fix
        locatorName = ''
        for name in moduleDict.keys():
            if name.endswith('Locator'):
                locatorName = name
                break

            # find portType classes
        portClassNames = []
        for k in moduleDict[locatorName].__dict__.keys():
            if k.endswith('_address'):
                endIndex = k.rfind('_address')
                portClassNames.append(k[:endIndex])

        if len(portClassNames) == 1:
            singlePortType = True
        else:
            singlePortType = False

        for portClassName in portClassNames:
            if singlePortType:
                fd.write('class %sLibrary:' % self.serviceName)
            else:
                fd.write('class %sLibrary:' % portClassName)
            initList = []
            initList.append(ID1)
            initList.append('def __init__(self, kw):\n')
            initList.append(ID2)
            initList.append('"""\n' + ID2)
            if singlePortType:
                initList.append('Initializes %s class library\n' % self.serviceName)
            else:
                initList.append('Initializes %s class library\n' % portClassName)
            initList.append(ID2)
            initList.append('"""\n\n')
            initList.append(ID2)
            initList.append('loc = %s()\n' % locatorName)
            initList.append(ID2)
            initList.append('self.portType = loc.get%s(**kw)' % portClassName)
            initList.append('\n\n\n')

            locatorInstance = moduleDict[locatorName]()
            c = compile('locatorInstance.get%s()' % portClassName,
                        locatorName, 'eval')
            portTypeName = eval(c).__class__.__name__
            portClassDict = moduleDict[portTypeName].__dict__
            self.methodNamesList = []
                # find all method names
            for key, value in portClassDict.items():
                if hasattr(value, 'func_name') and key != '__init__':
                    self.methodNamesList.append(key)
            self.methodNamesList.sort()

                # write out code for all methods
            methodsList = self.writeMethods(moduleDict, portClassDict)
            fd.write('\n\n\n')
            fd.write(''.join(initList))
            if methodsList:
                fd.write(''.join(methodsList))
            fd.write('\n\n\n')


    def writeMethods(self, moduleDict, portClassDict):
        """Library methods generator for high-level client.
        """

        methodsList = []
        for name in self.methodNamesList:
                # get lists representing parameters, return argument,
                # and input message name
            params, returnArgs, requestName = \
                self.methodInfo(moduleDict, portClassDict, name)
            methodsList.append(ID1)
            methodsList.append('def %s(self, params):\n' % name)
            methodsList.append(ID2)
            methodsList.append('"""\n')
            methodsList.append(ID2)
            methodsList.append('@param params:  A Call.Parameters instance, ')
            methodsList.append('with entries::\n\n')
                # adds parameter names and types to docstring
            methodsList.extend(params)
            methodsList.append('\n' + ID2)
            methodsList.append('@return: ')
            methodsList.append('A Call.Results instance, ') 
            methodsList.append('with entries::\n\n')
                # adds return value names and types to docstring
            methodsList.extend(returnArgs)
            methodsList.append(ID2)
            methodsList.append('"""\n\n')
            methodsList.append(ID2)
            methodsList.append('request = ')
            methodsList.append('%s(self.portType)\n' % requestName)
            methodsList.append(ID2)
                # copy parameters to request object
            methodsList.append('params.assignTo(request, params)\n')
            methodsList.append(ID2)
            methodsList.append('response = ')
            methodsList.append('self.portType.%s(request)\n' % name)
            methodsList.append(ID2)
                # get relevant attributes out of response
            methodsList.append(
                'return Results().extract("%s", response)' % name)
            methodsList.append('\n\n\n')

        return methodsList


    def methodInfo(self, moduleDict, portClassDict, methodName):
        """Generates code for one method.
        """
        params = {}
        returnArgs = {}
        methodObjs = {}
            # get docstring from method generated by wsdl2py
        docstring = StringIO.StringIO(portClassDict[methodName].__doc__)
        docstring.readline()

        # get names of input and output wrapper methods
        line = docstring.readline()
        requestName = None
        start = line.find(':')
        if start != -1:
            requestName = line[start+2:-1] + 'Wrapper'

        line = docstring.readline()
        outputName = None
        start = line.find(':')
        if start != -1:
            outputName = line[start+2:-1] + 'Wrapper'
        docstring.close()

        params = []
            # used to call input and output wrapper methods to get
            # typecodes list
        if requestName:
            inobj = moduleDict[requestName]()
            classList = []
            optString = 'optional'
                # generate names with associated types for docstring
            self.recurse_typecodes(inobj, params, optString, classList, -1)

        returnArgs = []
        if outputName:
            outobj = moduleDict[outputName]()
            classList = []
            optString = 'may be empty'
                # generate names with associated types for docstring
            self.recurse_typecodes(outobj, returnArgs, optString, classList, -1)
        return params, returnArgs, requestName


    def getAliases(self):
        """Get namespace aliases used in 'services' file.
        """
        ctr = 1
        alias = 'ns' + str(ctr)
        while sys.modules[self.xFaceName].__dict__.has_key(alias):
            self.nspAliases[sys.modules[self.xFaceName].__dict__[alias].__name__] = alias
            ctr += 1
            alias = 'ns' + str(ctr)


    def recurse_typecodes(self, obj, argList, optString, classList, level):
        """Recursively generates list of parameter names and
           their types.  Note that this depends on the structure
           of the code generated by wsdl2python.
        """
        ofwhat = getattr(obj, 'ofwhat', None)
        if not ofwhat:
            typecode = getattr(obj, 'typecode', None)
            if typecode:
                ofwhat = getattr(typecode, 'ofwhat', None)

        if ofwhat:
            if level >= 0:
                    # generate proper indentation
                argList.append(ID2 + ID2SP*level)

                    # Don't need full (long) result entry name for docstring
                if level == 0 and obj.aname.endswith('Result'):
                    argList.append('_result: ')
                else:
                    argList.append('%s: ' % (obj.aname))

                    # A list is returned instead of an ArrayOf**_Def
                    # structure.
                if obj.__class__.__name__.startswith('ArrayOf'):
                    argList.append('list of the following')
                else:   # print name
                    schema = getattr(obj, 'schema', None)
                    if not schema:
                        argList.append(obj.__class__.__name__)
                    else:
                        entryName = self.getFullName(obj.schema, obj.__class__.__name__)
                        argList.append(entryName)

                        # prints whether optional
                    if obj.optional:
                        argList.append(', %s' % optString)

                argList.append('\n')
                    # don't print the internals of a type if it's
                    # already been printed out once
                if obj.__class__ in classList:
                    return
                else:
                    classList.append(obj.__class__)
            try:
                    # recurse into typecode list
                for tc in ofwhat:
                    self.recurse_typecodes(tc, argList, optString,
                                           classList, level+1)
                return
            except TypeError:    # ofwhat not iterable
                try:
                    self.recurse_typecodes(ofwhat, argList, optString,
                                           classList, level+1)
                    return
                except TypeError:
                    pass
            # if it's a type code
        if isinstance(obj, ZSI.TC.TypeCode):
                # tag gives the type to print
            tag = getattr(obj, 'tag', None)
            argList.append(ID2 + ID2SP*level)
            if tag:
                    # don't print out long name
                if level == 0 and obj.aname.endswith('Result'):
                    argList.append('_result: %s\n' % (tag))
                else:
                    if obj.aname:   # print out name and type
                        argList.append('%s: %s\n' % (obj.aname, tag))
                    else:
                        argList.append('%s\n' % (tag))
            elif obj.aname[1:] in self.methodNamesList:
                argList.append('No parameters\n')
            else:
                argList.append('%s: type is Any\n' % (obj.aname))
        else:
            print 'WARNING: % not handled' % ofwhat


    def getFullName(self, schema, aname):
        '''Get qualified name of element, with the namespace alias.
        '''

        name = self.nsh.namespace_to_moduleName(schema)
        qname = self.nspAliases[name] + '.' + aname 
        return qname




def main():
        # if a path, generate 'services' and 'types' files
    if ((sys.argv[1].find('http://') == 0) or
            (sys.argv[1].find('file://') == 0)):
        reader = WSDLTools.WSDLReader()
        if sys.argv[1].find('file://') == 0:
            wsdl = reader.loadFromFile(sys.argv[1])
        else:
            wsdl = reader.loadFromURL(sys.argv[1])
        wsm = ZSI.wsdl2python.WriteServiceModule(wsdl)
        wsm.write()
        xFaceName = wsm.get_module_names()[1]
        indx = xFaceName.find("_services")
        serviceName = xFaceName[:indx]
    else:   # assumes already generated
        serviceName = sys.argv[1]
        xFaceName = serviceName + '_services'
    c = GenClientLib().write(serviceName, xFaceName)
                  

if __name__ == "__main__" : main()
