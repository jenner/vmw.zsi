\chapter{WSDL Support}

The \ZSI~and \module{ZSI.wstools} modules provide client tools for
using WSDL 1.1
(see \citetitle[http://www.w3.org/TR/wsdl]{WSDL 1.1 specification}).

ZSI provides two ways of accessing a WSDL service.  The first
provides an easy-to-use interface,
but requires setting all type codes manually.  It is easier
to use with simple services than with those specifying many
complex types.
The second method requires the use of a more complex
interface, but automatically generates type codes and classes
that correspond to XML Schema types, as well as client stub code.
Both use a \class{WSDL} instance internally to send and receive
messages (see section 11.4 for more information on the \class{WSDL}
class).

The first way of accessing a service is through the \class{ServiceProxy} class.
Once the proxy has been created, each remote operation is exposed
as a method on the object.
The user must handle the generation of type codes.
Note that while \class{ServiceProxy} is part of \ZSI{}, it must be
explicitly imported.

The second method uses wsdl2py.  Handling XML Schema
(see \citetitle[http://www.w3.org/XML/Schema]{XML Schema specification}) 
is one of the more difficult aspects
of using WSDL.  The class \class{WriteServiceModule}, which wsdl2py
uses, helps to hides these
details.  It generates a module with stub code for the client interface,
and a module that encapsulates the handling of XML Schema, automatically
generating type codes.

\section{WSDLReader}

The \class{WSDLReader} class in \module{ZSI.wstools.WSDLTools} provides
methods for loading WSDL service descriptions from URLs, XML files
or XML string data, and creating a \class{WSDL} object.
It is used by \class{ServiceProxy} and \class{WriteServiceModule}.

\class{WSDL} instances represent WSDL service descriptions and provide 
a low-level object model for building and working with those descriptions.

The WSDL reader is implemented as a 
separate class to make it easy to create custom readers that implement 
caching policies or other optimizations.


\begin{classdesc}{WSDLReader}{}

The following methods are available:

\begin{methoddesc}{loadFromStream}{file}
Return a \class{WSDL} instance representing the service description 
contained in \var{file}. The \var{file} argument must be a file-like 
object.
\end{methoddesc}

\begin{methoddesc}{loadFromString}{data}
Returns a \class{WSDL} instance loaded from the XML string \var{data}.
\end{methoddesc}

\begin{methoddesc}{loadFromFile}{filename}
Returns a \class{WSDL} instance loaded from the file named by \var{filename}.
\end{methoddesc}

\begin{methoddesc}{loadFromURL}{url}
Returns a \class{WSDL} instance loaded from the given \var{url}.
\end{methoddesc}

\end{classdesc}

\section{ServiceProxy}

The \class{ServiceProxy} class provides calls to
web services. A WSDL description must be available for the 
service.  \class{ServiceProxy} uses \class{WSDLReader} internally to load 
a \class{WSDL} instance.

The user may build up a type codes module for use by \class{ServiceProxy}.

\begin{classdesc}{ServiceProxy}{wsdl,\optional{, service\optional{, port}}}

The \var{wsdl} argument may be either the URL of the service description 
or an existing \class{WSDL} instance. The optional \var{service} and 
\var{port} name the service and port within the WSDL description that 
should be used. If not specified, the first defined service and port 
will be used.

The following keyword arguments may be used:

\begin{tableiii}{l|c|p{30em}}{textrm}{Keyword}{Default}{Description}
\lineiii{\code{nsdict}}{\code{\{\}}}{Namespace dictionary to send in the
    SOAP \code{Envelope}}
\lineiii{\code{tracefile}}{\code{None}}{An object with a \code{write}
    method, where packet traces will be recorded.}
\end{tableiii}

A \class{ServiceProxy} instance, once instantiated, exposes callable 
methods that reflect the methods of the remote web service it 
represents. These methods may be called like normal methods, using 
*either* positional or keyword arguments (but not both).

The methods can be called with either positional or keyword arguments;
the argument types must be compatible with the types specified in the
WSDL description.

When a method of a \class{ServiceProxy} is called with positional 
arguments, the arguments are mapped to the SOAP request based on 
the parameter order defined in the WSDL description. If keyword 
arguments are passed, the arguments will be mapped based on their 
names.

\end{classdesc}

\subsection{Example}

The following example, using ServiceProxy,  shows a simple language
translation service that makes
use of the complex type structures defined in the module BabelTypes:

\begin{verbatim}
from ZSI import ServiceProxy
import BabelTypes

service = ServiceProxy('http://www.xmethods.net/sd/BabelFishService.wsdl',
		       typesmodule=BabelTypes)
value = service.BabelFish('en_de', 'This is a test!')
\end{verbatim}

The return value from a proxy method depends on the SOAP signature. If the 
remote service returns a single value, that value will be returned. If the 
remote service returns multiple ``out'' parameters, the return value of the 
proxy method will be a dictionary containing the out parameters indexed by 
name.  Because \class{ServiceProxy} makes use of the ZSI serialization / 
deserialization engine, complex return types are supported.  This means 
that an aggregation of primitives can be returned from or passed to a service
invocation according to any predefined hierarchical structure.


\section{Code Generation from WSDL and XML Schema}

This section covers wsdl2py, the second way ZSI provides to access WSDL
services.  Given the path to a WSDL service, two files are generated, a 
'service' file and a 'types' file, that one can then use to access the
service.  For example, to generate code to access the TerraServer database,
the script can be called as follows:

\begin{verbatim}
wsdl2py http://terraservice.net/TerraService.asmx?WSDL
\end{verbatim}

To generate the 'service' file, wsdl2py uses the \class{WriteServiceModule}
class in \module{ZSI.wsdl2python}.
\class{WriteServiceModule} transforms the definitions in a WSDL instance
to remote proxy interfaces in the 'service' file.
To generate the 'types' file, wsdl2py transforms the XML Schema instances in
the WSDL types section to type codes that describe
the data.

The \class{WSDL} (see section 11.4) class and \module{ZSI.wstools.XMLSchema}
module provide API's into the
definitions, which \class{ModuleWriter} and its underlying generator classes
use to interpret WSDL and XML Schema into class definitions.

The 'service' file contains locator, portType, and message classes.  
A locator instance is used to
get an instance of a portType class, which is a remote proxy object.
Message instances are sent and received through the methods of the
portType instance.

The 'types' file contains class representations of the definitions and
declarations defined by all schema instances imported by the WSDL definition.
XML Schema attributes, wildcards, and derived types are not fully
handled.

\subsection{Example Use of Generated Code}

The following shows how to call a proxy method for
ConvertPlaceToLonLatPt, a method provided by a service
named TerraService. It assumes that wsdl2py has already been called.
In this case, the 'services' and 'types' files generated would
be named TerraService_services.py and TerraService_services_types.py,
respectively.

\begin{verbatim}
from TerraService_services import *

import sys

def main():
    loc = TerraServiceLocator()

       # prints messages sent and received if tracefile is set
    kw = { 'tracefile' : sys.stdout }
    portType = loc.getTerraServiceSoap(**kw)

    # --------------------------------
    # From "TerraService_services.py"
    #
    #  ConvertPlaceToLonLatPtSoapIn = ns0.ConvertPlaceToLonLatPt_Dec().pyclass

    # --------------------------------
    # From "TerraService_services_types.py"
    #
    #  class ConvertPlaceToLonLatPt_Dec(ZSI.TCcompound.Struct, ElementDeclaration):
    #      ...
    #      class Holder(SetAddByAname):
    #          typecode = self
    #          def __init__(self):
    #              # pyclass
    #              self._place = None
    #
    class Holder: pass
    request = ConvertPlaceToLonLatPtSoapIn()
    request._place = Holder()
    request._place._City = 'Oak Harbor'
    request._place._State = 'Washington'
    request._place._Country = 'United States'

    response = portType.ConvertPlaceToLonLatPt(request)
    print "Latitude = %s" % response._ConvertPlaceToLonLatPtResult._Lat
    print "Longitude = %s" % response._ConvertPlaceToLonLatPtResult._Lon
...

\end{verbatim}

One needs to look at the associated WSDL file to see how
to use the classes and methods in the generated code.
In this example, \class{TerraServiceLocator}
is a class with the name of the WSDL service, plus 'Locator'.  It contains the
information necessary to contact the service, using
\method{getTerraServiceSoap(**kw)}.

That method's name is generated by 'get' plus the name of the WSDL portType
for the service.  It returns a class which
encapsulates the information in the portType, and contains the proxies
for the methods associated with it.

\method{ConvertPlaceToLonLatPtSoapInWrapper()}'s
name is generated using
the name of the WSDL input message for the ConvertPlaceToLonLatPt
WSDL operation, plus 'Wrapper'.  The actual call to the service is a method of
the class encapsulating the portType, with the same name as the WSDL operation.

The name of the response field is '_' plus the name of the
WSDL element (or one contained by the element) returned by the call.
Parameters that are input and output are subfields of
the request object and the response field, respectively. 
Their names can be determined by looking at the part sub-element of a
message.

If the user wishes to set authorization headers in a request, using the 
previous example, it would be accomplished like this:

\begin{verbatim}
def main():
    loc = TerraServiceLocator()
    portType = loc.getTerraServiceSoap(
        tracefile=sys.stdout,
        auth=(soap.ZSI.AUTH.httpbasic, 'logname', 'password'))
    # ...
\end{verbatim}
