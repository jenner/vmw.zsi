\chapter{Examples}

This section contains examples to help you better understand what \ZSI{}
offers.  It is broken down into client-side and server-side examples, and
explores different implementation options a developer has using \ZSI{}.

\section{Server Side Examples}
\subsection{Simple example}
Using the \module{ZSI.cgi} module, it is simple to expose Python
functions as web services.
Each function is invoked with all the input parameters specified in the
client's SOAP request.
Any value returned by the function will be serialized back to the client;
multiple values can be returned by returning a tuple.

The following code shows some simple services:

\begin{verbatim}
def hello():
    return "Hello, world"

def echo(*args):
    return args

def average(*args):
    sum = 0
    for i in args: sum += i
    return sum / len(args)

from ZSI import dispatch
dispatch.AsCGI()
\end{verbatim}

Each function defines a SOAP request, so if this script is installed
as a CGI script, a SOAP message can be posted to that script's URL with any of
\code{hello}, \code{echo}, or \code{average} as the request element,
and the value returned by the function will be sent back.

The \ZSI{} CGI dispatcher catches exceptions and sends back a SOAP fault.
For example, a fault will be sent if the  \code{hello} function is given any
arguments, or if the \code{average} function is given a non-integer.

\subsection{More complex example}

We will now show a more complete example of a robust web service.
It takes as input a player name and array of integers, and returns
the average.
It is presented in sections, following the steps detailed above.

The first section reads in a request, and parses the SOAP header.

\begin{verbatim}
from ZSI import *
import sys
IN, OUT = sys.stdin, sys.stdout

try:
    ps = ParsedSoap(IN)
except ParseException, e:
    FaultFromZSIException(e).AsSOAP(OUT)
    sys.exit(1)
except Exception, e:
    # Faulted while processing; we assume it's in the header.
    FaultFromException(e, 1).AsSOAP(OUT)
    sys.exit(1)

# We are not prepared to handle any actors or mustUnderstand elements,
# so we'll arbitrarily fault back with the first one we found.
a = ps.WhatActorsArePresent()
if len(a):
    FaultFromActor(a[0]).AsSOAP(OUT)
    sys.exit(1)
mu = ps.WhatMustIUnderstand()
if len(mu):
    uri, localname = mu[0]
    FaultFromNotUnderstood(uri, localname).AsSOAP(OUT)
    sys.exit(1)
\end{verbatim}

This section defines the mappings between Python objects and the SOAP
data being transmitted.
Recall that according to the SOAP specification, RPC input and output
are modeled as a structure.

\begin{verbatim}
class Player:
    def __init__(self, name):
        pass
Player.typecode = TC.Struct(Player, [
                                TC.String('Name'),
                                TC.Array('Integer', TC.Integer(), 'Scores'),
                                ], 'GetAverage')
class Average:
    def __init__(self, average):
        self.average = average
Average.typecode = TC.Struct(Average, [
                                TC.Integer('average'),
                                ], 'GetAverageResponse')
\end{verbatim}

This section parses the input, performs the application-level
activity, and serializes the response.
\begin{verbatim}
try:
    player = ps.Parse(Player.typecode)
except EvaluateError, e:
    FaultFromZSIException(e).AsSOAP(OUT)
    sys.exit(1)

try:
    total = 0
    for value in player.Scores: total = total + value
    result = Average(total / len(player.Scores))
    sw = SoapWriter(OUT)
    sw.serialize(result, Average.typecode)
    sw.close()
except Exception, e:
    FaultFromException(e, 0, sys.exc_info()[2]).AsSOAP(OUT)
    sys.exit(1)
\end{verbatim}

In the \method{serialize()} call above, the second parameter is optional,
since \code{result} is an instance of the 
\class{Average} class, and the \code{Average.typecode} attribute is
the typecode for class instances.
In addition, since the \class{SoapWriter} destructor will call \method{close()}
if necessary, sending a SOAP response can often be written like
this one-liner:
\begin{verbatim}
SoapWriter(OUT).serialize(result)
\end{verbatim}


\subsection{A mod_python example}

The Apache module \code{mod_python} (see
\url{http://www.modpython.org}) embeds Python within the Apache server.
It is fairly easy to use \ZSI{} with \code{mod_python}; the only ``trick''
is that you have to serialize your output into a string before
sending it to the client.

The following is a complete example of a simple handler:

\begin{verbatim}
from mod_python import apache
from ZSI import *
import cStringIO

class TestInput:
    def __init__(self, name):
        pass
TestInput.typecode = TC.Struct(TestInput, [
                                 TC.Integer('x'),
                                 ], 'TestInput')

class TestOutput:
    def __init__(self, y):
        self.y = y
TestOutput.typecode = TC.Struct(TestOutput, [
                                  TC.Integer('y'),
                                  ], 'TestOutput')

def handler(req):
    # Parse the input
    ps = ParsedSoap(req)
    testinput = ps.Parse(TestInput.typecode)

    # Calculate the output
    result = TestOutput(testinput.x * 2)

    # Serialize the output into a string
    out_io = cStringIO.StringIO()
    sw = SoapWriter(out_io)
    sw.serialize(result)
    sw.close()
    out_str = out_io.getvalue()

    # Set up the return values
    req.content_type = "text/xml"
    req.content_length = len(out_str)
    req.send_http_header()
    req.write(out_str)
    return apache.OK
\end{verbatim}


\section{Client Side Examples}
\subsection{Simple Example}
If the simple server side example shown above is installed on the webserver 
running on the local host, and if the URL is \code{/cgi-bin/simple-test}, then
the following code shows simple binding and access to the server:

\begin{verbatim}
from ZSI.client import Binding
b = Binding(url='/cgi-bin/simple-test')
a = apply(b.average, range(1,11))
assert a == 5
print b.hello()
\end{verbatim}

\subsection{Complex Example}
If the operation invoked returns a ComplexType, typecode information must
be provided in order to tell \ZSI{} how to deserialize the response.  Let's
assume the following server side implementation:

\begin{verbatim}
# Complex type definition
class Person:
  def __init__(self, name=None, age=0):
    self.name = name
    self.age = age

Person.typecode = TC.Struct(Person,
			    [TC.String('name'),
			     TC.InonNegativeInteger('age')],
			    'myApp:Person')

# my web service
def getPerson():
  return Person('Christopher', 26)
\end{verbatim}

In order for \ZSI{} to properly deserialize the returned complex type into
a Person instance, you must do one of two things: define the Person class (and
typecode) in a module named \module{ComplexTypes}, or pass the expected return
type to the \code{Binding.Receive} method.  The former is recommended, as it
makes your code easier to read.  Below you'll find client side code that
interacts with the operation described above (this assumes that you have
defined the Person class and typecode in a module named \module{ComplexTypes}
which is present in \code{sys.path}:

\begin{verbatim}
from ZSI.client import Binding
b = Binding(url='/cgi-bin/complex-test')
a = apply(b.getPerson, '')
person = b.Receive()    # you could also write: person = b.Receive(Person)
\end{verbatim}

The person returned is an instance of Person.  The deserialization in this
case was possible because \ZSI{} was able to locate the typecode information
for the returned Person and properly re-assemble the instance.  If you would
like to explicitly tell \ZSI{} which class to use for deserialization, you
may do so by providing the class as an argument to the \code{Receive} method.
