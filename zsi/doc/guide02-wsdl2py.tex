\chapter{The wsdl2py Tool: WSDL/XMLSchema python code generator}

The \ZSI~and \module{ZSI.wstools} modules provide client tools for
using WSDL 1.1
(see \citetitle[http://www.w3.org/TR/wsdl]{WSDL 1.1 specification}).

ZSI provides two ways of accessing a WSDL service.  The first
provides an easy-to-use interface,
but requires setting all type codes manually.  It is easier
to use with simple services than with those specifying many
complex types.
The second method requires the use of a more complex
interface, but automatically generates type codes and classes
that correspond to XML Schema types, as well as client stub code.
Both use a \class{WSDL} instance internally to send and receive
messages (see section 11.4 for more information on the \class{WSDL}
class).

The first way of accessing a service is through the \class{ServiceProxy} class.
Once the proxy has been created, each remote operation is exposed
as a method on the object.
The user must handle the generation of type codes.
Note that while \class{ServiceProxy} is part of \ZSI{}, it must be
explicitly imported.

The second method uses wsdl2py.  Handling XML Schema
(see \citetitle[http://www.w3.org/XML/Schema]{XML Schema specification}) 
is one of the more difficult aspects
of using WSDL.  The class \class{WriteServiceModule}, which wsdl2py
uses, helps to hides these
details.  It generates a module with stub code for the client interface,
and a module that encapsulates the handling of XML Schema, automatically
generating type codes.

\section{WSDLReader}

The \class{WSDLReader} class in \module{ZSI.wstools.WSDLTools} provides
methods for loading WSDL service descriptions from URLs, XML files
or XML string data, and creating a \class{WSDL} object.
It is used by \class{ServiceProxy} and \class{WriteServiceModule}.

\class{WSDL} instances represent WSDL service descriptions and provide 
a low-level object model for building and working with those descriptions.

The WSDL reader is implemented as a 
separate class to make it easy to create custom readers that implement 
caching policies or other optimizations.


\begin{classdesc}{WSDLReader}{}

The following methods are available:

\begin{methoddesc}{loadFromStream}{file}
Return a \class{WSDL} instance representing the service description 
contained in \var{file}. The \var{file} argument must be a file-like 
object.
\end{methoddesc}

\begin{methoddesc}{loadFromString}{data}
Returns a \class{WSDL} instance loaded from the XML string \var{data}.
\end{methoddesc}

\begin{methoddesc}{loadFromFile}{filename}
Returns a \class{WSDL} instance loaded from the file named by \var{filename}.
\end{methoddesc}

\begin{methoddesc}{loadFromURL}{url}
Returns a \class{WSDL} instance loaded from the given \var{url}.
\end{methoddesc}

\end{classdesc}

\section{ServiceProxy}

The \class{ServiceProxy} class provides calls to
web services. A WSDL description must be available for the 
service.  \class{ServiceProxy} uses \class{WSDLReader} internally to load 
a \class{WSDL} instance.

The user may build up a type codes module for use by \class{ServiceProxy}.

\begin{classdesc}{ServiceProxy}{wsdl,\optional{, service\optional{, port}}}

The \var{wsdl} argument may be either the URL of the service description 
or an existing \class{WSDL} instance. The optional \var{service} and 
\var{port} name the service and port within the WSDL description that 
should be used. If not specified, the first defined service and port 
will be used.

The following keyword arguments may be used:

\begin{tableiii}{l|c|p{30em}}{textrm}{Keyword}{Default}{Description}
\lineiii{\code{nsdict}}{\code{\{\}}}{Namespace dictionary to send in the
    SOAP \code{Envelope}}
\lineiii{\code{tracefile}}{\code{None}}{An object with a \code{write}
    method, where packet traces will be recorded.}
\end{tableiii}

A \class{ServiceProxy} instance, once instantiated, exposes callable 
methods that reflect the methods of the remote web service it 
represents. These methods may be called like normal methods, using 
*either* positional or keyword arguments (but not both).

The methods can be called with either positional or keyword arguments;
the argument types must be compatible with the types specified in the
WSDL description.

When a method of a \class{ServiceProxy} is called with positional 
arguments, the arguments are mapped to the SOAP request based on 
the parameter order defined in the WSDL description. If keyword 
arguments are passed, the arguments will be mapped based on their 
names.

\end{classdesc}

\subsection{Example}

The following example, using ServiceProxy,  shows a simple language
translation service that makes
use of the complex type structures defined in the module BabelTypes:

\begin{verbatim}
from ZSI import ServiceProxy
import BabelTypes

service = ServiceProxy('http://www.xmethods.net/sd/BabelFishService.wsdl',
		       typesmodule=BabelTypes)
value = service.BabelFish('en_de', 'This is a test!')
\end{verbatim}

The return value from a proxy method depends on the SOAP signature. If the 
remote service returns a single value, that value will be returned. If the 
remote service returns multiple ``out'' parameters, the return value of the 
proxy method will be a dictionary containing the out parameters indexed by 
name.  Because \class{ServiceProxy} makes use of the ZSI serialization / 
deserialization engine, complex return types are supported.  This means 
that an aggregation of primitives can be returned from or passed to a service
invocation according to any predefined hierarchical structure.


\section{Code Generation from WSDL and XML Schema}

This section covers wsdl2py, the second way ZSI provides to access WSDL
services.  Given the path to a WSDL service, two files are generated, a 
'service' file and a 'types' file, that one can then use to access the
service.  As an example, we will use the search service provided by Wolfram
Research Inc.\copyright{}, \url{http://webservices.wolfram.com/wolframsearch/}, 
which provides a service for searching the popular MathWorld site, 
\url{http://mathworld.wolfram.com/}, among others.

\begin{verbatim}
wsdl2py.py --complexType --url=http://webservices.wolfram.com/services/SearchServices/WolframSearch2.wsdl
\end{verbatim}

Run the above command to generate the service and type files.  The wsdl2py uses
the {\it name} attribute of the {\it wsdl:service} element to name the resulting files.
In this example, the service name is {\it WolframSearchService}.  Therefore the files
{\it WolframSearchService_services.py} and {\it WolframSearchService_services_types.py}
should of been generated.

The 'service' file contains locator, portType, and message classes.  
A locator instance is used to get an instance of a portType class, 
which is a remote proxy object. Message instances are sent and received 
through the methods of the portType instance.

The 'types' file contains class representations of the definitions and
declarations defined by all schema instances imported by the WSDL definition.
XML Schema attributes, wildcards, and derived types are not fully
handled.

\subsection{Example Use of Generated Code}

The following shows how to call a proxy method for {\it WolframSearch}.  It
assumes wsdl2py has already been ran as shown in the section above.  The example
will be explained in greater detail below.

\begin{verbatim}
# import the generated class stubs
from WolframSearchService_services import *

# get a port proxy instance
loc = WolframSearchServiceLocator()
port = loc.getWolframSearchmyPortType()

# create a new request
req = WolframSearchRequest()
req.Options = req.new_Options()
req.Options.Query = 'newton'

# call the remote method
resp = port.WolframSearch(req)

# print results
print 'Search Time:', resp.Result.SearchTime
print 'Total Matches:', resp.Result.TotalMatches
for hit in resp.Result.Matches.Item:
    print '--', hit.Title
\end{verbatim}

Now each section of the code above will be explained.

\begin{verbatim}
from WolframSearchService_services import *
\end{verbatim}

We are primarily interested in the service locator that is imported.  The 
binding proxy and classes for all the messages are additionally imported.
Look at the {\it WolframSearchService_services.py} file for more information.

\begin{verbatim}
loc = WolframSearchServiceLocator()
port = loc.getWolframSearchmyPortType()
\end{verbatim}

Using an instance of the locator, we fetch an instance of the port proxy
which is used for invoking the remote methods provided by the service.  In
this case the default {\it location} specified in the {\it wsdlsoap:address}
element is used.  You can optionally pass a url to the port getter method to
specify an alternate location to be used.  The {\it portType} - {\it name} 
attribute is used to determine the method name to fetch a port proxy instance.
In this example, the port name is {\it WolframSearchmyPortType}, hence the 
method of the locator for fetching the proxy is {\it getWolframSearchmyPortType}.

\begin{verbatim}
req = WolframSearchRequest()
req.Options = req.new_Options()
req.Options.Query = 'newton'
\end{verbatim}

The first step in calling {\it WolframSearch} is to create a request object
corresponding to the input message of the method.  In this case, the name of
the message is {\it WolframSearchRequest}.  A class representing this message
was imported from the service module.

Once a request object is created we need to populate the instance with the
information we want to use in our request.  This is where the {\tt --complexType}
option we passed to wsdl2py will come in handy.  This caused the creation of 
functions for getting and setting elements and attributes of the type, class 
properties for each element, and convenience functions for creating new instances
of elements of complex types.  The following explains these in more detail.

\begin{description}
\item[get/setters] The \var{req} variable has getter and setter methods for the
elements of the type it represents.  {\it WolframSearchRequest's} message type
has only one element, {\it Options}.  Therefore, \var{req} has functions
{\it get_element__Options} and {\it set_element__Options}.

\item[properties] Python 2.2 introduced the concept of class properties.  This
allows a class attribute to transparently call getter and setter methods.  In the
example, {\it req.Options} is a class property which respectively calls 
{\it get_element__Options} and {\it set_element__Options} when requested 
and assigned.

\item[complex type creator methods] The \var{req} object has one element in this
example, Options, which is a complex type.  Classes representing all complex types
in this wsdl were generated by wsdl2py and are located in the types module.  There
are many ways to fetch these classes, but since we know the type of \var{Options}
a convenience function is added to \var{req} to create a new instance of this type,
{\tt new_Options}.  Simple types can simply be assigned to the corresponding python
simple types (eg. {\tt req.Options.Query = 'newton'}).
\end{description}

\begin{verbatim}
resp = port.WolframSearch(req)
\end{verbatim}

Once the request instance is populated, calling the remote service is easy.  Using
the port proxy we call the method we are interested in.  An instance of the python
class representing the return type is returned by this call.  The \var{resp} object
can be used to introspect the result of the remote call.

\begin{verbatim}
resp = port.WolframSearch(req)
\end{verbatim}

Here we see that the response message, \var{resp}, represents type {\it WolframSearchReturn}.
This object has one element, {\it Result} which contains the search results for our
search of the keyword, {\tt newton}.

\begin{verbatim}
print 'Search Time:', resp.Result.SearchTime
...
\end{verbatim}

Refer to the wsdl for {\it WolframSearchService} for more details on the returned information.