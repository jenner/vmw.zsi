<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<link rel="STYLESHEET" href="zsi.css" type='text/css'>
<link rel="first" href="zsi.html" title='ZSI: The Zolera Soap Infrastructure'>
<link rel='contents' href='zsi.html' title="Contents">
<link rel='last' href='about.html' title='About this document...'>
<link rel='help' href='about.html' title='About this document...'>
<meta name='aesop' content='information'>
<META NAME="description" CONTENT="ZSI: The Zolera Soap Infrastructure">
<META NAME="keywords" CONTENT="zsi">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<title>ZSI: The Zolera Soap Infrastructure</title>
</head>
<body>
<DIV CLASS="navigation">
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td><img src='blank.gif'
  border='0' height='32'  alt='' width='32'></td>
<td><img src='blank.gif'
  border='0' height='32'  alt='' width='32'></td>
<td><img src='blank.gif'
  border='0' height='32'  alt='' width='32'></td>
<td align="center" width="100%">ZSI: The Zolera Soap Infrastructure</td>
<td><img src='blank.gif'
  border='0' height='32'  alt='' width='32'></td>
</tr></table>
<br><hr>
</DIV>
<!--End of Navigation Panel-->

<P>

<div class="titlepage">
<center>
<h1>ZSI: The Zolera Soap Infrastructure</h1>
<p><b><font size="+2">Rich Salz,</font></b></p>
<p>
<span class="email">rsalz@datapower.com
<BR>
blunck@python.org</span>
</p>
<p><i>        Christopher Blunck</i></p>
<p><strong>Release 1.7.0</strong><br>
<strong>February 16, 2005</strong></p>
<p>
</center>
</div>

<P>
<DIV CLASS="centerline" ID="par4247" ALIGN="CENTER">
<b>ABSTRACT</b></DIV>

<P>
<tt class="module">ZSI</tt>, the Zolera SOAP Infrastructure, is a Python package that
provides an implementation of SOAP messaging, as described in
<em class="citetitle"><a
 href="http://www.w3.org/TR/soap"
 title="The SOAP 1.1 Specification"
 >The SOAP 1.1 Specification</a></em>.
In particular, <tt class="module">ZSI</tt> parses and generates SOAP messages, and
converts between native Python datatypes and SOAP syntax.
It can also be used to build applications using
<em class="citetitle"><a
 href="http://www.w3.org/TR/SOAP-attachments"
 title="SOAP Messages with
Attachments"
 >SOAP Messages with
Attachments</a></em>.
<tt class="module">ZSI</tt> is ``transport neutral'', and provides only a simple
I/O and dispatch framework; a more complete solution is the
responsibility of the application using <tt class="module">ZSI</tt>.
As usage patterns emerge, and common application frameworks are
more understood, this may change.

<P>
<tt class="module">ZSI</tt> requires Python 2.0 or later and PyXML version 0.6.6 or later.

<P>
The <tt class="module">ZSI</tt> homepage is at <a class="url" href="http://pywebsvcs.sf.net/">http://pywebsvcs.sf.net/</a>.

<P>

<P>
<DIV CLASS="centerline" ID="par4248" ALIGN="CENTER">
<b>COPYRIGHT</b></DIV>

<P>
Copyright &#169; 2001, Zolera Systems, Inc.
<BR>
All Rights Reserved.

<P>
Copyright &#169; 2002-2003, Rich Salz.
<BR>
All Rights Reserved.

<P>
Permission is hereby granted, free of charge, to any person obtaining a
copy of this software and associated documentation files (the "Software"),
to deal in the Software without restriction, including without limitation
the rights to use, copy, modify, merge, publish, distribute, and/or
sell copies of the Software, and to permit persons to whom the Software
is furnished to do so, provided that the above copyright notice(s) and
this permission notice appear in all copies of the Software and that
both the above copyright notice(s) and this permission notice appear in
supporting documentation.

<P>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF THIRD PARTY RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS
INCLUDED IN THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT
OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE
OR PERFORMANCE OF THIS SOFTWARE.

<P>
Except as contained in this notice, the name of a copyright holder
shall not be used in advertising or otherwise to promote the sale, use
or other dealings in this Software without prior written authorization
of the copyright holder.

<P>

<P>
<DIV CLASS="centerline" ID="par4249" ALIGN="CENTER">
<b>Acknowledgments</b></DIV>

<P>
We are grateful to the members of the <code>soapbuilders</code>
mailing list (see <a class="url" href="http://groups.yahoo.com/soapbuilders">http://groups.yahoo.com/soapbuilders</a>),
Frederick Lundh for his <code>soaplib</code> package (see
<a class="url" href="http://www.secretlabs.com/downloads/index.htm#soap">http://www.secretlabs.com/downloads/index.htm#soap</a>),
Cayce Ullman and Brian Matthews for their <code>SOAP.py</code> package
(see <a class="url" href="http://sourceforge.net/projects/pywebsvcs">http://sourceforge.net/projects/pywebsvcs</a>).

<P>
We are particularly grateful to Brian Lloyd and the Zope Corporation
(<a class="url" href="http://www.zope.com">http://www.zope.com</a>) for letting us incorporate his ZOPE
WebServices package and documentation into <tt class="module">ZSI</tt>.

<P>
<BR>
<BR><H2><A NAME="SECTION001000000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL CLASS="TofC">
<LI><A href="zsi.html#SECTION002000000000000000000">1. Introduction</a>
<UL>
<LI><A href="zsi.html#SECTION002100000000000000000">1.1 How to Read this Document</a>
</ul>
<LI><A href="zsi.html#SECTION003000000000000000000">2. Examples</a>
<UL>
<LI><A href="zsi.html#SECTION003100000000000000000">2.1 Server Side Examples</a>
<UL>
<LI><A href="zsi.html#SECTION003110000000000000000">2.1.1 Simple example</a>
<LI><A href="zsi.html#SECTION003120000000000000000">2.1.2 More complex example</a>
<LI><A href="zsi.html#SECTION003130000000000000000">2.1.3 A mod_python example</a>
</ul>
<LI><A href="zsi.html#SECTION003200000000000000000">2.2 Client Side Examples</a>
<UL>
<LI><A href="zsi.html#SECTION003210000000000000000">2.2.1 Simple Example</a>
<LI><A href="zsi.html#SECTION003220000000000000000">2.2.2 Complex Example</a>
</ul>
</ul>
<LI><A href="zsi.html#SECTION004000000000000000000">3. Exceptions</a>
<LI><A href="zsi.html#SECTION005000000000000000000">4. Utilities</a>
<UL>
<LI><A href="zsi.html#SECTION005100000000000000000">4.1 Low-Level Utilities</a>
</ul>
<LI><A href="zsi.html#SECTION006000000000000000000">5. The ParsedSoap module -- basic message handling</a>
<LI><A href="zsi.html#SECTION007000000000000000000">6. The TypeCode classes -- data conversions</a>
<UL>
<LI><A href="zsi.html#SECTION007100000000000000000">6.1 TC.Any -- the basis of dynamic typing</a>
<LI><A href="zsi.html#SECTION007200000000000000000">6.2 Void</a>
<LI><A href="zsi.html#SECTION007300000000000000000">6.3 Strings</a>
<LI><A href="zsi.html#SECTION007400000000000000000">6.4 Integers</a>
<LI><A href="zsi.html#SECTION007500000000000000000">6.5 Floating-point Numbers</a>
<LI><A href="zsi.html#SECTION007600000000000000000">6.6 Dates and Times</a>
<LI><A href="zsi.html#SECTION007700000000000000000">6.7 Boolean</a>
<LI><A href="zsi.html#SECTION007800000000000000000">6.8 XML</a>
<LI><A href="zsi.html#SECTION007900000000000000000">6.9 Struct</a>
<LI><A href="zsi.html#SECTION0071000000000000000000">6.10 Choice</a>
<LI><A href="zsi.html#SECTION0071100000000000000000">6.11 Arrays</a>
<LI><A href="zsi.html#SECTION0071200000000000000000">6.12 Apache Datatype</a>
</ul>
<LI><A href="zsi.html#SECTION008000000000000000000">7. The SoapWriter module -- serializing data</a>
<LI><A href="zsi.html#SECTION009000000000000000000">8. The Fault module -- reporting errors</a>
<LI><A href="zsi.html#SECTION0010000000000000000000">9. The resolvers module -- fetching remote data</a>
<LI><A href="zsi.html#SECTION0011000000000000000000">10. Dispatching and Invoking</a>
<UL>
<LI><A href="zsi.html#SECTION0011100000000000000000">10.1 Dispatching</a>
<LI><A href="zsi.html#SECTION0011200000000000000000">10.2 The client module -- sending SOAP messages</a>
</ul>
<LI><A href="zsi.html#SECTION0012000000000000000000">11. WSDL Support</a>
<UL>
<LI><A href="zsi.html#SECTION0012100000000000000000">11.1 WSDLReader</a>
<LI><A href="zsi.html#SECTION0012200000000000000000">11.2 ServiceProxy</a>
<UL>
<LI><A href="zsi.html#SECTION0012210000000000000000">11.2.1 Example</a>
</ul>
<LI><A href="zsi.html#SECTION0012300000000000000000">11.3 Code Generation from WSDL and XML Schema</a>
<UL>
<LI><A href="zsi.html#SECTION0012310000000000000000">11.3.1 WriteServiceModule Class Description</a>
<LI><A href="zsi.html#SECTION0012320000000000000000">11.3.2 Example Use of Generated Code</a>
</ul>
<LI><A href="zsi.html#SECTION0012400000000000000000">11.4 WSDL objects</a>
<UL>
<LI><A href="zsi.html#SECTION0012410000000000000000">11.4.1 Binding Classes</a>
</ul>
</ul>
<LI><A href="zsi.html#SECTION0013000000000000000000">12. ZSI Schema</a>
</ul>
<!--End of Table of Contents-->
<P>

<H1><A NAME="SECTION002000000000000000000">
1. Introduction</A>
</H1>

<P>
<tt class="module">ZSI</tt>, the Zolera SOAP Infrastructure, is a Python package that
provides an implementation of the SOAP specification, as described in
<em class="citetitle"><a
 href="http://www.w3.org/TR/soap"
 title="The SOAP 1.1 Specification"
 >The SOAP 1.1 Specification</a></em>.
In particular, <tt class="module">ZSI</tt> parses and generates SOAP messages, and
converts between native Python datatypes and SOAP syntax.

<P>
<tt class="module">ZSI</tt> requires Python 2.0 or later and PyXML version 0.6.6 or later.

<P>
The <tt class="module">ZSI</tt> project is maintained at SourceForge, at
<a class="url" href="http://pywebsvcs.sf.net">http://pywebsvcs.sf.net</a>.
<tt class="module">ZSI</tt> is discussed on the Python web services mailing list, visit
<a class="url" href="http://lists.sourceforge.net/lists/listinfo/pywebsvcs-talk">http://lists.sourceforge.net/lists/listinfo/pywebsvcs-talk</a>to subscribe.

<P>
For those interested in a high-level tutorial covering <tt class="module">ZSI</tt> and why
Python was chosen, see the article
<a class="url" href="http://www.xml.com/pub/a/ws/2002/06/12/soap.html">http://www.xml.com/pub/a/ws/2002/06/12/soap.html</a>, 
written by Rich Salz for xml.com.

<P>
SOAP-based processing typically involves several steps.
The following list details the steps of a common processing model naturally
supported by <tt class="module">ZSI</tt> (other models are certainly possible):

<OL>
<LI><tt class="module">ZSI</tt> takes data from an input stream and <i>parses</i> it, generating
    a DOM-based parse tree as part of creating a <tt class="class">ParsedSoap</tt> object.
    At this point the major syntactic elements of a SOAP message -- the
    <code>Header</code>, the <code>Body</code>, etc. -- are available.
</LI>
<LI>The application does <i>header processing</i>.
    More specifically, it does local dispatch and processing based on
    the elements in the SOAP <code>Header</code>.
    The SOAP <code>actor</code> and <code>mustUnderstand</code> attributes are
    also handled (or at least recognized) here.
</LI>
<LI><tt class="module">ZSI</tt> next <i>parses</i> the <code>Body</code>, creating local Python objects
    from the data in the SOAP message.
    The parsing is often under the control of a list of data descriptions,
    known as <i>typecodes</i>, defined by the application because it knows
    what type of data it is expecting.
    In cases where the SOAP data is known to be completely self-describing,
    the parsing can be <i>dynamic</i> through the use of the <tt class="class">TC.Any</tt>
    class.
</LI>
<LI>The application now <i>dispatches</i> to the appropriate handler
    in order to do its ``real work.''
    As part of its processing it may create <i>output objects</i>
</LI>
<LI>The application creates a <tt class="class">SoapWriter</tt> instance and outputs
    an initial set of namespace entries and header elements.
</LI>
<LI>Any local data to be sent back to the client is <i>serialized</i>.
    As with <code>Body</code> parsing, the datatypes can be described through
    typecodes or determined dynamically (here, through introspection).
</LI>
<LI>In the event of any processing exceptions, a <tt class="class">Fault</tt> object
    can be raised, created, and/or serialized.
</LI>
</OL>

<P>
Note that <tt class="module">ZSI</tt> is ``transport neutral'', and provides only a simple
I/O and dispatch framework; a more complete solution is the
responsibility of the application using <tt class="module">ZSI</tt>.
As usage patterns emerge, and common application frameworks are
more understood, this may change.

<P>
Within this document, <code>tns</code> is used as the prefix for the
application's target namespace, and the term
<i>element</i> refers to a DOM element node.)

<P>

<H1><A NAME="SECTION002100000000000000000">
1.1 How to Read this Document</A>
</H1>

<P>
Readers only interested in developing the simplest SOAP applications,
or spending the least amount of time on building a web services
infrastructure, should read chapters 2, 3, and 10.
Readers who are developing complex services, and who are familiar
with XML Schema and/or WSDL, should read this manual in order.
This will provide them with enough information to implement the
processing model described above.
They can skip probably skip chapters 2 and 10.

<P>
This release of <tt class="module">ZSI</tt> adds the capability to 
process WSDL definitions (described in
<em class="citetitle"><a
 href="http://www.w3.org/TR/wsdl"
 title="The Web Services Description Language"
 >The Web Services Description Language</a></em>)
and generate typecodes automatically.  See chapter 11
for details.

<H1><A NAME="SECTION003000000000000000000">
2. Examples</A>
</H1>

<P>
This chapter contains a number of examples to show off some of <tt class="module">ZSI</tt>'s
features.
It is broken down into client-side and server-side examples, and
explores different implementation options <tt class="module">ZSI</tt> provides.

<P>

<H1><A NAME="SECTION003100000000000000000">
2.1 Server Side Examples</A>
</H1>

<H2><A NAME="SECTION003110000000000000000">
2.1.1 Simple example</A>
</H2>
Using the <tt class="module">ZSI.cgi</tt> module, it is simple to expose Python
functions as web services.
Each function is invoked with all the input parameters specified in the
client's SOAP request.
Any value returned by the function will be serialized back to the client;
multiple values can be returned by returning a tuple.

<P>
The following code shows some simple services:

<P>
<div class="verbatim"><pre>
def hello():
    return "Hello, world"

def echo(*args):
    return args

def average(*args):
    sum = 0
    for i in args: sum += i
    return sum / len(args)

from ZSI import dispatch
dispatch.AsCGI()
</pre></div>

<P>
Each function defines a SOAP request, so if this script is installed
as a CGI script, a SOAP message can be posted to that script's URL with any of
<code>hello</code>, <code>echo</code>, or <code>average</code> as the request element,
and the value returned by the function will be sent back.

<P>
The <tt class="module">ZSI</tt> CGI dispatcher catches exceptions and sends back a SOAP fault.
For example, a fault will be sent if the  <code>hello</code> function is given any
arguments, or if the <code>average</code> function is given a non-integer.

<P>

<H2><A NAME="SECTION003120000000000000000">
2.1.2 More complex example</A>
</H2>

<P>
We will now show a more complete example of a robust web service.
It takes as input a player name and array of integers, and returns
the average.
It is presented in sections, following the steps detailed above.

<P>
The first section reads in a request, and parses the SOAP header.

<P>
<div class="verbatim"><pre>
from ZSI import *
import sys
IN, OUT = sys.stdin, sys.stdout

try:
    ps = ParsedSoap(IN)
except ParseException, e:
    FaultFromZSIException(e).AsSOAP(OUT)
    sys.exit(1)
except Exception, e:
    # Faulted while processing; we assume it's in the header.
    FaultFromException(e, 1).AsSOAP(OUT)
    sys.exit(1)

# We are not prepared to handle any actors or mustUnderstand elements,
# so we'll arbitrarily fault back with the first one we found.
a = ps.WhatActorsArePresent()
if len(a):
    FaultFromActor(a[0]).AsSOAP(OUT)
    sys.exit(1)
mu = ps.WhatMustIUnderstand()
if len(mu):
    uri, localname = mu[0]
    FaultFromNotUnderstood(uri, localname).AsSOAP(OUT)
    sys.exit(1)
</pre></div>

<P>
This section defines the mappings between Python objects and the SOAP
data being transmitted.
Recall that according to the SOAP specification, RPC input and output
are modeled as a structure.

<P>
<div class="verbatim"><pre>
class Player:
    def __init__(self, name):
        pass
Player.typecode = TC.Struct(Player, [
                                TC.String('Name'),
                                TC.Array('Integer', TC.Integer(), 'Scores'),
                                ], 'GetAverage')
class Average:
    def __init__(self, average):
        self.average = average
Average.typecode = TC.Struct(Average, [
                                TC.Integer('average'),
                                ], 'GetAverageResponse')
</pre></div>

<P>
This section parses the input, performs the application-level
activity, and serializes the response.
<div class="verbatim"><pre>
try:
    player = ps.Parse(Player.typecode)
except EvaluateException, e:
    FaultFromZSIException(e).AsSOAP(OUT)
    sys.exit(1)

try:
    total = 0
    for value in player.Scores: total = total + value
    result = Average(total / len(player.Scores))
    sw = SoapWriter(OUT)
    sw.serialize(result, Average.typecode)
    sw.close()
except Exception, e:
    FaultFromException(e, 0, sys.exc_info()[2]).AsSOAP(OUT)
    sys.exit(1)
</pre></div>

<P>
In the <tt class="method">serialize()</tt> call above, the second parameter is optional,
since <code>result</code> is an instance of the 
<tt class="class">Average</tt> class, and the <code>Average.typecode</code> attribute is
the typecode for class instances.
In addition, since the <tt class="class">SoapWriter</tt> destructor will call <tt class="method">close()</tt>
if necessary, sending a SOAP response can often be written like
this one-liner:
<div class="verbatim"><pre>
SoapWriter(OUT).serialize(result)
</pre></div>

<P>

<H2><A NAME="SECTION003130000000000000000">
2.1.3 A mod_python example</A>
</H2>

<P>
The Apache module <code>mod_python</code> (see
<a class="url" href="http://www.modpython.org">http://www.modpython.org</a>) embeds Python within the Apache server.
In order to expose operations within a module via mod_python, use the 
<tt class="method">dispatch.AsHandler()</tt> function.  The <tt class="method">dispatch.AsHandler()</tt>
function will dispatch requests to any operation defined in the module you
pass it, which allows for multiple operations to be defined in a module.
The only trick is to use __import__ to load the XML encodings your service 
expects.  This is a required workaround to avoid the pitfalls of restricted
execution with respect to XML parsing.

<P>
The following is a complete example of a simple handler.  The soap operations
are implemented in the MyHandler module:

<P>
<div class="verbatim"><pre>
def hello():
    return "Hello, world"

def echo(*args):
    return args

def average(*args):
    sum = 0
    for i in args: sum += i
    return sum / len(args)
</pre></div>

<P>
Dispatching from within mod_python is achieved by passing the aforementined
MyHandler module to <code>dispatch.AsHandler()</code>.  The following code exposes
the operations defined in MyHandler via SOAP:

<P>
<div class="verbatim"><pre>
from ZSI import dispatch
from mod_python import apache

import MyHandler
mod = __import__('encodings.utf_8', globals(), locals(), '*')
mod = __import__('encodings.utf_16_be', globals(), locals(), '*')

def handler(req):
    dispatch.AsHandler(modules=(MyHandler,), request=req)
    return apache.OK
</pre></div>

<P>

<H1><A NAME="SECTION003200000000000000000">
2.2 Client Side Examples</A>
</H1>

<P>

<H2><A NAME="SECTION003210000000000000000">
2.2.1 Simple Example</A>
</H2>
<tt class="module">ZSI</tt> provides two ways for a client to interactive with a server:
the <tt class="class">Binding</tt> class and the <tt class="class">ServiceProxy</tt> class.
The first is useful when the operations to be invoked are not defined
in WSDL or when only simple Python datatypes are used; the <tt class="class">ServiceProxy</tt>
class can be used to parse WSDL definitions in order
to determine how to serialize and parse the SOAP messages.

<P>
During development, it is often useful to record ``packet traces'' of
the SOAP messages being exchanged.
Both the <tt class="class">Binding</tt> and <tt class="class">ServiceProxy</tt> classes provide a
<code>tracefile</code> parameter to specify an output stream (such as a file)
to capture messages.
It can be particularly useful when debugging unexpected SOAP faults.

<P>
The first example provided below demonstrates how to use the <tt class="class">Binding</tt>
class to connect to a remote service and perform an operation.  It assumes
that the simple server-side example shown above is installed on the webserver 
running on the local host, and if the URL is <code>/cgi-bin/simple-test</code>:

<P>
<div class="verbatim"><pre>
from ZSI.client import Binding
fp = open('debug.out', 'a')
b = Binding(url='/cgi-bin/simple-test', tracefile=fp)
fp.close()
a = b.average(range(1,11))
assert a == 5
print b.hello()
</pre></div>

<P>

<H2><A NAME="SECTION003220000000000000000">
2.2.2 Complex Example</A>
</H2>
If the operation invoked returns a ComplexType, typecode information must
be provided in order to tell <tt class="module">ZSI</tt> how to deserialize the response.
Here is a sample server-side implementation:

<P>
<div class="verbatim"><pre>
# Complex type definition
class Person:
  def __init__(self, name=None, age=0):
    self.name = name
    self.age = age

Person.typecode = TC.Struct(Person,
			    [TC.String('name'),
			     TC.InonNegativeInteger('age')],
			    'myApp:Person')

# my web service that returns a complex structure
def getPerson(name):
  fp = open('%s.person.pickle', % name, 'r')
  return pickle.load(fp)

# my web service that accepts a complex structure
def savePerson(person):
  fp = open('%s.person.pickle' % person.name, 'w')
  pickle(person, fp)
  fp.close()
</pre></div>

<P>
In order for <tt class="module">ZSI</tt> to transparently deserialize the returned complex type into
a <tt class="class">Person</tt> instance, a module defining the class and its typecode must
be appended to the <var>ZSI.Path</var> list.
It is also possible to explicitly tell <tt class="module">ZSI</tt> what class and typecode to
use by passing the class as a parameter to the
<tt class="method">Binding.Receive()</tt> method.
The first method is often preferred, particularly for publically-distributed
libraries.

<P>
The following fragment shows both styles:

<P>
<div class="verbatim"><pre>
from ZSI.client import Binding
from ZSI import Path

# Explicitly stating what to get back.
from MyComplexTypes import Person
a = apply(b.getPerson, 'christopher')
person = b.Receive(Person)

# Transparent deserialization
import MyComplexTypes
b = Binding(url='/cgi-bin/complex-test', typesmodule=MyComplexTypes)
person = b.getPerson('christopher')
</pre></div>

<P>
Because the returned complex type is defined in a class registered in 
<var>ZSI.Path</var>, transparent deserialization is possible.  When sending
complex types to the server, it is not necessary to list the module
in <var>ZSI.Path</var>:

<P>
<div class="verbatim"><pre>
from ZSI.client import Binding
b = Binding(url='/cgi-bin/complex-test')
person = Person('christopher', 26)
b.savePerson(person)
</pre></div>

<H1><A NAME="SECTION004000000000000000000">
3. Exceptions</A>
</H1>

<P>
<tt class="module">ZSI</tt> defines two exception classes.

<P>
<dl><dt><b><span class="typelabel">exception</span>&nbsp;<a name="l2h-1"><tt class="exception">ParseException</tt></a></b>
<dd>
<tt class="module">ZSI</tt> can raise this exception while creating a <tt class="class">ParsedSoap</tt> object.
It is a subtype of Python's <tt class="exception">Exception</tt> class.
The string form of a <tt class="exception">ParseException</tt> object consists of a
line of human-readable text.
If the backtrace is available, it will be concatenated as a second line.
</dl>

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-2"><tt class="member">inheader</tt></a></b>
<dd>
A boolean that indicates if the error was detected in the SOAP <code>Header</code>
element.
</dl>

<P>
<dl><dt><b><a name="l2h-3"><tt class="member">str</tt></a></b>
<dd>
A text string describing the error.
</dl>

<P>
<dl><dt><b><a name="l2h-4"><tt class="member">trace</tt></a></b>
<dd>
A text string containing a backtrace to the error.
This may be <code>None</code> if it was not possible, such as when there was
a general DOM exception, or when the <code>str</code> text is believed to be
sufficient.
</dl>

<P>
<dl><dt><b><span class="typelabel">exception</span>&nbsp;<a name="l2h-5"><tt class="exception">EvaluateException</tt></a></b>
<dd>
This exception is similar to <tt class="exception">ParseException</tt>, except
that <tt class="module">ZSI</tt> may raise it while converting between SOAP and local
Python objects.
</dl>

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-6"><tt class="member">str</tt></a></b>
<dd>
A text string describing the error.
</dl>

<P>
<dl><dt><b><a name="l2h-7"><tt class="member">trace</tt></a></b>
<dd>
A text backtrace, as described above for <tt class="exception">ParseException</tt>.
</dl>

<H1><A NAME="SECTION005000000000000000000">
4. Utilities</A>
</H1>

<P>
<tt class="module">ZSI</tt> defines some utility methods that general applications
may want to use.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-8"><tt class="function">Version</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Returns a three-element tuple containing the numbers representing the
major, minor, and release identifying the <tt class="module">ZSI</tt> version.

<span class="versionnote">New in version 1.1.</span>

</dl>

<P>

<H1><A NAME="SECTION005100000000000000000">
4.1 Low-Level Utilities</A>
</H1>

<P>
<tt class="module">ZSI</tt> also defines some low-level utilities for its own use that
start with a leading underscore and must be imported explicitly.
They are documented here because they can be useful for developing
new typecode classes.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-9"><tt class="function">_valid_encoding</tt></a></b>(</nobr></td>
  <td><var>elt</var>)</td></tr></table>
<dd>
Return true if the element <code>elt</code> has a SOAP encoding
that can be handled by <tt class="module">ZSI</tt>
(currently Section 5 of the SOAP 1.1 specification or an empty encoding
for XML).
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-10"><tt class="function">_backtrace</tt></a></b>(</nobr></td>
  <td><var>elt, dom</var>)</td></tr></table>
<dd>
This function returns a text string that traces a ``path'' from <code>dom</code>,
a DOM root, to <code>elt</code>, an element within that document, in
XPath syntax.
</dl>

<P>
Some <code>lambda</code>'s are defined so that some DOM accessors
will return an empty list rather than <code>None</code>.
This means that rather than writing:
<div class="verbatim"><pre>
if elt.childNodes:
   for N in elt.childNodes:
      ...
</pre></div>
One can write:
<div class="verbatim"><pre>
for N in _children(elt):
   ...
</pre></div>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-11"><tt class="function">_children</tt></a></b>(</nobr></td>
  <td><var>element</var>)</td></tr></table>
<dd>
Returns a list of all children of the specified <code>element</code>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-12"><tt class="function">_attrs</tt></a></b>(</nobr></td>
  <td><var>element</var>)</td></tr></table>
<dd>
Returns a list of all attributes of the specified <code>element</code>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-13"><tt class="function">_child_elements</tt></a></b>(</nobr></td>
  <td><var>element</var>)</td></tr></table>
<dd>
Returns a list of all children elements of the specified <code>element</code>.
</dl>

<P>
Other <code>lambda</code>'s return SOAP-related attributes from an element,
or <code>None</code> if not present.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-14"><tt class="function">_find_arraytype</tt></a></b>(</nobr></td>
  <td><var>element</var>)</td></tr></table>
<dd>
The value of the SOAP <code>arrayType</code> attribute.

<span class="versionnote">New in version 1.2.</span>

</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-15"><tt class="function">_find_attr</tt></a></b>(</nobr></td>
  <td><var>element, name</var>)</td></tr></table>
<dd>
The value of the unqualified <code>name</code> attribute.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-16"><tt class="function">_find_encstyle</tt></a></b>(</nobr></td>
  <td><var>element</var>)</td></tr></table>
<dd>
The value of the SOAP <code>encodingStyle</code> attribute.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-17"><tt class="function">_find_href</tt></a></b>(</nobr></td>
  <td><var>element</var>)</td></tr></table>
<dd>
The value of the unqualified <code>href</code> attribute.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-18"><tt class="function">_find_type</tt></a></b>(</nobr></td>
  <td><var>element</var>)</td></tr></table>
<dd>
The value of the XML Schema <code>type</code> attribute.
</dl>

<H1><A NAME="SECTION006000000000000000000">
5. The <tt class="module">ParsedSoap</tt> module -- basic message handling</A>
</H1>

<P>
This class represents an input stream that has been parsed as a SOAP
message.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-19"><tt class="class">ParsedSoap</tt></a></b>(</nobr></td>
  <td><var>input</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
Creates a <tt class="class">ParsedSoap</tt> object from the provided input source.
If <code>input</code> is not a string, then it must be an object with a
<tt class="method">read()</tt> method that supports the standard Python ``file read''
semantics.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>keepdom</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">Do not release the DOM when this
object is destroyed. To access the DOM object, use the
<tt class="method">GetDomAndReader()</tt> method. The reader object is necessary to 
properly free the DOM structure using <tt class="method">reader.releaseNode(dom)</tt>.

<span class="versionnote">New in version 1.2.</span>
</td>
    <tr><td align="left" valign="baseline"><code>readerclass</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">Class used to create DOM-creating
XML readers; described below.

<span class="versionnote">New in version 1.2.</span>
</td>
    <tr><td align="left" valign="baseline"><code>resolver</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">Value for the <code>resolver</code>
attribute; see below.</td>
    <tr><td align="left" valign="baseline"><code>trailers</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">Allow trailing data elements
to appear after the <code>Body</code>.</td></tbody>
</table>

<P>
</dl>

<P>
The following attributes of a <tt class="class">ParsedSoap</tt> are read-only:

<P>
<dl><dt><b><a name="l2h-20"><tt class="member">body</tt></a></b>
<dd>
The root of the SOAP <code>Body</code> element.
Using the <tt class="method">GetElementNSdict()</tt> method on this attribute can be useful
to get a dictionary to be used with the <tt class="class">SoapWriter</tt> class.
</dl>

<P>
<dl><dt><b><a name="l2h-21"><tt class="member">body_root</tt></a></b>
<dd>
The element that contains the SOAP serialization root; that is,
the element in the SOAP <code>Body</code> that ``starts off'' the data.
</dl>

<P>
<dl><dt><b><a name="l2h-22"><tt class="member">data_elements</tt></a></b>
<dd>
A (possibly empty) list of all child elements of the <code>Body</code> other
than the root.
</dl>

<P>
<dl><dt><b><a name="l2h-23"><tt class="member">header</tt></a></b>
<dd>
The root of the SOAP <code>Header</code> element.
Using the <tt class="method">GetElementNSdict()</tt> method on this attribute can be useful
to get a dictionary to be used with the <tt class="class">SoapWriter</tt> class.
</dl>

<P>
<dl><dt><b><a name="l2h-24"><tt class="member">header_elements</tt></a></b>
<dd>
A (possibly empty) list of all elements in the SOAP <code>Header</code>.
</dl>

<P>
<dl><dt><b><a name="l2h-25"><tt class="member">trailer_elements</tt></a></b>
<dd>
Returns a (possibly empty) list of all elements following the <code>Body</code>.
If the <code>trailers</code> keyword was not used when the object was
constructed, this attribute will not be instantiated and retrieving
it will raise an exception.
</dl>

<P>
The following attribute may be modified:

<P>
<dl><dt><b><a name="l2h-26"><tt class="member">resolver</tt></a></b>
<dd>
If not <code>None</code>,
this attribute can be invoked to handle absolute <code>href</code>'s in the SOAP data.
It will be invoked as follows:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-27"><tt class="method">resolver</tt></a></b>(</nobr></td>
  <td><var>uri, tc, ps, **keywords</var>)</td></tr></table>
<dd>
The <code>uri</code> parameter is the URI to resolve.
The <code>tc</code> parameter is the typecode that needs to resolve <code>href</code>; this
may be needed to properly interpret the content of a MIME bodypart, for example.
The <code>ps</code> parameter is the <tt class="class">ParsedSoap</tt> object that is invoking
the resolution (this allows a single resolver instance to handle multiple
SOAP parsers).

<P>
Failure to resolve the URI should result in an exception being raised.
If there is no content, return <code>None</code>; this is not the same as an
empty string.
If there is content, the data returned should be in a form understandable
by the typecode.
</dl>
</dl>

<P>
The following methods are available:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-28"><tt class="method">Backtrace</tt></a></b>(</nobr></td>
  <td><var>elt</var>)</td></tr></table>
<dd>
Returns a human-readable ``trace'' from the document root to the
specified element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-29"><tt class="method">FindLocalHREF</tt></a></b>(</nobr></td>
  <td><var>href, elt</var>)</td></tr></table>
<dd>
Returns the element that has an <code>id</code> attribute whose value is specified
by the <code>href</code> fragment identifier.
The <code>href</code> <i>must</i> be a fragment reference -- that is, it must
start with a pound sign.
This method raises an <tt class="exception">EvaluateException</tt> exception if the
element isn't found.
It is mainly for use by the parsing methods in the <tt class="module">TypeCode</tt> module.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-30"><tt class="method">GetElementNSdict</tt></a></b>(</nobr></td>
  <td><var>elt</var>)</td></tr></table>
<dd>
Return a dictionary for all the namespace entries active at the
current element. Each dictionary key will be the prefix and the value will
be the namespace URI.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-31"><tt class="method">GetMyHeaderElements</tt></a></b>(</nobr></td>
  <td><big>[</big><var>actorlist=None</var><big>]</big>)</td></tr></table>
<dd>
Returns a list of all elements in the <code>Header</code> that are intended for
<i>this</i> SOAP processor.
This includes all elements that either have no SOAP <code>actor</code>
attribute, or whose value is either the special ``next actor'' value or
in the <code>actorlist</code> list of URI's.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-32"><tt class="method">GetDomAndReader</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Returns a tuple containing the dom and reader objects, <code>(dom, reader)</code>.
Unless keepdom is true, the dom and reader objects will go out of scope
when the ParsedSoap instance is deleted. If keepdom is true, the reader
object is needed to properly clean up the dom tree with 
<tt class="method">reader.releaseNode(dom)</tt>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-33"><tt class="method">IsAFault</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Returns true if the message is a SOAP fault.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-34"><tt class="method">Parse</tt></a></b>(</nobr></td>
  <td><var>how</var>)</td></tr></table>
<dd>
Parses the SOAP <code>Body</code> according to the <code>how</code> parameter,
and returns a Python object.
If <code>how</code> is not a <tt class="class">TC.TypeCode</tt> object, then it should be a
Python class object that has a <code>typecode</code> attribute.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-35"><tt class="method">ResolveHREF</tt></a></b>(</nobr></td>
  <td><var>uri, tc</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
This method is invoked to resolve an absolute URI.
If the typecode <code>tc</code> has a <code>resolver</code> attribute, it will use it
to resolve the URI specified in the <code>uri</code> parameter,
otherwise it will use its own <code>resolver</code>, or raise an
<tt class="exception">EvaluateException</tt> exception.

<P>
Any <code>keyword</code> parameters will be passed to the chosen resolver.
If no content is available, it will return <code>None</code>.
If unable to resolve the URI it will raise an
<tt class="exception">EvaluateException</tt> exception.
Otherwise, the resolver should return data in a form acceptable to the
specified typecode, <code>tc</code>.
(This will almost always be a file-like object holding opaque data;
for XML, it may be a DOM tree.)
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-36"><tt class="method">WhatActorsArePresent</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Returns a list of the values of all the SOAP <code>actor</code> attributes
found in child elements of the SOAP <code>Header</code>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-37"><tt class="method">WhatMustIUnderstand</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Returns a list of "<tt class="samp">(uri, localname)</tt>" tuples for all elements in the
SOAP <code>Header</code> that have the SOAP <code>mustUnderstand</code> attribute set
to a non-zero value.
</dl>

<P>
<tt class="module">ZSI</tt> supports multiple DOM implementations.
The <code>readerclass</code> parameter specifies which one to use.
The default is to use the DOM provided with the PyXML package developed
by the Python XML SIG, provided through the <tt class="class">PyExpat.Reader</tt> class
in the <tt class="module">xml.dom.ext.reader</tt> module.

<P>
The specified reader class must support the following methods:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-38"><tt class="method">fromString</tt></a></b>(</nobr></td>
  <td><var>string</var>)</td></tr></table>
<dd>
Return a DOM object from a string.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-39"><tt class="method">fromStream</tt></a></b>(</nobr></td>
  <td><var>stream</var>)</td></tr></table>
<dd>
Return a DOM object from a file-like stream.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-40"><tt class="method">releaseNode</tt></a></b>(</nobr></td>
  <td><var>dom</var>)</td></tr></table>
<dd>
Free the specified DOM object.
</dl>

<P>
The DOM object must support the standard Python mapping of the DOM Level 2
specification.
While only a small subset of specification is used, the particular
methods and attributes used by <tt class="module">ZSI</tt> are available only
by inspecting the source.

<P>
To use the <code>cDomlette</code> DOM provided by the 4Suite package, use the
<tt class="class">NonvalidatingReader</tt> class in the <tt class="module">Ft.Xml.Domlette</tt> module.
Due to name changes in the 1.0 version of 4Suite, a simple adapter class
is required to use this DOM implementation. 

<P>
<div class="verbatim"><pre>
from 4Suite.Xml.Domlette import NonvalidatingReaderBase

class 4SuiteAdapterReader(NonvalidatingReaderBase):

    def fromString(self, str):
        return self.parseString(str)

    def fromStream(self, stream):
        return self.parseStream(stream)

    def releaseNode(self, node):
        pass
</pre></div>

<H1><A NAME="SECTION007000000000000000000">
6. The <tt class="module">TypeCode</tt> classes -- data conversions</A>
</H1>

<P>
The <tt class="module">TypeCode</tt> module defines classes used for converting data
between SOAP data and local Python objects.
Python numeric and string types, and sequences and dictionaries, are
supported by <tt class="module">ZSI</tt>.
The <tt class="class">TC.TypeCode</tt> class is the parent class of all datatypes
understood by <tt class="module">ZSI</tt>.

<P>
All typecodes classes have the prefix <code>TC.</code>, to avoid name clashes.

<P>
<tt class="module">ZSI</tt> provides fine-grain control over the names used when parsing and
serializing XML into local Python objects, through the use of three
attributes: the <code>pname</code>, the <code>aname</code>, and the <code>oname</code>
(in approximate order of importance).  They specify the name expected on
the XML element being parsed, the name to use for the analogous attribute
in the local Python object, and the name to use for the output element
when serializing.

<P>
The <code>pname</code> is the parameter name. It specifies the incoming
XML element name and the default values for the Python attribute
and serialized names.  All typecodes take name argument, known as
<code>name</code>, for the <code>pname</code>.  This name can be specified as
either a list or a string.  When specified as a list, it must have two
elements which are interpreted as a ``(namespace-URI, localname)'' pair.
If specified this way, both the namespace and the local element name
must match for the parse to succeed.  For the Python attribute, and
when generating output, only the ``localname'' is used.  (Because the
output name is not namespace-qualified, it may be necessary to set the
default namespace, such as through the <code>nsdict</code> parameter of the
<tt class="class">SoapWriter</tt> class.  When the name is specified as a string, it
can be either a simple XML name (such as ``foo''), or a colon-separated
XML qualified name (such as ``tns:foo'').  If a qualified name is used,
the namespace prefix is ignore on input and for the Python attribute,
but the full qualified name is used for output; this <i>requires</i>
the namespace prefix to be specified.

<P>
The <code>aname</code> is the attribute name.  This parameter overrides
any value implied by the <code>pname</code>.  Typecodes nested in a the
<tt class="class">TC.Struct</tt> or <tt class="class">TC.Choice</tt> can use this parameter to specify
the tag, dictionary key, or instance attribute to set.

<P>
The final name, <code>oname</code>, specifies the name to use for the XML element
when serializing.  This is most useful when using the same typecode for
both parsing and serializing operations.  It can be any string, and is
output directly; a name like ``tns:foo'' implies that the <code>nsdict</code>
parameter to the <tt class="class">SoapWriter</tt> construct should have an entry for
``tns,'' otherwise the resulting output will not be well-formed XML.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-41"><tt class="class">TypeCode</tt></a></b>(</nobr></td>
  <td><var>name, **keywords</var>)</td></tr></table>
<dd>
The <code>name</code> parameter is the name of the object; this is only
required when a typecode appears within a <tt class="class">TC.Struct</tt> as it defines
the attribute name used to hold the data, or within a <tt class="class">TC.Choice</tt>
as it determines the data type.
(Since SOAP RPC models transfer as structures, this essentially means that
a the <code>name</code> parameter can never be <code>None</code>.)

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>aname</code></td>
        
        <td align="left">See name discussion above.</td>
    <tr><td align="left" valign="baseline"><code>default</code></td>
        <td align="center">n/a</td>
        <td align="left">Value if the element is not specified.</td>
    <tr><td align="left" valign="baseline"><code>optional</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">The element is optional; see below.</td>
    <tr><td align="left" valign="baseline"><code>oname</code></td>
        
        <td align="left">See name discussion above.</td>
    <tr><td align="left" valign="baseline"><code>repeatable</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">If multiple instances of this
occur in a <tt class="class">TC.Struct</tt>, collect the values into a list.

<span class="versionnote">New in version 1.2.</span>
</td>
    <tr><td align="left" valign="baseline"><code>typed</code></td>
        <td align="center"><code>1</code></td>
        <td align="left">Output type information (in the
<code>xsi:type</code> attribute) when serializing. By special dispensation,
typecodes within a <tt class="class">TC.Struct</tt> object inherit this from the
container.</td>
    <tr><td align="left" valign="baseline"><code>unique</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">If true, the object is unique and will
never be ``aliased'' with another object, so the <code>id</code> attribute
need not be output.</td></tbody>
</table>

<P>
Optional elements are those which do not have to be an incoming
message, or which have the XML Schema <code>nil</code> attribute set.
When parsing the message as part of a <code>Struct</code>, then the Python
instance attribute will not be set, or the element will not appear as
a dictionary key.
When being parsed as a simple type, the value <code>None</code> is returned.
When serializing an optional element, a non-existent attribute, or a value
of <code>None</code> is taken to mean not present, and the element is skipped.

<P>
</dl>

<P>
<dl><dt><b><a name="l2h-42"><tt class="member">typechecks</tt></a></b>
<dd>
This is a class attribute.
If true (the default) then all typecode constructors do more
rigorous type-checking on their parameters.
</dl>

<P>
The following methods are useful for defining new typecode classes;
see the section on dynamic typing for more details.
In all of the following, the <code>ps</code> parameter is a <tt class="class">ParsedSoap</tt>
object.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-43"><tt class="method">checkname</tt></a></b>(</nobr></td>
  <td><var>elt, ps</var>)</td></tr></table>
<dd>
Checks if the name and type of the element <code>elt</code> are
correct and raises a <tt class="exception">EvaluateException</tt> if not.
Returns the element's type as a "<tt class="samp">(uri, localname)</tt>" tuple if so.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-44"><tt class="method">checktype</tt></a></b>(</nobr></td>
  <td><var>elt, ps</var>)</td></tr></table>
<dd>
Like <tt class="method">checkname()</tt> except that the element name is ignored.
This method is actually invoked by <tt class="method">checkname()</tt> to do the
second half of its processing, but is useful to invoke
directly, such as when resolving multi-reference data.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-45"><tt class="method">nilled</tt></a></b>(</nobr></td>
  <td><var>elt, ps</var>)</td></tr></table>
<dd>
If the element <code>elt</code> has data, this returns <code>0</code>.
If it has no data, and the typecode is not optional, an
<tt class="exception">EvaluateException</tt> is raised; if it is optional,
a <code>1</code> is returned.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-46"><tt class="method">simple_value</tt></a></b>(</nobr></td>
  <td><var>elt, ps</var>)</td></tr></table>
<dd>
Returns the text content of the element <code>elt</code>.
If no value is present, or the element has non-text children, an
<tt class="exception">EvaluateException</tt> is raised.
</dl>

<P>

<H1><A NAME="SECTION007100000000000000000">
6.1 <tt class="class">TC.Any</tt> -- the basis of dynamic typing</A>
</H1>

<P>
SOAP provides a flexible set of serialization rules, ranging from
completely self-describing to completely opaque, requiring an external
schema. For example, the following are all possible ways of encoding an
integer element <code>i</code> with a value of <code>12</code>:

<P>
<div class="verbatim"><pre>
&lt;tns:i xsi:type="SOAP-ENC:integer"&gt;12&lt;/tns:i&gt;
&lt;tns:i xsi:type="xsi:nonNegativeInteger"&gt;12&lt;/tns:i&gt;
&lt;SOAP-ENC:integer&gt;12&lt;/SOAP-ENC:integer&gt;
&lt;tns:i&gt;12&lt;/tns:i&gt;
</pre></div>

<P>
The first three lines are examples of <i>typed</i> elements.
If <tt class="module">ZSI</tt> is asked to parse any of the above examples, and a
<tt class="class">TC.Any</tt> typecode is given, it will properly create a Python
integer for the first three, and raise a <tt class="exception">ParseException</tt>
for the fourth.

<P>
Compound data, such as a <code>struct</code>, may also be self-describing:
<div class="verbatim"><pre>
&lt;tns:foo xsi:type="tns:mytype"&gt;
    &lt;tns:i xsi:type="SOAP-ENC:integer"&gt;12&lt;/tns:i&gt;
    &lt;tns:name xsi:type="SOAP-ENC:string"&gt;Hello world&lt;/tns:name&gt;
&lt;/tns:foo&gt;
</pre></div>

<P>
If this is parsed with a <tt class="class">TC.Any</tt> typecode, either a Python dictionary
or a sequence will be created:
<div class="verbatim"><pre>
{   'name': u'Hello world',    'i': 12   }

[ 12, u'Hello world' ]
</pre></div>
Note that one preserves order, while the other preserves the element names.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-47"><tt class="class">Any</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
Used for parsing incoming SOAP data (that is typed), and serializing
outgoing Python data.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>aslist</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">If true, then the data is (recursively)
treated as a list of values.
The default is a Python dictionary, which preserves parameter names but
loses the ordering.

<span class="versionnote">New in version 1.1.</span>
</td></tbody>
</table>

<P>
In addition, if the Python object being serialized with an <tt class="class">Any</tt>
has a <code>typecode</code> attribute, then the <tt class="method">serialize</tt> method of
the typecode will be invoked to do the serialization.
This allows objects to override the default dynamic serialization.
</dl>

<P>
Referring back to the compound XML data above, it is possible to create a new
typecode capable of parsing elements of type <code>mytype</code>.
This class would know that the <code>i</code> element is an integer,
so that the explicit typing becomes optional, rather than required.

<P>
The rest of this section describes how to add new
types to the <tt class="module">ZSI</tt> typecode engine.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-48"><tt class="class"><i>NEWTYPECODE</i>(TypeCode)</tt></a></b>(</nobr></td>
  <td><var>...</var>)</td></tr></table>
<dd>
The new typecode should be derived from the <tt class="class">TC.TypeCode</tt> class, and
<tt class="method">TypeCode.__init__()</tt> must be invoked in the new class's constructor.
</dl>

<P>
<dl><dt><b><a name="l2h-49"><tt class="member">parselist</tt></a></b>
<dd>
This is a class attribute, used when parsing incoming SOAP data.
It should be a sequence of "<tt class="samp">(uri, localname)</tt>" tuples to identify
the datatype.
If <code>uri</code> is <code>None</code>, it is taken to mean either the XML Schema
namespace or the SOAP encoding namespace;
this should only be used if adding support for additional primitive types.
If this list is empty, then the type of the incoming SOAP data is assumed
to be correct; an empty list also means that incoming typed data cannot
by dynamically parsed.
</dl>

<P>
<dl><dt><b><a name="l2h-50"><tt class="member">errorlist</tt></a></b>
<dd>
This is a class attribute, used when reporting a parsing error.
It is a text string naming the datatype that was expected.
If not defined, <tt class="module">ZSI</tt> will create this attribute from the <code>parselist</code>
attribute when it is needed.
</dl>

<P>
<dl><dt><b><a name="l2h-51"><tt class="member">seriallist</tt></a></b>
<dd>
This is a class attribute, used when serializing Python objects
dynamically.
It specifies what types of object instances (or Python types) this
typecode can serialize.
It should be a sequence, where each element is a Python class object,
a string naming the class, or a type object from Python's <tt class="module">types</tt>
module (if the
new typecode is serializing a built-in Python type).
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-52"><tt class="method">parse</tt></a></b>(</nobr></td>
  <td><var>elt, ps</var>)</td></tr></table>
<dd>
<tt class="module">ZSI</tt> invokes this method to
parse the <code>elt</code> element and return its Python value.
The <code>ps</code> parameter is the <tt class="class">ParsedSoap</tt> object, and can be
used for dereferencing <code>href</code>'s, calling <tt class="method">Backtrace()</tt> to
report errors, etc.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-53"><tt class="method">serialize</tt></a></b>(</nobr></td>
  <td><var>sw, pyobj</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
<tt class="module">ZSI</tt> invokes this method to output a Python object to a SOAP stream.
The <code>sw</code> parameter will be a <tt class="class">SoapWriter</tt> object, and
the <code>pyobj</code> parameter is the Python object to serialize.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>attrtext</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">Text (with leading space)
to output as an attribute; this is normally used by the <tt class="class">TC.Array</tt> class
to pass down indexing information.</td>
    <tr><td align="left" valign="baseline"><code>name</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">Name to use for serialization; defaults
to the name specified in the typecode, or a generated name.</td>
    <tr><td align="left" valign="baseline"><code>typed</code></td>
        <td align="center"><i>per-typecode</i></td>
        <td align="left">Whether or not to output type
information; the default is to use the value in the typecode.</td></tbody>
</table>
</dl>

<P>
Once the new typecode class has been defined, it should be registered with
<tt class="module">ZSI</tt>'s dynamic type system by invoking the following function:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-54"><tt class="function">RegisterType</tt></a></b>(</nobr></td>
  <td><var>class</var><big>[</big><var>, clobber=0</var><big>[</big><var>, **keywords</var><big>]</big><big>]</big>)</td></tr></table>
<dd>
By default, it is an error to replace an existing type registration, and
an exception will be raised.
The <code>clobber</code> parameter may be given to allow replacement.
A single instance of the <code>class</code> object will be created, and
the <code>keyword</code> parameters are passed to the constructor.
</dl>

<P>
If the class is not registered, then instances of the class cannot be
processed as dynamic types.
This may be acceptable in some environments.

<P>

<H1><A NAME="SECTION007200000000000000000">
6.2 Void</A>
</H1>

<P>
A SOAP void is a Python <code>None</code>.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-55"><tt class="class">Void</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A <code>Void</code> is an item without a value.
It is of marginal utility, mainly useful for interoperability tests, and
as an optional item within a <code>Struct</code>.
</dl>

<P>

<H1><A NAME="SECTION007300000000000000000">
6.3 Strings</A>
</H1>

<P>
SOAP Strings are Python strings.
If the value to be serialized is a Python sequence, then an <code>href</code>
is generated, with the first element of the sequence used as the URI.
This can be used, for example, when generating SOAP with attachments.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-56"><tt class="class">String</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
The parent type of all SOAP strings.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>resolver</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">A function that can resolve an
absolute URI and return its content as a string, as described in the
<tt class="class">ParsedSoap</tt> description.</td>
    <tr><td align="left" valign="baseline"><code>strip</code></td>
        <td align="center"><code>1</code></td>
        <td align="left">If true, leading and trailing whitespace
are stripped from the content.</td>
    <tr><td align="left" valign="baseline"><code>textprotect</code></td>
        <td align="center"><code>1</code></td>
        <td align="left">If true, less-than and ampersand
characters are replaced with <code>&amp;lt;</code> and <code>&amp;amp;</code>, respectively.

<span class="versionnote">New in version 1.1.</span>
</td></tbody>
</table>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-57"><tt class="class">Enumeration</tt></a></b>(</nobr></td>
  <td><var>value_list, name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
Like <tt class="class">TC.String</tt>, but the value must be a member of
the <code>value_list</code> sequence of text strings
</dl>

<P>
In addition to <tt class="class">TC.String</tt>,
the basic string, several subtypes are provided that transparently
handle common encodings.
These classes create a temporary string object and pass that to
the <tt class="method">serialize()</tt> method.
When doing RPC encoding, and checking for non-unique strings, the
<tt class="class">TC.String</tt> class must have the original Python string, as well
as the new output.
This is done by adding a parameter to the <tt class="method">serialize()</tt> method:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>orig</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">If deriving a new typecode from the
string class, and the derivation creates a temporary Python string
(such as by <tt class="class">Base64String</tt>), than this parameter is the
original string being serialized.</td></tbody>
</table>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-58"><tt class="class">Base64String</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
The value is encoded in Base-64.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-59"><tt class="class">HexBinaryString</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
Each byte is encoded as its printable version.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-60"><tt class="class">URI</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
The value is URL quoted (e.g., <code>%20</code> for the space character).
</dl>

<P>
It is often the case that a parameter will be typed as a string for
transport purposes, but will in fact have special syntax and processing
requirements.
For example, a string could be used for an XPath expression, but it is
more convenient for the Python value to
actually be the compiled expression. Here is how to do that:

<P>
<div class="verbatim"><pre>
import xml.xpath.pyxpath
import xml.xpath.pyxpath.Compile as _xpath_compile

class XPathString(TC.String):
    def __init__(self, name, **kw):
        TC.String.__init__(self, name, **kw)

    def parse(self, elt, ps):
        val = TC.String.parse(self, elt, ps)
        try:
            val = _xpath_compile(val)
        except:
            raise EvaluateException("Invalid XPath expression",
                        ps.Backtrace(elt))
        return val
</pre></div>

<P>
In particular, it is common to send XML as a string, using entity
encoding to protect the ampersand and less-than characters.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-61"><tt class="class">XMLString</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
Parses the data as a string, but returns an XML DOM object.
For serialization, takes an XML DOM (or element node), and outputs
it as a string.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>readerclass</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">Class used to create DOM-creating
XML readers; described in the <tt class="class">ParsedSoap</tt> chapter.</td></tbody>
</table>

<P>
</dl>

<P>

<H1><A NAME="SECTION007400000000000000000">
6.4 Integers</A>
</H1>

<P>
SOAP integers are Python integers.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-62"><tt class="class">Integer</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
The parent type of all integers.
This class handles any of the several types (and ranges) of SOAP integers.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>format</code></td>
        <td align="center"><code>%d</code></td>
        <td align="left">Format string for serializing.

<span class="versionnote">New in version 1.2.</span>
</td></tbody>
</table>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-63"><tt class="class">IEnumeration</tt></a></b>(</nobr></td>
  <td><var>value_list, name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
Like <tt class="class">TC.Integer</tt>, but the value must be a member of
the <code>value_list</code> sequence.
</dl>

<P>
A number of sub-classes are defined to handle smaller-ranged numbers.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-64"><tt class="class">Ibyte</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A signed eight-bit value.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-65"><tt class="class">IunsignedByte</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
An unsigned eight-bit value.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-66"><tt class="class">Ishort</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A signed 16-bit value.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-67"><tt class="class">IunsignedShort</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
An unsigned 16-bit value.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-68"><tt class="class">Iint</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A signed 32-bit value.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-69"><tt class="class">IunsignedInt</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
An unsigned 32-bit value.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-70"><tt class="class">Ilong</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
An signed 64-bit value.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-71"><tt class="class">IunsignedLong</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
An unsigned 64-bit value.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-72"><tt class="class">IpositiveInteger</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A value greater than zero.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-73"><tt class="class">InegativeInteger</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A value less than zero.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-74"><tt class="class">InonPositiveInteger</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A value less than or equal to zero.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-75"><tt class="class">InonNegativeInteger</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A value greater than or equal to zero.
</dl>

<P>

<H1><A NAME="SECTION007500000000000000000">
6.5 Floating-point Numbers</A>
</H1>

<P>
SOAP floating point numbers are Python floats.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-76"><tt class="class">Decimal</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
The parent type of all floating point numbers.
This class handles any of the several types (and ranges) of SOAP
floating point numbers.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>format</code></td>
        <td align="center"><code>%f</code></td>
        <td align="left">Format string for serializing.

<span class="versionnote">New in version 1.2.</span>
</td></tbody>
</table>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-77"><tt class="class">FPEnumeration</tt></a></b>(</nobr></td>
  <td><var>value_list, name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
Like <tt class="class">TC.Decimal</tt>, but the value must be a member of
the <code>value_list</code> sequence.
Be careful of round-off errors if using this class.
</dl>

<P>
Two sub-classes are defined to handle smaller-ranged numbers.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-78"><tt class="class">FPfloat</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
An IEEE single-precision 32-bit floating point value.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-79"><tt class="class">FPdouble</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
An IEEE double-precision 64-bit floating point value.
</dl>

<P>

<H1><A NAME="SECTION007600000000000000000">
6.6 Dates and Times</A>
</H1>

<P>
SOAP dates and times are Python time tuples in UTC (GMT), as documented
in the Python <tt class="module">time</tt> module.
Time is tricky, and processing anything other than a simple absolute time
can be difficult.
(Even then, timezones lie in wait to trip up the unwary.)
A few caveats are in order:

<P>

<OL>
<LI>Some date and time formats will be parsed into tuples that are
not valid time values.
For example, 75 minutes is a valid duration, although not a legal value
for the minutes element of a time tuple.

<P>
</LI>
<LI>Fractional parts of a second may be lost when parsing, and may have
extra trailing zero's when serializing.

<P>
</LI>
<LI>Badly-formed time tuples may result in non-sensical values being serialized;
the first six values are taken directly as year, month, day, hour, minute,
second in UTC.

<P>
</LI>
<LI>Although the classes <tt class="class">Duration</tt> and <tt class="class">Gregorian</tt> are defined, they 
are for internal use only and should not be included in any <tt class="class">TypeCode</tt>
you define.  Instead, use the classes beginning with a lower case g in your
typecodes.

<P>
</LI>
</OL>

<P>
In addition, badly-formed values may result in non-sensical serializations.

<P>
When serializing, an integral or floating point number is taken as
the number of seconds since the epoch, in UTC.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-80"><tt class="class">Duration</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A relative time period.
Negative durations have all values less than zero; this makes
it easy to add a duration to a Python time tuple.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-81"><tt class="class">Gregorian</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
An absolute time period.
This class should not be instantiated directly; use one of the <code>gXXX</code>
classes instead.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-82"><tt class="class">gDateTime</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A date and time.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-83"><tt class="class">gDate</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A date.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-84"><tt class="class">gYearMonth</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A year and month.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-85"><tt class="class">gYear</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A year.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-86"><tt class="class">gMonthDay</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A month and day.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-87"><tt class="class">gDay</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A day.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-88"><tt class="class">gTime</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
A time.
</dl>

<P>

<H1><A NAME="SECTION007700000000000000000">
6.7 Boolean</A>
</H1>

<P>
SOAP Booleans are Python integers.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-89"><tt class="class">Boolean</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
When marshaling zero or the word ``false'' is returned as <code>0</code>
and any non-zero value or the word ``true'' is returned as <code>1</code>.
When serializing, the number <code>0</code> or <code>1</code> will be generated.
</dl>

<P>

<H1><A NAME="SECTION007800000000000000000">
6.8 XML</A>
</H1>

<P>
XML is a Python DOM element node.
If the value to be serialized is a Python string, then an <code>href</code>
is generated, with the value used as the URI.
This can be used, for example, when generating SOAP with attachments.
Otherwise, the XML is typically put inside a wrapper element that sets
the proper SOAP encoding style.

<P>
For efficiency, incoming XML is returend as a ``pointer'' into the
DOM tree maintained within the <tt class="class">ParsedSoap</tt> object.
If that object is going to go out of scope, the data will be destroyed
and any XML objects will become empty elements.
The class instance variable <code>copyit</code>, if non-zero indicates that a
deep copy of the XML subtree will be made and returned as the value.
Note that it is generally more efficient to keep the <tt class="class">ParsedSoap</tt>
object alive until the XML data is no longerneeded.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-90"><tt class="class">XML</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
This typecode represents a portion of an XML document embedded in a SOAP
message.
The value is the element node.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>copyit</code></td>
        <td align="center">TC.XML.copyit</td>
        <td align="left">Return a copy of the parsed data.</td>
    <tr><td align="left" valign="baseline"><code>comments</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">Preserve comments in output.</td>
    <tr><td align="left" valign="baseline"><code>inline</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">The XML sub-tree is single-reference,
so can be output in-place.</td>
    <tr><td align="left" valign="baseline"><code>resolver</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">A function that can resolve an
absolute URI and return its content as an element node, as described in the
<tt class="class">ParsedSoap</tt> description.</td>
    <tr><td align="left" valign="baseline"><code>wrapped</code></td>
        <td align="center"><code>1</code></td>
        <td align="left">If zero, the XML is output directly,
and not within a SOAP wrapper element.

<span class="versionnote">New in version 1.2.</span>
</td></tbody>
</table>
</dl>

<P>
When serializing, it may be necessary to specify which namespace prefixes
are ``active'' in the XML.
This is done by using the <code>unsuppressedPrefixes</code> parameter when
calling the <tt class="method">serialize()</tt> method.
(This will only work when XML is the top-level item being serialized,
such as when using typecodes and document-style interfaces.)

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>unsuppressedPrefixes</code></td>
        <td align="center">[]</td>
        <td align="left">An array of strings
identifying the namespace prefixes that should be output.</td></tbody>
</table>

<P>

<H1><A NAME="SECTION007900000000000000000">
6.9 Struct</A>
</H1>

<P>
SOAP structs are either Python dictionaries or
instances of application-specified classes.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-91"><tt class="class">Struct</tt></a></b>(</nobr></td>
  <td><var>pyclass, typecode_seq, name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
This class defines a compound data structure.
If <code>pyclass</code> is <code>None</code>, then the data will be marshaled
into a Python dictionary, and each item in the <code>typecode_seq</code> sequence
specifies a (possible) dictionary entry.
Otherwise, <code>pyclass</code> must be a Python class object whose constructor
takes a single parameter, which will be the value of the <code>name</code>
parameter given in the <tt class="class">TC.Struct</tt> constructor.
(This allows a single <code>pyclass</code> to be used for different typecodes.)
The data is then marshaled into the object, and each item in the
<code>typecode_seq</code>
sequence specifies an attribute of the instance to set.

<P>
Note that each typecode in <code>typecode_seq</code> must have a name.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>hasextras</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">Ignore any extra elements that appear
in the in the structure.
If <code>inorder</code> is true, extras can only appear at the end.</td>
    <tr><td align="left" valign="baseline"><code>inorder</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">Items within the structure must appear
in the order specified in the <code>TCseq</code> sequence.</td>
    <tr><td align="left" valign="baseline"><code>inline</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">The structure is single-reference,
so ZSI does not have to use <code>href/id</code> encodings.</td>
    <tr><td align="left" valign="baseline"><code>mutable</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">If an object is going to be serialized
multiple times, and its state may be modified between serializations,
then this keyword should be used, otherwise a single instance will be
serialized, with multiple references to it.
This argument implies the <code>inline</code> argument.

<span class="versionnote">New in version 1.2.</span>
</td>
    <tr><td align="left" valign="baseline"><code>type</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">A "<tt class="samp">(uri, localname)</tt>" tuple that
defines the type of the structure.
If present, and if the input data has a <code>xsi:type</code> attribute, then the
namespace-qualified value of that attribute must match the value
specified by this parameter.
By default, type-checking is not done for structures; matching child element
names is usually sufficient and senders rarely provide type information.</td></tbody>
</table>

<P>
If the <code>typed</code> keyword is used, then its value is assigned to
all typecodes in the <code>typecode_seq</code> parameter.
If any of the typecodes in <code>typecode_seq</code> are repeatable, then the
<code>inorder</code> keyword should not be used and the <code>hasextras</code> parameter
<i>must</i> be used.

<P>
For example, the following C structure:
<div class="verbatim"><pre>
struct foo {
    int i;
    char* text;
};
</pre></div>
could be declared as follows:
<div class="verbatim"><pre>
class foo:
    def __init__(self, name):
        self.name = name
    def __str__(self):
        return str((self.name, self.i, self.text))

foo.typecode = TC.Struct(foo,
    ( TC.Integer('i'), TC.String('text') ),
    'foo')
</pre></div>
</dl>

<P>

<H1><A NAME="SECTION0071000000000000000000">
6.10 Choice</A>
</H1>

<P>
A choice is a Python two-element "<tt class="samp">(name, value)</tt>" tuple, representing
a union of different types.
The first item is a string identifying the type, and the second is the
actual data.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-92"><tt class="class">Choice</tt></a></b>(</nobr></td>
  <td><var>typecode_seq, name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
When parsing, ZSI will look at the element name in the SOAP message, and
determine which of the choices to create.

<P>
When serializing Python objects to SOAP messages, <tt class="module">ZSI</tt> must be
explicitly told which of the choices define the data.
This is done by passing a two-element tuple.
The first item is a string identifying the name of a typecode
from the <code>typecode_seq</code> list of typecodes.
The second is the object to be serialized.
</dl>

<P>

<H1><A NAME="SECTION0071100000000000000000">
6.11 Arrays</A>
</H1>

<P>
SOAP arrays are Python lists; multi-dimensional arrays are
lists of lists and are indistinguishable from a SOAP array of arrays.
Arrays may be <i>sparse</i>, in which case each element in the
array is a tuple of "<tt class="samp">(subscript, data)</tt>" pairs.
If an array is not sparse, a specified <i>fill</i> element will be
used for the missing values.

<P>
<b>Currently only singly-dimensioned arrays are supported.</b>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-93"><tt class="class">Array</tt></a></b>(</nobr></td>
  <td><var>atype, ofwhat, name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
The <code>atype</code> parameter is a text string representing the SOAP array type.
the <code>ofwhat</code> parameter is a typecode describing the array elements.
</dl>

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>childnames</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">Default name to use for the child
elements.</td>
    <tr><td align="left" valign="baseline"><code>dimensions</code></td>
        <td align="center"><code>1</code></td>
        <td align="left">The number of dimensions in
the array.</td>
    <tr><td align="left" valign="baseline"><code>fill</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">The value to use when an array
element is omitted.</td>
    <tr><td align="left" valign="baseline"><code>mutable</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">Same as <tt class="class">TC.Struct</tt>

<span class="versionnote">New in version 1.2.</span>
</td>
    <tr><td align="left" valign="baseline"><code>nooffset</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">Do not use the SOAP <code>offset</code>
attribute so skip leading elements with the same value as <code>fill</code>.</td>
    <tr><td align="left" valign="baseline"><code>sparse</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">The array is sparse.</td>
    <tr><td align="left" valign="baseline"><code>size</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">An integer or list of integers that
specifies the maximum array dimensions.</td>
    <tr><td align="left" valign="baseline"><code>undeclared</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">The SOAP "<tt class="samp">arrayType</tt>" attribute
need not appear.</td></tbody>
</table>

<P>

<H1><A NAME="SECTION0071200000000000000000">
6.12 Apache Datatype</A>
</H1>

<P>
The Apache SOAP project, urlhttp://xml.apache.org/soap/index.html,
has defined a popular SOAP datatype in the 
<code>http://xml.apache.org/xml-soap</code> namespace, a
<tt class="class">Map</tt>.

<P>
The <code>Map</code> type is encoded as a list of <code>item</code> elements.
Each <code>item</code> has a <code>key</code> and <code>value</code> child element; these
children must have SOAP type information.
An Apache Map is either a Python dictionary or a list of two-element
tuples.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-94"><tt class="class">Apache.Map</tt></a></b>(</nobr></td>
  <td><var>name</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
An Apache map.
Note that the class name is dotted.
</dl>

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>aslist</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">Use a list of tuples rather than
a dictionary.</td></tbody>
</table>

<H1><A NAME="SECTION008000000000000000000">
7. The <tt class="module">SoapWriter</tt> module -- serializing data</A>
</H1>

<P>
The SoapWriter class is used to output SOAP messages.
Note that its output is encoded as UTF-8; when transporting SOAP over
HTTP it is therefore important to set the <code>charset</code> attribute
of the <code>Content-Type</code> header.

<P>
The <tt class="class">SoapWriter</tt> class reserves some namespace prefixes:
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Prefix</b>&nbsp;</th>
      <th align="left"><b>URI</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>SOAP-ENV</code></td>
        <td align="left"><code>http://schemas.xmlsoap.org/soap/envelope/</code></td>
    <tr><td align="left" valign="baseline"><code>SOAP-ENC</code></td>
        <td align="left"><code>http://schemas.xmlsoap.org/soap/encoding/</code></td>
    <tr><td align="left" valign="baseline"><code>ZSI</code></td>
        <td align="left"><code>http://www.zolera.com/schemas/ZSI/</code></td>
    <tr><td align="left" valign="baseline"><code>xsd</code></td>
        <td align="left"><code>http://www.w3.org/2001/XMLSchema</code></td>
    <tr><td align="left" valign="baseline"><code>xsi</code></td>
        <td align="left"><code>http://www.w3.org/2001/XMLSchema-instance</code></td></tbody>
</table>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-95"><tt class="class">SoapWriter</tt></a></b>(</nobr></td>
  <td><var>out</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
The <code>out</code> parameter is an object that has a <tt class="method">write()</tt>
method for generating the output.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>encoding</code></td>
        <td align="center"><code>SOAP-ENC</code> value</td>
        <td align="left">If not <code>None</code>, then
use the specified value as the value for the SOAP <code>encodingStyle</code>
attribute.

<span class="versionnote">New in version 1.2.</span>
</td>
    <tr><td align="left" valign="baseline"><code>envelope</code></td>
        <td align="center"><code>1</code></td>
        <td align="left">Write the SOAP envelope elements.

<span class="versionnote">New in version 1.2.</span>
</td>
    <tr><td align="left" valign="baseline"><code>nsdict</code></td>
        <td align="center"><code>{}</code></td>
        <td align="left">Dictionary of namespaces to declare
in the SOAP <code>Body</code>.
Note that earlier versions of ZSI put the declarations on the SOAP
<code>Envelope</code>; they have been moved to the <code>Body</code> for greater
interoperability.</td>
    <tr><td align="left" valign="baseline"><code>header</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">A sequence of elements to output in
the SOAP <code>Header</code>.
It may also be a text string, in which case it is output as-is, and should
therefore be XML text.</td></tbody>
</table>
</dl>

<P>
Creating a <tt class="class">SoapWriter</tt> object with a <tt class="class">StringIO</tt> object for
the <code>out</code> parameter and <code>envelope</code> set to false results in an
object that can be used for serializing objects into a string.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-96"><tt class="method">serialize</tt></a></b>(</nobr></td>
  <td><var>pyobj</var><big>[</big><var>, typecode</var><big>[</big><var>, root=None</var><big>[</big><var>, **keywords</var><big>]</big><big>]</big><big>]</big>)</td></tr></table>
<dd>
This method serializes the <code>pyobj</code> Python object as directed
by the <code>typecode</code> typecode object.
If <code>typecode</code> is omitted, then <code>pyobj</code> should be a Python
object instance of a class that has a <code>typecode</code> attribute.
It returns <code>self</code>, so that serializations can be chained together, or
so that the <tt class="method">close()</tt> method can be invoked.
The <code>root</code> parameter may be used to explicitly indicate the root
(main element) of a SOAP encoding, or indicate that the item is not the
root.
If specified, it should have the numeric value of zero or one.
Any other keyword parameters are passed to the typecode's <code>serialize</code>
method.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-97"><tt class="method">close</tt></a></b>(</nobr></td>
  <td><big>[</big><var>trailer=None</var><big>[</big><var>, nsdict=None</var><big>]</big><big>]</big>)</td></tr></table>
<dd>
Close off the SOAP message, finishing all the pending serializations.
If <code>trailer</code> is a string or list of elements, it is output after the
close-tag for the <code>Body</code>.
The <tt class="method">close()</tt> method of the originally provided out object is NOT called.
(If it were, and the original <code>out</code> object were a <tt class="class">StringIO</tt>
object, there would be no way to collect the data.)
This method will be invoked automatically if the object is deleted.
</dl>

<P>
The following methods are primarily useful for those writing new typecodes.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-98"><tt class="method">AddCallback</tt></a></b>(</nobr></td>
  <td><var>func, arg</var>)</td></tr></table>
<dd>
Used by typecodes when serializing, allows them to add output after
the SOAP <code>Body</code> is written but before the SOAP <code>Envelope</code> is closed.
The function <tt class="method">func()</tt>
will be called with the <tt class="class">SoapWriter</tt> object and the specified <code>arg</code>
argument, which may be a tuple.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-99"><tt class="method">Forget</tt></a></b>(</nobr></td>
  <td><var>obj</var>)</td></tr></table>
<dd>
Forget that <code>obj</code> has been seen before.
This is useful when repeatedly serializing a mutable object.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-100"><tt class="method">Known</tt></a></b>(</nobr></td>
  <td><var>obj</var>)</td></tr></table>
<dd>
If <code>obj</code> has been seen before (based on its Python <code>id</code>),
return <code>1</code>.
Otherwise, remember <code>obj</code> and return <code>0</code>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-101"><tt class="method">ReservedNS</tt></a></b>(</nobr></td>
  <td><var>prefix, uri</var>)</td></tr></table>
<dd>
Returns true if the specified namespace <code>prefix</code> and
<code>uri</code>
collide with those used by the implementation.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-102"><tt class="method">write</tt></a></b>(</nobr></td>
  <td><var>arg</var>)</td></tr></table>
<dd>
This is a convenience method that calls <tt class="method">self.out.write()</tt>
on <code>arg</code>, with the addition that if <code>arg</code> is a sequence,
it iterates over the sequence, writing each item (that isn't <code>None</code>)
in turn.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-103"><tt class="method">writeNSDict</tt></a></b>(</nobr></td>
  <td><var>nsdict</var>)</td></tr></table>
<dd>
Outputs <code>nsdict</code> as a namespace dictionary.
It is assumed that an XML start-element is pending on the output
stream.
</dl>

<H1><A NAME="SECTION009000000000000000000">
8. The <tt class="module">Fault</tt> module -- reporting errors</A>
</H1>

<P>
SOAP defines a <i>fault</i> message as the way for a recipient to
indicate it was unable to process a message.
The <tt class="module">ZSI</tt> <tt class="class">Fault</tt> class encapsulates this.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-104"><tt class="class">Fault</tt></a></b>(</nobr></td>
  <td><var>code, string</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
The <code>code</code> parameter is a text string identifying the SOAP fault
code, a namespace-qualified name.
The class attribute <code>Fault.Client</code> can be used to indicate a problem with
an incoming message, <code>Fault.Server</code> can be used to
indicate a problem occurred while processing the request, or <code>Fault.MU</code>
can be used to indicate a problem with the SOAP <code>mustUnderstand</code>
attribute.
The <code>string</code> parameter is a human-readable text string describing the
fault.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>actor</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">A string identifying the <code>actor</code>
attribute that caused the problem (usually because it is unknown).</td>
    <tr><td align="left" valign="baseline"><code>detail</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">A sequence
of elements to output in the <code>detail</code> element; it may also
be a text string, in which case it is output as-is, and should
therefore be XML text.</td>
    <tr><td align="left" valign="baseline"><code>headerdetail</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">Data, treated the same as
the <code>detail</code> keyword, to be output in the SOAP header.  See
the following paragraph.</td></tbody>
</table>

<P>
If the fault occurred in the SOAP <code>Header</code>, the specification
requires that the detail be sent back as an element within
the SOAP <code>Header</code> element.
Unfortunately, the SOAP specification does not describe how to encode
this; <tt class="module">ZSI</tt> defines and uses a
<code>ZSI:detail</code> element, which is analogous to the SOAP <code>detail</code>
element.
</dl>

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-105"><tt class="member">actor</tt></a></b>
<dd>
A text string holding the value of the SOAP <code>faultactor</code> element.
</dl>

<P>
<dl><dt><b><a name="l2h-106"><tt class="member">code</tt></a></b>
<dd>
A text string holding the value of the SOAP <code>faultcode</code> element.
</dl>

<P>
<dl><dt><b><a name="l2h-107"><tt class="member">detail</tt></a></b>
<dd>
A text string or sequence of elements containing holding the value of the
SOAP <code>detail</code> element, when available.
</dl>

<P>
<dl><dt><b><a name="l2h-108"><tt class="member">headerdetail</tt></a></b>
<dd>
A text string or sequence of elements containing holding the value of the
<tt class="module">ZSI</tt> header detail element, when available.
</dl>

<P>
<dl><dt><b><a name="l2h-109"><tt class="member">string</tt></a></b>
<dd>
A text string holding the value of the SOAP <code>faultstring</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-110"><tt class="method">AsSOAP</tt></a></b>(</nobr></td>
  <td><big>[</big><var>output=None</var><big>[</big><var>, **kw</var><big>]</big><big>]</big>)</td></tr></table>
<dd>
This method serializes the <tt class="class">Fault</tt> object into a SOAP message.
If the <code>output</code> parameter is not specified, the message is returned
as a string.
Any other keyword arguments are passed to the <tt class="class">SoapWriter</tt> constructor.
Otherwise <tt class="method">AsSOAP()</tt> will call <tt class="method">output.write()</tt> as needed
to output the message.

<span class="versionnote">New in version 1.1; the old <code>AsSoap</code> method is still available.</span>

</dl>

<P>
If other data is going to be sent with the fault, the following
two methods can be used.
Because some data might need to be output in the SOAP <code>Header</code>,
serializing a fault is a two-step process.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-111"><tt class="method">DataForSOAPHeader</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
This method returns a text string that can be included as the
<code>header</code> parameter for constructing a <tt class="class">SoapWriter</tt> object.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-112"><tt class="method">serialize</tt></a></b>(</nobr></td>
  <td><var>sw</var>)</td></tr></table>
<dd>
This method outputs the fault object onto the <code>sw</code> object,
which must support a <tt class="method">write()</tt> method.
</dl>

<P>
Some convenience functions are available to create a <tt class="class">Fault</tt>
from common conditions.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-113"><tt class="function">FaultFromActor</tt></a></b>(</nobr></td>
  <td><var>uri</var><big>[</big><var>, actor=None</var><big>]</big>)</td></tr></table>
<dd>
This function could be used when an application receives a message
that has a SOAP <code>Header</code> element directed to an actor that
cannot be processed.
The <code>uri</code> parameter identifies the actor.
The <code>actor</code> parameter can be used to specify a URI that identifies the
application, if it is not the ultimate recipient of the SOAP message.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-114"><tt class="function">FaultFromException</tt></a></b>(</nobr></td>
  <td><var>ex, inheader</var><big>[</big><var>,
    tb=None</var><big>[</big><var>, actor=None</var><big>]</big><big>]</big>)</td></tr></table>
<dd>
This function creates a <tt class="class">Fault</tt> from a general Python exception.
A SOAP ``server'' fault is created.
The <code>ex</code> parameter should be the Python exception.
The <code>inheader</code> parameter should be true if the error was
found on a SOAP <code>Header</code> element.
The optional <code>tb</code> parameter may be a Python <tt class="class">traceback</tt>
object, as returned by "<tt class="samp">sys.exc_info()[2]</tt>".
The <code>actor</code> parameter can be used to specify a URI that identifies the
application, if it is not the ultimate recipient of the SOAP message.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-115"><tt class="function">FaultFromFaultMessage</tt></a></b>(</nobr></td>
  <td><var>ps</var>)</td></tr></table>
<dd>
This function creates a <tt class="class">Fault</tt> from a <tt class="class">ParsedSoap</tt> object.
It should only be used if the <tt class="method">IsAFault()</tt> method returned true.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-116"><tt class="function">FaultFromNotUnderstood</tt></a></b>(</nobr></td>
  <td><var>uri, localname,</var><big>[</big><var>,
    actor=None</var><big>]</big>)</td></tr></table>
<dd>
This function could be used when an application receives a message with
the SOAP <code>mustUnderstand</code> attribute that it does not understand.
The <code>uri</code> and <code>localname</code> parameters should identify
the unknown element.
The <code>actor</code> parameter can be used to specify a URI that identifies the
application, if it is not the ultimate recipient of the SOAP message.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-117"><tt class="function">FaultFromZSIException</tt></a></b>(</nobr></td>
  <td><var>ex</var><big>[</big><var>, actor=None</var><big>]</big>)</td></tr></table>
<dd>
This function creates a <tt class="class">Fault</tt> object from a <tt class="module">ZSI</tt> exception,
<tt class="exception">ParseException</tt> or <tt class="exception">EvaluateException</tt>.
A SOAP ``client'' fault is created.
The <code>actor</code> parameter can be used to specify a URI that identifies the
application, if it is not the ultimate recipient of the SOAP message.
</dl>

<H1><A NAME="SECTION0010000000000000000000">
9. The <tt class="module">resolvers</tt> module -- fetching remote data</A>
</H1>

<P>
The <tt class="module">resolvers</tt> module provides some functions and classes
that can be used as the <code>resolver</code> attribute for <tt class="class">TC.String</tt>
or <tt class="class">TC.XML</tt> typecodes.
They process an absolute URL, as described above, and return the
content.
Because the <tt class="module">resolvers</tt> module can import a number of other
large modules, it must be imported directly, as in
"<tt class="samp">from ZSI import resolvers</tt>".

<P>
These first two functions pass the URI directly to the <tt class="method">urlopen</tt>
function in the <tt class="module">urllib</tt> module.
Therefore, if used directly as resolvers, a client could direct the
SOAP application to fetch any file on the network or local disk.
Needless to say, this could pose a security risks.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-118"><tt class="function">Opaque</tt></a></b>(</nobr></td>
  <td><var>uri, tc, ps</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
This function returns the data contained at the specified <code>uri</code>
as a Python string.
Base-64 decoding will be done if necessary.
The <code>tc</code> and <code>ps</code> parameters are ignored; the <code>keywords</code>
are passed to the <tt class="method">urlopen</tt> method.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-119"><tt class="function">XML</tt></a></b>(</nobr></td>
  <td><var>uri, tc, ps</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
This function returns a list of the child element nodes of the XML
document at the specified <code>uri</code>.
The <code>tc</code> and <code>ps</code> parameters are ignored; the <code>keywords</code>
are passed to the <tt class="method">urlopen</tt> method.
</dl>

<P>
The <tt class="class">NetworkResolver</tt> class provides a simple-minded way to limit
the URI's that will be resolved.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-120"><tt class="class">NetworkResolver</tt></a></b>(</nobr></td>
  <td><big>[</big><var>prefixes=None</var><big>]</big>)</td></tr></table>
<dd>
The <code>prefixes</code> parameter is a list of strings defining the allowed
prefixes of any URI's.
If asked to fetch the content for a URI that does start with one of
the prefixes, it will raise an exception.

<P>
In addition to <code>Opaque</code> and <code>XML</code> methods, this class
provides a <code>Resolve</code> method that examines the typecode to determine
what type of data is desired.
</dl>

<P>
If the SOAP application is given a multi-part MIME document, the
<tt class="class">MIMEResolver</tt> class can be used to process SOAP with Attachments.

<P>
The <tt class="class">MIMEResolver</tt> class will read the entire multipart MIME document,
noting any <code>Content-ID</code> or <code>Content-Location</code> headers that appear
on the headers of any of the message parts, and use them to resolve
any <code>href</code> attributes that appear in the SOAP message.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-121"><tt class="class">MIMEResolver</tt></a></b>(</nobr></td>
  <td><var>ct, f</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
The <code>ct</code> parameter is a string that contains the value of the
MIME <code>Content-Type</code> header.
The <code>f</code> parameter is the input stream, which should be positioned just
after the message headers.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>seekable</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">Whether or not the input stream is
seekable; passed to the constructor for the internal <tt class="class">multifile</tt>
object.

<span class="versionnote">Changed in version 2.0:
default had been 1.</span>
</td>
    <tr><td align="left" valign="baseline"><code>next</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">A resolver object that will be
asked to resolve the URI if it is not found in the MIME document.

<span class="versionnote">New in version 1.1.</span>
</td>
    <tr><td align="left" valign="baseline"><code>uribase</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">The base URI to be used when
resolving relative URI's; this will typically be the value of the
<code>Content-Location</code> header, if present.

<span class="versionnote">New in version 1.1.</span>
</td></tbody>
</table>
</dl>

<P>
In addition to to the <code>Opaque</code>, <code>Resolve</code>, and <code>XML</code> methods
as described above, the following method is available:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-122"><tt class="method">GetSOAPPart</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
This method returns a stream containing the SOAP message text.
</dl>

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-123"><tt class="member">parts</tt></a></b>
<dd>
An array of tuples, one for each MIME bodypart found.
Each tuple has two elements, a <tt class="class">mimetools.Message</tt> object
which contains the headers for the bodypart, and a 
<tt class="class">StringIO</tt> object containing the data.
</dl>

<P>
<dl><dt><b><a name="l2h-124"><tt class="member">id_dict</tt></a></b>
<dd>
A dictionary whose keys are the values of any <code>Content-ID</code>
headers, and whose value is the appropriate <code>parts</code> tuple.
</dl>

<P>
<dl><dt><b><a name="l2h-125"><tt class="member">loc_dict</tt></a></b>
<dd>
A dictionary whose keys are the values of any <code>Content-Location</code>
headers, and whose value is the appropriate <code>parts</code> tuple.
</dl>

<H1><A NAME="SECTION0011000000000000000000">
10. Dispatching and Invoking</A>
</H1>

<P>

<span class="versionnote">New in version 1.1.</span>

<P>
<tt class="module">ZSI</tt> is focused on parsing and generating SOAP messages, and provides
limited facilities for dispatching to the appropriate message handler.
This is because <tt class="module">ZSI</tt> works within many client and server environments,
and the dispatching styles for these different environments can be
very different.

<P>
Nevertheless, <tt class="module">ZSI</tt> includes some dispatch and invocation functions.
To use them, they must be explicitly imported, as shown in the example
at the start of this document.

<P>
The implementation (and names) of the these classes reflects the orientation
of using SOAP for remote procedure calls (RPC).

<P>
Both client and server share a class that defines the mechanism a
client uses to authenticate itself.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-126"><tt class="class">AUTH</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
This class defines constants used to identify how the client
authenticated: <code>none</code> if no authentication was provided;
<code>httpbasic</code> if HTTP basic authentication was used, or
<code>zsibasic</code> if <tt class="module">ZSI</tt> basic authentication (see below)) was used.
</dl>

<P>
The <tt class="module">ZSI</tt> schema (see the last chapter of this manual)
defines a SOAP header element, <code>BasicAuth</code>, that
contains a name and password.
This is similar to the HTTP basic authentication header, except
that it can be used independently from an HTTP transport.

<P>

<H1><A NAME="SECTION0011100000000000000000">
10.1 Dispatching</A>
</H1>

<P>
The <tt class="module">ZSI.dispatch</tt> module allows you to expose Python functions as a
web service.
The module provides the infrastructure to parse the request, dispatch
to the appropriate handler, and then serialize any return value
back to the client.
The value returned by the function will be serialized back to the client.
To return multiple values, return a list.

<P>
If an exception occurs, a SOAP fault will be sent back to the client.

<P>
Three dispatch mechanisms are provided: one supports standard CGI
scripts, one runs a dedicated server based on the
<tt class="module">BaseHTTPServer</tt> module, and the third uses the JonPY package,
<a class="url" href="http://jonpy.sourceforge.net">http://jonpy.sourceforge.net</a>, to support FastCGI.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-127"><tt class="method">AsCGI</tt></a></b>(</nobr></td>
  <td><big>[</big><var>module_list</var><big>]</big>)</td></tr></table>
<dd>
This method parses the CGI input and invokes a function that has the
same name as the top-level SOAP request element.
The optional <code>module_list</code> parameter can specify a list of modules
(already imported) to search for functions.
If no modules are specified, only the <tt class="module">__main__</tt> module will be searched.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-128"><tt class="method">AsServer</tt></a></b>(</nobr></td>
  <td><big>[</big><var>**keywords</var><big>]</big>)</td></tr></table>
<dd>
This creates a <tt class="class">HTTPServer</tt> object with a request handler that only
supports the ``POST'' method.
Dispatch is based solely on the name of the root element in the
incoming SOAP request;
the request URL is ignored.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>docstyle</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">If true, then all methods are
invoked with a single argument, the unparsed body of the SOAP message.</td>
    <tr><td align="left" valign="baseline"><code>modules</code></td>
        <td align="center"><code>(__main__,)</code></td>
        <td align="left">List of modules containing
functions that can be invoked.</td>
    <tr><td align="left" valign="baseline"><code>nsdict</code></td>
        <td align="center"><code>{}</code></td>
        <td align="left">Namespace dictionary to send in the
    SOAP <code>Envelope</code></td>
    <tr><td align="left" valign="baseline"><code>port</code></td>
        <td align="center"><code>80</code></td>
        <td align="left">Port to listen on.</td></tbody>
</table>

<P>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-129"><tt class="method">AsJonPy</tt></a></b>(</nobr></td>
  <td><var>request=req</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>

<P>
This method is used within a JonPY handler to do dispatch.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>request</code></td>
        <td align="center"><code>(__main__,)</code></td>
        <td align="left">List of modules containing
functions that can be invoked.</td></tbody>
</table>

<P>
The following code shows a sample use:

<P>
<div class="verbatim"><pre>
import jon.fcgi
from ZSI import dispatch
import MyHandler

class Handler(cgi.Handler):
    def process(self, req):
        dispatch.AsJonPy(modules=(MyHandler,), request=req)

jon.fcgi.Server({jon.fcgi.FCGI_RESPONDER: Handler}).run()
</pre></div>

<P>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-130"><tt class="method">GetClientBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
More sophisticated scripts may want to use access the client binding object,
which encapsulates all information about the client invoking the script.
This function returns <code>None</code> or the binding information, an
object of type <tt class="class">ClientBinding</tt>, described below.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-131"><tt class="class">ClientBinding</tt></a></b>(</nobr></td>
  <td><var>...</var>)</td></tr></table>
<dd>
This object contains information about the client.
It is created internally by <tt class="module">ZSI</tt>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-132"><tt class="method">GetAuth</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
This returns a tuple containing information about the client identity.
The first element will be one of the constants from the <code>AUTH</code> class
described above.
For HTTP or <tt class="module">ZSI</tt> basic authentication, the next two elements will be
the name and password provided by the client.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-133"><tt class="method">GetNS</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Returns the namespace URI that the client is using, or an empty string.
This can be useful for versioning.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-134"><tt class="method">GetRequest</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Returns the <tt class="class">ParsedSoap</tt> object of the incoming request.
</dl>

<P>
The following attribute is read-only:

<P>
<dl><dt><b><a name="l2h-135"><tt class="member">environ</tt></a></b>
<dd>
A dictionary of the environment variables.
This is most useful when <tt class="method">AsCGI()</tt> is used.
</dl>

<P>

<H1><A NAME="SECTION0011200000000000000000">
10.2 The <tt class="module">client</tt> module -- sending SOAP messages</A>
</H1>

<P>
<tt class="module">ZSI</tt> includes a module to connect to a SOAP server over HTTP, send requests,
and parse the response.
It is built on the standard Python <tt class="module">httplib</tt> module.
It must be explicitly imported, as in
"<tt class="samp">from ZSI.client import AUTH,Binding</tt>".

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-136"><tt class="class">Binding</tt></a></b>(</nobr></td>
  <td><big>[</big><var>**keywords</var><big>]</big>)</td></tr></table>
<dd>
This class encapsulates a connection to a server, known as a <i>binding</i>.
A single binding may be used for multiple RPC calls.
Between calls, modifiers may be used to change the URL being posted to,
etc.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>auth</code></td>
        <td align="center"><code>(AUTH.none,)</code></td>
        <td align="left">A tuple with authentication
    information; the first value should be one of the constants
    from the <tt class="class">AUTH</tt> class.</td>
    <tr><td align="left" valign="baseline"><code>host</code></td>
        <td align="center"><code>'localhost'</code></td>
        <td align="left">Host to connect to.</td>
    <tr><td align="left" valign="baseline"><code>ns</code></td>
        <td align="center">n/a</td>
        <td align="left">Default namespace for the request.</td>
    <tr><td align="left" valign="baseline"><code>nsdict</code></td>
        <td align="center"><code>{}</code></td>
        <td align="left">Namespace dictionary to send in the
    SOAP <code>Envelope</code></td>
    <tr><td align="left" valign="baseline"><code>port</code></td>
        <td align="center"><code>80</code> or <code>443</code></td>
        <td align="left">Port to connect on.</td>
    <tr><td align="left" valign="baseline"><code>soapaction</code></td>
        <td align="center"><code>http://www.zolera.com</code></td>
        <td align="left">Value for the
    <code>SOAPAction</code> HTTP header.</td>
    <tr><td align="left" valign="baseline"><code>readerclass</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">Class used to create DOM-creating
XML readers; see the description in the <tt class="class">ParsedSoap</tt> class.

<span class="versionnote">New in version 1.2.</span>
</td>
    <tr><td align="left" valign="baseline"><code>ssl</code></td>
        <td align="center"><code>0</code></td>
        <td align="left">Use SSL if non-zero.</td>
    <tr><td align="left" valign="baseline"><code>tracefile</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">An object with a <code>write</code>
    method, where packet traces will be recorded.</td>
    <tr><td align="left" valign="baseline"><code>url</code></td>
        <td align="center">n/a</td>
        <td align="left">URL to post to.</td></tbody>
</table>

<P>
If using SSL, the <code>cert_file</code> and <code>key_file</code> keyword parameters may
also be used.
For details see the documentation for the <tt class="module">httplib</tt> module.

<P>
</dl>

<P>
Once a <tt class="class">Binding</tt> object has been created, the following modifiers are
available.
All of them return the binding object, so that multiple modifiers can
be chained together.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-137"><tt class="method">AddHeader</tt></a></b>(</nobr></td>
  <td><var>header, value</var>)</td></tr></table>
<dd>
Output the specified <code>header</code> and <code>value</code> with the HTTP
headers.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-138"><tt class="method">SetAuth</tt></a></b>(</nobr></td>
  <td><var>style, name, password</var>)</td></tr></table>
<dd>
The <code>style</code> should be one of the constants from the <code>AUTH</code>
class described above.
The remaining parameters will vary depending on the <code>style</code>.
Currently only basic authentication data of name and password are
supported.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-139"><tt class="method">SetNS</tt></a></b>(</nobr></td>
  <td><var>uri</var>)</td></tr></table>
<dd>
Set the default namespace for the request to the specified <code>uri</code>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-140"><tt class="method">SetURL</tt></a></b>(</nobr></td>
  <td><var>url</var>)</td></tr></table>
<dd>
Set the URL where the post is made to <code>url</code>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-141"><tt class="method">ResetHeaders</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Remove any headers that were added by <tt class="method">AddHeader()</tt>.
</dl>

<P>
The following attribute may also be modified:

<P>
<dl><dt><b><a name="l2h-142"><tt class="member">trace</tt></a></b>
<dd>
If this attribute is not <code>None</code>, it should be an object with a
<code>write</code> method, where packet traces will be recorded.
</dl>

<P>
Once the necessary parameters have been specified (at a minimum, the URL
must have been given in the constructor are through <code>SetURL</code>),
invocations can be made.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-143"><tt class="method">RPC</tt></a></b>(</nobr></td>
  <td><var>url, opname, pyobj, replytype=None</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
This is the highest-level invocation method.
It calls <tt class="method">Send()</tt> to send <code>pyobj</code> to the specified <code>url</code>
to perform the <code>opname</code> operation,
and calls <tt class="method">Receive()</tt> expecting to get a reply of the specified
<code>replytype</code>.

<P>
This method will raise a <tt class="exception">TypeError</tt> if the response does not
appear to be a SOAP message, or if is valid SOAP but contains a fault.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-144"><tt class="method">Send</tt></a></b>(</nobr></td>
  <td><var>url, opname, pyboj</var><big>[</big><var>, **keywords</var><big>]</big>)</td></tr></table>
<dd>
This sends the specified <code>pyobj</code> to the specified <code>url</code>, invoking
the <code>opname</code> method.
The <code>url</code> can be <code>None</code> if it was specified in the <tt class="class">Binding</tt>
constructor or if <code>SetURL</code> has been called.
See below for a shortcut version of this method.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>auth_header</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">String (containing presumably
    serialized XML) to output as an authentication header.</td>SOAP <code>Envelope</code>

    <tr><td align="left" valign="baseline"><code>nsdict</code></td>
        <td align="center"><code>{}</code></td>
        <td align="left">Namespace dictionary to send in the
    SOAP <code>Envelope</code></td>
    <tr><td align="left" valign="baseline"><code>requestclass</code></td>
        <td align="center">n/a</td>
        <td align="left">Python <code>class</code> object with a
    <code>typecode</code> attribute specifying how to serialize the data.</td>
    <tr><td align="left" valign="baseline"><code>requesttypecode</code></td>
        <td align="center">n/a</td>
        <td align="left">Typecode specifying how to serialize
    the data.</td>
    <tr><td align="left" valign="baseline"><code>soapaction</code></td>
        <td align="center">Obtained from the <tt class="class">Binding</tt></td>
        <td align="left">Value for the
    <code>SOAPAction</code> HTTP header.</td></tbody>
</table>

<P>
</dl>

<P>
Methods are available to determine the type of response that came back:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-145"><tt class="method">IsSOAP</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Returns true if the message appears to be a SOAP message.
(Some servers return an HTML page under certain error conditions.)
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-146"><tt class="method">IsAFault</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Returns true if the message is a SOAP fault.
</dl>

<P>
Having determined the type of the message (or, more likely, assuming
it was good and catching an exception if not), the following methods
are available to actually parse the data.
They will continue to return the same value until
another message is sent.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-147"><tt class="method">ReceiveRaw</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Returns the unparsed message body.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-148"><tt class="method">ReceiveSoap</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Returns a <tt class="class">ParsedSOAP</tt> object containing the parsed message.
Raises a <tt class="exception">TypeError</tt> if the message wasn't SOAP.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-149"><tt class="method">ReceiveFault</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Returns a <tt class="class">Fault</tt> object containing the SOAP fault message.
Raises a <tt class="exception">TypeError</tt> if the message did not contain a fault.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-150"><tt class="method">Receive</tt></a></b>(</nobr></td>
  <td><var>replytype=None</var>)</td></tr></table>
<dd>
Parses a SOAP message.
The <code>replytype</code> specifies how to parse the data.
If it s <code>None</code>, dynamic parsing will be used, usually resulting
in a Python list.
If <code>replytype</code> is a Python class, then the class's <code>typecode</code>
attribute will be used, otherwise <code>replytype</code> is taken to be
the typecode to use for parsing the data.
</dl>

<P>
Once a reply has been parsed (or its type examined), the following
read-only attributes are available.
Their values will remain unchanged until another reply is parsed.

<P>
<dl><dt><b><a name="l2h-151"><tt class="member">reply_code</tt></a></b>
<dd>
The HTTP reply code, a number.
</dl>

<P>
<dl><dt><b><a name="l2h-152"><tt class="member">reply_headers</tt></a></b>
<dd>
The HTTP headers, as a <tt class="class">mimetools</tt> object.
</dl>

<P>
<dl><dt><b><a name="l2h-153"><tt class="member">reply_msg</tt></a></b>
<dd>
A text string containing the HTTP reply text.
</dl>

<P>
Finally, if an attribute is fetched other than one of those described
above, it is taken to be the <code>opname</code> of a remote procedure,
and a callable object is returned.
This object dynamically parses its arguments, receives the reply, and
parses that.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-154"><tt class="method">opname</tt></a></b>(</nobr></td>
  <td><var>args...</var>)</td></tr></table>
<dd>
Using this shortcut requires that the <tt class="method">SetURL()</tt> was invoked first.
This method is then equivalent to:
"<tt class="samp">RPC(None, opname, tuple(args), TC.Any())</tt>"</dl>

<H1><A NAME="SECTION0012000000000000000000">
11. WSDL Support</A>
</H1>

<P>
The <tt class="module">ZSI</tt>&nbsp;and <tt class="module">ZSI.wstools</tt> modules provide client tools for
using WSDL 1.1
(see <em class="citetitle"><a
 href="http://www.w3.org/TR/wsdl"
 title="WSDL 1.1 specification"
 >WSDL 1.1 specification</a></em>).

<P>
ZSI provides two ways of accessing a WSDL service.  The first
provides an easy-to-use interface,
but requires setting all type codes manually.  It is easier
to use with simple services than with those specifying many
complex types.
The second method requires the use of a more complex
interface, but automatically generates type codes and classes
that correspond to XML Schema types, as well as client stub code.
Both use a <tt class="class">WSDL</tt> instance internally to send and receive
messages (see section 11.4 for more information on the <tt class="class">WSDL</tt>
class).

<P>
The first way of accessing a service is through the <tt class="class">ServiceProxy</tt> class.
Once the proxy has been created, each remote operation is exposed
as a method on the object.
The user must handle the generation of type codes.
Note that while <tt class="class">ServiceProxy</tt> is part of <tt class="module">ZSI</tt>, it must be
explicitly imported.

<P>
The second method uses wsdl2py.  Handling XML Schema
(see <em class="citetitle"><a
 href="http://www.w3.org/XML/Schema"
 title="XML Schema specification"
 >XML Schema specification</a></em>) 
is one of the more difficult aspects
of using WSDL.  The class <tt class="class">WriteServiceModule</tt>, which wsdl2py
uses, helps to hides these
details.  It generates a module with stub code for the client interface,
and a module that encapsulates the handling of XML Schema, automatically
generating type codes.

<P>

<H1><A NAME="SECTION0012100000000000000000">
11.1 WSDLReader</A>
</H1>

<P>
The <tt class="class">WSDLReader</tt> class in <tt class="module">ZSI.wstools.WSDLTools</tt> provides
methods for loading WSDL service descriptions from URLs, XML files
or XML string data, and creating a <tt class="class">WSDL</tt> object.
It is used by <tt class="class">ServiceProxy</tt> and <tt class="class">WriteServiceModule</tt>.

<P>
<tt class="class">WSDL</tt> instances represent WSDL service descriptions and provide 
a low-level object model for building and working with those descriptions.

<P>
The WSDL reader is implemented as a 
separate class to make it easy to create custom readers that implement 
caching policies or other optimizations.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-155"><tt class="class">WSDLReader</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
The following methods are available:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-156"><tt class="method">loadFromStream</tt></a></b>(</nobr></td>
  <td><var>file</var>)</td></tr></table>
<dd>
Return a <tt class="class">WSDL</tt> instance representing the service description 
contained in <var>file</var>. The <var>file</var> argument must be a file-like 
object.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-157"><tt class="method">loadFromString</tt></a></b>(</nobr></td>
  <td><var>data</var>)</td></tr></table>
<dd>
Returns a <tt class="class">WSDL</tt> instance loaded from the XML string <var>data</var>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-158"><tt class="method">loadFromFile</tt></a></b>(</nobr></td>
  <td><var>filename</var>)</td></tr></table>
<dd>
Returns a <tt class="class">WSDL</tt> instance loaded from the file named by <var>filename</var>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-159"><tt class="method">loadFromURL</tt></a></b>(</nobr></td>
  <td><var>url</var>)</td></tr></table>
<dd>
Returns a <tt class="class">WSDL</tt> instance loaded from the given <var>url</var>.
</dl>

<P>
</dl>

<P>

<H1><A NAME="SECTION0012200000000000000000">
11.2 ServiceProxy</A>
</H1>

<P>
The <tt class="class">ServiceProxy</tt> class provides calls to
web services. A WSDL description must be available for the 
service.  <tt class="class">ServiceProxy</tt> uses <tt class="class">WSDLReader</tt> internally to load 
a <tt class="class">WSDL</tt> instance.

<P>
The user may build up a type codes module for use by <tt class="class">ServiceProxy</tt>.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-160"><tt class="class">ServiceProxy</tt></a></b>(</nobr></td>
  <td><var>wsdl,</var><big>[</big><var>, service</var><big>[</big><var>, port</var><big>]</big><big>]</big>)</td></tr></table>
<dd>

<P>
The <var>wsdl</var> argument may be either the URL of the service description 
or an existing <tt class="class">WSDL</tt> instance. The optional <var>service</var> and 
<var>port</var> name the service and port within the WSDL description that 
should be used. If not specified, the first defined service and port 
will be used.

<P>
The following keyword arguments may be used:

<P>
<table border align="center" style="border-collapse: collapse">
  <thead>
    <tr class="tableheader">
      <th align="left"><b>Keyword</b>&nbsp;</th>
      <th align="center"><b>Default</b>&nbsp;</th>
      <th align="left"><b>Description</b>&nbsp;</th>
      </tr>
    </thead>
  <tbody valign="baseline">
    <tr><td align="left" valign="baseline"><code>nsdict</code></td>
        <td align="center"><code>{}</code></td>
        <td align="left">Namespace dictionary to send in the
    SOAP <code>Envelope</code></td>
    <tr><td align="left" valign="baseline"><code>tracefile</code></td>
        <td align="center"><code>None</code></td>
        <td align="left">An object with a <code>write</code>
    method, where packet traces will be recorded.</td></tbody>
</table>

<P>
A <tt class="class">ServiceProxy</tt> instance, once instantiated, exposes callable 
methods that reflect the methods of the remote web service it 
represents. These methods may be called like normal methods, using 
*either* positional or keyword arguments (but not both).

<P>
The methods can be called with either positional or keyword arguments;
the argument types must be compatible with the types specified in the
WSDL description.

<P>
When a method of a <tt class="class">ServiceProxy</tt> is called with positional 
arguments, the arguments are mapped to the SOAP request based on 
the parameter order defined in the WSDL description. If keyword 
arguments are passed, the arguments will be mapped based on their 
names.

<P>
</dl>

<P>

<H2><A NAME="SECTION0012210000000000000000">
11.2.1 Example</A>
</H2>

<P>
The following example, using ServiceProxy,  shows a simple language
translation service that makes
use of the complex type structures defined in the module BabelTypes:

<P>
<div class="verbatim"><pre>
from ZSI import ServiceProxy
import BabelTypes

service = ServiceProxy('http://www.xmethods.net/sd/BabelFishService.wsdl',
		       typesmodule=BabelTypes)
value = service.BabelFish('en_de', 'This is a test!')
</pre></div>

<P>
The return value from a proxy method depends on the SOAP signature. If the 
remote service returns a single value, that value will be returned. If the 
remote service returns multiple ``out'' parameters, the return value of the 
proxy method will be a dictionary containing the out parameters indexed by 
name.  Because <tt class="class">ServiceProxy</tt> makes use of the ZSI serialization / 
deserialization engine, complex return types are supported.  This means 
that an aggregation of primitives can be returned from or passed to a service
invocation according to any predefined hierarchical structure.

<P>

<H1><A NAME="SECTION0012300000000000000000">
11.3 Code Generation from WSDL and XML Schema</A>
</H1>

<P>
This section covers wsdl2py, the second way ZSI provides to access WSDL
services.  Given the path to a WSDL service, two files are generated, a 
'service' file and a 'types' file, that one can then use to access the
service.  For example, to generate code to access the TerraServer database,
the script can be called as follows:

<P>
<div class="verbatim"><pre>
wsdl2py http://terraservice.net/TerraService.asmx?WSDL
</pre></div>

<P>
To generate the 'service' file, wsdl2py uses the <tt class="class">WriteServiceModule</tt>
class in <tt class="module">ZSI.wsdl2python</tt>.
<tt class="class">WriteServiceModule</tt> transforms the definitions in a WSDL instance
to remote proxy interfaces in the 'service' file.
To generate the 'types' file, wsdl2py transforms the XML Schema instances in
the WSDL types section to type codes that describe
the data.

<P>
The <tt class="class">WSDL</tt> (see section 11.4) class and <tt class="module">ZSI.wstools.XMLSchema</tt>
module provide API's into the
definitions, which <tt class="class">ModuleWriter</tt> and its underlying generator classes
use to interpret WSDL and XML Schema into class definitions.

<P>
The 'service' file contains locator, portType, and message classes.  
A locator instance is used to
get an instance of a portType class, which is a remote proxy object.
Message instances are sent and received through the methods of the
portType instance.

<P>
The 'types' file contains class representations of the definitions and
declarations defined by all schema instances imported by the WSDL definition.
XML Schema attributes, wildcards, and derived types are not fully
handled.

<P>

<H2><A NAME="SECTION0012310000000000000000">
11.3.1 WriteServiceModule Class Description</A>
</H2>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-161"><tt class="class">WriteServiceModule</tt></a></b>(</nobr></td>
  <td><var>wsdl, </var><big>[</big><var>importlib,
</var><big>[</big><var>typewriter</var><big>]</big><big>]</big>)</td></tr></table>
<dd>

<P>
This class generates a module containing client stub code, and a module
encapsulating the use of XML Schema instances, given a <tt class="class">WSDL</tt>
instance generated by <tt class="class">WSDLReader</tt>.
It handles import, namespace, and schema complexities, and class definition
order.

<P>
<tt class="class">WriteServiceModule</tt> delegates to <tt class="class">ServiceDescription</tt> the
interpretation
of the service definition, and to <tt class="class">SchemaDescription</tt> the interpretation
of the schema definition.  (These two classes are only intended to be called
by <tt class="class">WriteServiceModule</tt>, but are described here to indicate what
is going on behind the scenes.)

<P>
The following method is available:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-162"><tt class="method">write</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Generates the client code.
</dl>

<P>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-163"><tt class="class">ServiceDescription</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Interprets the service definition, and creates the client interface and
port descriptions code.  It delegates to <tt class="class">MessageWriter</tt>, which
generates a message's class definition, and to <tt class="class">PartWriter</tt>, which
generates a message part's description.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-164"><tt class="class">SchemaDescription</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Interprets the schema definition, generating typecode module code
for all global definitions and declarations in a schema instance.
It delegates to <tt class="class">TypeWriter</tt>, which generates a type's
description/typecode.
</dl>

<P>
The following excerpt is from wsdl2py, and illustrates how
<tt class="class">WriteServiceModule</tt> is used.  The input is a 
path name of a WSDL file or URL.

<P>
<div class="verbatim"><pre>
    ...
    reader = WSDLTools.WSDLReader()
    if args_d['fromfile']:
        wsdl = reader.loadFromFile(args_d['wsdl'])
    elif args_d['fromurl']:
        wsdl = reader.loadFromURL(args_d['wsdl'])
    wsm = ZSI.wsdl2python.WriteServiceModule(wsdl)
    wsm.write()
    ...
</pre></div>

<P>

<H2><A NAME="SECTION0012320000000000000000">
11.3.2 Example Use of Generated Code</A>
</H2>

<P>
The following shows how to call a proxy method for
ConvertPlaceToLonLatPt, a method provided by a service
named TerraService. It assumes that wsdl2py has already been called.
In this case, the 'services' and 'types' files generated would
be named TerraService_services.py and TerraService_services_types.py,
respectively.

<P>
<div class="verbatim"><pre>
from TerraService_services import *

import sys

def main():
    loc = TerraServiceLocator()

       # prints messages sent and received if tracefile is set
    kw = { 'tracefile' : sys.stdout }
    portType = loc.getTerraServiceSoap(**kw)

       # ns1 is an alias for a namespace
       # Place_Def is defined in TerraService_services_types,
       # which TerraService_services imports
    place = ns1.Place_Def()
    place._City = 'Oak Harbor'
    place._State = 'Washington'
    place._Country = 'United States'

    request = ConvertPlaceToLonLatPtSoapInWrapper()
    request._place = place

    response = portType.ConvertPlaceToLonLatPt(request)
    print "Latitude = %s" % response._ConvertPlaceToLonLatPtResult._Lat
    print "Longitude = %s" % response._ConvertPlaceToLonLatPtResult._Lon
...
</pre></div>

<P>
One needs to look at the associated WSDL file to see how
to use the classes and methods in the generated code.
In this example, <tt class="class">TerraServiceLocator</tt>
is a class with the name of the WSDL service, plus 'Locator'.  It contains the
information necessary to contact the service, using
<tt class="method">getTerraServiceSoap(**kw)</tt>.

<P>
That method's name is generated by 'get' plus the name of the WSDL portType
for the service.  It returns a class which
encapsulates the information in the portType, and contains the proxies
for the methods associated with it.

<P>
<tt class="method">ConvertPlaceToLonLatPtSoapInWrapper()</tt>'s
name is generated using
the name of the WSDL input message for the ConvertPlaceToLonLatPt
WSDL operation, plus 'Wrapper'.  The actual call to the service is a method of
the class encapsulating the portType, with the same name as the WSDL operation.

<P>
The name of the response field is '_' plus the name of the
WSDL element (or one contained by the element) returned by the call.
Parameters that are input and output are subfields of
the request object and the response field, respectively. 
Their names can be determined by looking at the part sub-element of a
message.

<P>
If the user wishes to set authorization headers in a request, using the 
previous example, it would be accomplished like this:

<P>
<div class="verbatim"><pre>
def main():

    loc = TerraServiceLocator()

    kw = { 'tracefile' : sys.stdout, 'auth' : ( soap.ZSI.AUTH.httpbasic,  'logname', 'password' ) }

    portType = loc.getTerraServiceSoap( **kw ) 
...
</pre></div>

<P>

<H1><A NAME="SECTION0012400000000000000000">
11.4 WSDL objects</A>
</H1>

<P>
The following classes described encapsulate the upper-level objects
in a WSDL file.  Note that most users will not need to use these,
given the availability of <tt class="class">WriteServiceModule</tt> and
<tt class="class">ServiceProxy</tt>, which are built on top of these objects.

<P>
There are quite many classes defined here to
implement the WSDL object model. Instances of those classes are generally 
accessed and created through container objects rather than instantiated 
directly. Most of them simply implement a straightforward representation of 
the WSDL elements they represent. The interfaces of these objects are 
described in the next section.

<P>
An exception is defined for errors that occur while creating WSDL objects.

<P>
<dl><dt><b><span class="typelabel">exception</span>&nbsp;<a name="l2h-165"><tt class="exception">WSDLError</tt></a></b>
<dd>
This exception is raised when errors occur in the parsing or building of 
WSDL objects, usually indicating invalid structure or usage.
It is a subtype of Python's <tt class="exception">Exception</tt> class.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-166"><tt class="class">WSDL</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
<tt class="class">WSDL</tt> instances implement the WSDL object model. They are
created by loading an XML source into a <tt class="class">WSDLReader</tt> object.

<P>
A <tt class="class">WSDL</tt> object provides access to all of the structures that make 
up a web service description. The various ``collections'' in the WSDL 
object model (services, bindings, portTypes, etc.) are implemented as 
<tt class="class">Collection</tt> objects that behave like ordered mappings.

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-167"><tt class="member">name</tt></a></b>
<dd>
The name of the service description (associated with the <i>definitions</i> 
element), or <code>None</code> if not specified.
</dl>

<P>
<dl><dt><b><a name="l2h-168"><tt class="member">targetNamespace</tt></a></b>
<dd>
The target namespace associated with the service description, or 
<code>None</code> if not specified.
</dl>

<P>
<dl><dt><b><a name="l2h-169"><tt class="member">documentation</tt></a></b>
<dd>
The documentation associated with the <i>definitions</i> element of the 
service description, or the empty string if not specified.
</dl>

<P>
<dl><dt><b><a name="l2h-170"><tt class="member">location</tt></a></b>
<dd>
The URL from which the service description was loaded, or <code>None</code> 
if the description was not loaded from a URL.
</dl>

<P>
<dl><dt><b><a name="l2h-171"><tt class="member">services</tt></a></b>
<dd>
A collection that contains <tt class="class">Service</tt> objects that represent the 
services that appear in the service description. The items of this 
collection may be indexed by name or ordinal. 
</dl>

<P>
<dl><dt><b><a name="l2h-172"><tt class="member">messages</tt></a></b>
<dd>
A collection that contains <tt class="class">Message</tt> objects that represent the 
messages that appear in the service description. The items of this 
collection may be indexed by name or ordinal. 
</dl>

<P>
<dl><dt><b><a name="l2h-173"><tt class="member">portTypes</tt></a></b>
<dd>
A collection that contains <tt class="class">PortType</tt> objects that represent the 
portTypes that appear in the service description. The items of this 
collection may be indexed by name or ordinal. 
</dl>

<P>
<dl><dt><b><a name="l2h-174"><tt class="member">bindings</tt></a></b>
<dd>
A collection that contains <tt class="class">Binding</tt> objects that represent the 
bindings that appear in the service description. The items of this 
collection may be indexed by name or ordinal. 
</dl>

<P>
<dl><dt><b><a name="l2h-175"><tt class="member">imports</tt></a></b>
<dd>
A collection that contains <tt class="class">ImportElement</tt> objects that represent the 
import elements that appear in the service description. The items of this 
collection may be indexed by ordinal or the target namespace URI of the 
import element.
</dl>

<P>
<dl><dt><b><a name="l2h-176"><tt class="member">types</tt></a></b>
<dd>
A <tt class="class">Types</tt> instance that contains <tt class="class">XMLSchema</tt> objects that 
represent the schemas defined or imported by the WSDL description. The 
<tt class="class">Types</tt> object may be indexed by ordinal or by targetNamespace to 
lookup schema objects.
</dl>

<P>
<dl><dt><b><a name="l2h-177"><tt class="member">extensions</tt></a></b>
<dd>
A sequence of objects that represent WSDL <i>extension elements</i>. These 
objects may be instances of classes that represent WSDL-defined extensions 
(<tt class="class">SoapBinding</tt>, <tt class="class">SoapBodyBinding</tt>, etc.), or DOM <tt class="class">Element</tt> 
objects for unknown extensions.
</dl>

<P>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-178"><tt class="class">Service</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
A <tt class="class">Service</tt> object represents a WSDL <code>&lt;service&gt;</code> element.

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-179"><tt class="member">name</tt></a></b>
<dd>
The name of the service.
</dl>

<P>
<dl><dt><b><a name="l2h-180"><tt class="member">documentation</tt></a></b>
<dd>
The documentation associated with the element, or an empty string.
</dl>

<P>
<dl><dt><b><a name="l2h-181"><tt class="member">ports</tt></a></b>
<dd>
A collection that contains <tt class="class">Port</tt> objects that represent the 
ports defined by the service. The items of this collection may be indexed 
by name or ordinal. 
</dl>

<P>
<dl><dt><b><a name="l2h-182"><tt class="member">extensions</tt></a></b>
<dd>
A sequence of any contained WSDL extensions.
</dl>

<P>
The following method is available:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-183"><tt class="method">getWSDL</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return the parent <tt class="class">WSDL</tt> instance of the object.
</dl>

<P>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-184"><tt class="class">Port</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
A <tt class="class">Port</tt> object represents a WSDL <code>&lt;port&gt;</code> element.

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-185"><tt class="member">name</tt></a></b>
<dd>
The name of the port.
</dl>

<P>
<dl><dt><b><a name="l2h-186"><tt class="member">documentation</tt></a></b>
<dd>
The documentation associated with the element, or an empty string.
</dl>

<P>
<dl><dt><b><a name="l2h-187"><tt class="member">binding</tt></a></b>
<dd>
The name of the binding associated with the port.
</dl>

<P>
<dl><dt><b><a name="l2h-188"><tt class="member">extensions</tt></a></b>
<dd>
A sequence of any contained WSDL extensions.
</dl>

<P>
The following methods are available:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-189"><tt class="method">getAddressBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
A convenience method that returns the address binding extension for the 
port, either a <tt class="class">SoapAddressBinding</tt> or <tt class="class">HttpAddressBinding</tt>.
Raises <tt class="exception">WSDLError</tt> if no address binding is found.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-190"><tt class="method">getService</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return the parent <tt class="class">Service</tt> instance of the object.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-191"><tt class="method">getBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return the <tt class="class">Binding</tt> instance associated with the port.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-192"><tt class="method">getPortType</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return the <tt class="class">PortType</tt> instance associated with the port.
</dl>

<P>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-193"><tt class="class">PortType</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
A <tt class="class">PortType</tt> object represents a WSDL <code>&lt;portType&gt;</code> element.

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-194"><tt class="member">name</tt></a></b>
<dd>
The name of the portType.
</dl>

<P>
<dl><dt><b><a name="l2h-195"><tt class="member">documentation</tt></a></b>
<dd>
The documentation associated with the element, or an empty string.
</dl>

<P>
<dl><dt><b><a name="l2h-196"><tt class="member">operations</tt></a></b>
<dd>
A collection that contains <tt class="class">Operation</tt> objects that represent the 
operations in the portType. The items of this collection may be indexed 
by name or ordinal. 
</dl>

<P>
The following method is available:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-197"><tt class="method">getWSDL</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return the parent <tt class="class">WSDL</tt> instance of the object.
</dl>

<P>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-198"><tt class="class">Operation</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
A <tt class="class">Operation</tt> object represents a WSDL <code>&lt;operation&gt;</code> element 
within a <code>portType</code> element.

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-199"><tt class="member">name</tt></a></b>
<dd>
The name of the operation.
</dl>

<P>
<dl><dt><b><a name="l2h-200"><tt class="member">documentation</tt></a></b>
<dd>
The documentation associated with the element, or an empty string.
</dl>

<P>
<dl><dt><b><a name="l2h-201"><tt class="member">parameterOrder</tt></a></b>
<dd>
A string representing the <code>parameterOrder</code> attribute of the operation, 
or <code>None</code> if the attribute is not defined.
</dl>

<P>
<dl><dt><b><a name="l2h-202"><tt class="member">input</tt></a></b>
<dd>
A <tt class="class">MessageRole</tt> instance representing the <code>&lt;input&gt;</code> element of 
the operation binding, or <code>None</code> if no input element is present.
</dl>

<P>
<dl><dt><b><a name="l2h-203"><tt class="member">output</tt></a></b>
<dd>
A <tt class="class">MessageRole</tt> instance representing the <code>&lt;output&gt;</code> element of 
the operation, or <code>None</code> if no output element is present.
</dl>

<P>
<dl><dt><b><a name="l2h-204"><tt class="member">faults</tt></a></b>
<dd>
A collection of <tt class="class">MessageRole</tt> instances representing the <code>&lt;fault&gt;</code> 
elements of the operation.
</dl>

<P>
The following methods are available:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-205"><tt class="method">getPortType</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return the parent <tt class="class">PortType</tt> instance of the object.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-206"><tt class="method">getInputMessage</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return <tt class="class">Message</tt> object associated with the input to the operation.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-207"><tt class="method">getOutputMessage</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return <tt class="class">Message</tt> object associated with the output of the operation.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-208"><tt class="method">getFaultMessage</tt></a></b>(</nobr></td>
  <td><var>name</var>)</td></tr></table>
<dd>
Return <tt class="class">Message</tt> object associated with the named fault.
</dl>

<P>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-209"><tt class="class">MessageRole</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
<tt class="class">MessageRole</tt> objects represent WSDL <code>&lt;input&gt;</code>, <code>&lt;output&gt;</code> 
and <code>&lt;fault&gt;</code> elements within an operation.

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-210"><tt class="member">name</tt></a></b>
<dd>
The name attribute of the element.
</dl>

<P>
<dl><dt><b><a name="l2h-211"><tt class="member">type</tt></a></b>
<dd>
The type of the element, one of <code>'input'</code>, <code>'output'</code> or 
<code>'fault'</code>.
</dl>

<P>
<dl><dt><b><a name="l2h-212"><tt class="member">message</tt></a></b>
<dd>
The name of the message associated with the object.
</dl>

<P>
<dl><dt><b><a name="l2h-213"><tt class="member">documentation</tt></a></b>
<dd>
The documentation associated with the element, or an empty string.
</dl>

<P>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-214"><tt class="class">Binding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
A <tt class="class">Binding</tt> object represents a WSDL <code>&lt;binding&gt;</code> element.

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-215"><tt class="member">name</tt></a></b>
<dd>
The name of the binding.
</dl>

<P>
<dl><dt><b><a name="l2h-216"><tt class="member">documentation</tt></a></b>
<dd>
The documentation associated with the element, or an empty string.
</dl>

<P>
<dl><dt><b><a name="l2h-217"><tt class="member">type</tt></a></b>
<dd>
The name of the portType the binding is associated with.
</dl>

<P>
<dl><dt><b><a name="l2h-218"><tt class="member">operations</tt></a></b>
<dd>
A collection that contains <tt class="class">OperationBinding</tt> objects that represent 
the contained operation bindings.
</dl>

<P>
<dl><dt><b><a name="l2h-219"><tt class="member">extensions</tt></a></b>
<dd>
A sequence of any contained WSDL extensions.
</dl>

<P>
The following methods are available:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-220"><tt class="method">getWSDL</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return the parent <tt class="class">WSDL</tt> instance of the object.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-221"><tt class="method">getPortType</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return the <tt class="class">PortType</tt> object associated with the binding.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-222"><tt class="method">findBinding</tt></a></b>(</nobr></td>
  <td><var>kind</var>)</td></tr></table>
<dd>
Find a binding extension in the binding. The <var>kind</var> can be a class 
object if the wanted extension is one of the WSDL-defined types (such as 
<tt class="class">SoapBinding</tt> or <tt class="class">HttpBinding</tt>). If the extension is not one of 
the supported types, <var>kind</var> can be a tuple of the form 
<code>(namespace-URI, localname)</code>, which will be used to try to find a 
matching DOM <tt class="class">Element</tt>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-223"><tt class="method">findBindings</tt></a></b>(</nobr></td>
  <td><var>kind</var>)</td></tr></table>
<dd>
The same as <tt class="method">findBinding()</tt>, but will return multiple values of 
the given <var>kind</var>.
</dl>

<P>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-224"><tt class="class">OperationBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
A <tt class="class">OperationBinding</tt> object represents a WSDL <code>&lt;operation&gt;</code> 
element within a binding element.

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-225"><tt class="member">name</tt></a></b>
<dd>
The name of the operation binding.
</dl>

<P>
<dl><dt><b><a name="l2h-226"><tt class="member">documentation</tt></a></b>
<dd>
The documentation associated with the element, or an empty string.
</dl>

<P>
<dl><dt><b><a name="l2h-227"><tt class="member">input</tt></a></b>
<dd>
A <tt class="class">MessageRoleBinding</tt> instance representing the <code>&lt;input&gt;</code> 
element of the operation binding, or <code>None</code> if no input element is 
present.
</dl>

<P>
<dl><dt><b><a name="l2h-228"><tt class="member">output</tt></a></b>
<dd>
A <tt class="class">MessageRoleBinding</tt> instance representing the <code>&lt;output&gt;</code> 
element of the operation binding, or <code>None</code> if no output element is 
present.
</dl>

<P>
<dl><dt><b><a name="l2h-229"><tt class="member">faults</tt></a></b>
<dd>
A collection of <tt class="class">MessageRoleBinding</tt> instances representing the 
<code>&lt;fault&gt;</code> elements of the operation binding.
</dl>

<P>
<dl><dt><b><a name="l2h-230"><tt class="member">extensions</tt></a></b>
<dd>
A sequence of any contained WSDL extensions.
</dl>

<P>
The following methods are available:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-231"><tt class="method">getBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return the parent <tt class="class">Binding</tt> instance of the operation binding.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-232"><tt class="method">getOperation</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return the abstract <tt class="class">Operation</tt> associated with the operation binding.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-233"><tt class="method">findBinding</tt></a></b>(</nobr></td>
  <td><var>kind</var>)</td></tr></table>
<dd>
Find a binding extension in the operation binding. The <var>kind</var> can be a 
class object if the wanted extension is one of the WSDL-defined types (such 
as <tt class="class">SoapOperationsBinding</tt> or <tt class="class">HttpOperationBinding</tt>). 

<P>
If the extension is not one of the supported types, <var>kind</var> can be a
tuple of the form <code>(namespace-URI, localname)</code>, which will be used to 
try to find a matching DOM <tt class="class">Element</tt>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-234"><tt class="method">findBindings</tt></a></b>(</nobr></td>
  <td><var>kind</var>)</td></tr></table>
<dd>
The same as <tt class="method">findBinding()</tt>, but will return multiple values of 
the given <var>kind</var>.
</dl>

<P>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-235"><tt class="class">MessageRoleBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
<tt class="class">MessageRoleBinding</tt> objects represent WSDL <code>&lt;input&gt;</code>, 
<code>&lt;output&gt;</code> and <code>&lt;fault&gt;</code> elements within an operation binding.

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-236"><tt class="member">name</tt></a></b>
<dd>
The name attribute of the element, for fault elements. This is always 
<code>None</code> for input and output elements.
</dl>

<P>
<dl><dt><b><a name="l2h-237"><tt class="member">type</tt></a></b>
<dd>
The type of the element, one of <code>'input'</code>, <code>'output'</code> or 
<code>'fault'</code>.
</dl>

<P>
<dl><dt><b><a name="l2h-238"><tt class="member">documentation</tt></a></b>
<dd>
The documentation associated with the element, or an empty string.
</dl>

<P>
<dl><dt><b><a name="l2h-239"><tt class="member">extensions</tt></a></b>
<dd>
A sequence of any contained WSDL extensions.
</dl>

<P>
The following methods are available:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-240"><tt class="method">findBinding</tt></a></b>(</nobr></td>
  <td><var>kind</var>)</td></tr></table>
<dd>
Find a binding extension in the message role binding. The <var>kind</var> can be a 
class object if the wanted extension is one of the WSDL-defined types.

<P>
If the extension is not one of the supported types, <var>kind</var> can be a
tuple of the form <code>(namespace-URI, localname)</code>, which will be used to 
try to find a matching DOM <tt class="class">Element</tt>.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-241"><tt class="method">findBindings</tt></a></b>(</nobr></td>
  <td><var>kind</var>)</td></tr></table>
<dd>
The same as <tt class="method">findBinding()</tt>, but will return multiple values of 
the given <var>kind</var>.
</dl>

<P>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-242"><tt class="class">Message</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
A <tt class="class">Message</tt> object represents a WSDL <code>&lt;message&gt;</code> element.

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-243"><tt class="member">name</tt></a></b>
<dd>
The name of the message.
</dl>

<P>
<dl><dt><b><a name="l2h-244"><tt class="member">documentation</tt></a></b>
<dd>
The documentation associated with the element, or an empty string.
</dl>

<P>
<dl><dt><b><a name="l2h-245"><tt class="member">parts</tt></a></b>
<dd>
A collection that contains <tt class="class">MessagePart</tt> objects that represent the 
parts of the message. The items of this collection may be indexed 
by name or ordinal. 
</dl>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-246"><tt class="class">MessagePart</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
A <tt class="class">MessagePart</tt> object represents a WSDL <code>&lt;part&gt;</code> element.

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-247"><tt class="member">name</tt></a></b>
<dd>
The name of the message part.
</dl>

<P>
<dl><dt><b><a name="l2h-248"><tt class="member">documentation</tt></a></b>
<dd>
The documentation associated with the element, or an empty string.
</dl>

<P>
<dl><dt><b><a name="l2h-249"><tt class="member">type</tt></a></b>
<dd>
A tuple of the form <code>(namespace-URI, localname)</code>, or <code>None</code> 
if the <tt class="member">type</tt> attribute is not defined.
</dl>

<P>
<dl><dt><b><a name="l2h-250"><tt class="member">element</tt></a></b>
<dd>
A tuple of the form <code>(namespace-URI, localname)</code>, or <code>None</code> 
if the <tt class="member">element</tt> attribute is not defined.
</dl>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-251"><tt class="class">Types</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
The following attributes are read-only:

<P>
A <tt class="class">Types</tt> object represents a WSDL <code>&lt;types&gt;</code> element. It acts 
as an ordered collection containing <tt class="class">XMLSchema</tt> instances associated 
with the service description (either directly defined in a <code>&lt;types&gt;</code> 
element, or included via import). The <tt class="class">Types</tt> object can be indexed 
by ordinal or by the <code>targetNamespace</code> of the contained schemas.

<P>
<dl><dt><b><a name="l2h-252"><tt class="member">documentation</tt></a></b>
<dd>
The documentation associated with the element, or an empty string.
</dl>

<P>
<dl><dt><b><a name="l2h-253"><tt class="member">extensions</tt></a></b>
<dd>
A sequence of any contained WSDL extensions.
</dl>

<P>
The following method is available:

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><a name="l2h-254"><tt class="method">getWSDL</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Return the parent <tt class="class">WSDL</tt> instance of the object.
</dl>
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-255"><tt class="class">ImportElement</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>

<P>
A <tt class="class">ImportElement</tt> object represents a WSDL <code>&lt;import&gt;</code> element.

<P>
The following attributes are read-only:

<P>
<dl><dt><b><a name="l2h-256"><tt class="member">namespace</tt></a></b>
<dd>
The namespace attribute of the import element.
</dl>

<P>
The following method is available:

<P>
<dl><dt><b><a name="l2h-257"><tt class="member">location</tt></a></b>
<dd>
The location attribute of the import element.
</dl>
</dl>

<P>

<H2><A NAME="SECTION0012410000000000000000">
11.4.1 Binding Classes</A>
</H2>

<P>
The <tt class="module">WSDLTools</tt> module contains a number of classes that represent 
the binding extensions defined in the WSDL specification. These classes 
are straightforward, reflecting the attributes of the corresponding 
XML elements, so they are not documented exhaustively here.

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-258"><tt class="class">SoapBinding</tt></a></b>(</nobr></td>
  <td><var>transport</var><big>[</big><var>, style</var><big>]</big>)</td></tr></table>
<dd>
Represents a <code>&lt;soap:binding&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-259"><tt class="class">SoapAddressBinding</tt></a></b>(</nobr></td>
  <td><var>location</var>)</td></tr></table>
<dd>
Represents a <code>&lt;soap:address&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-260"><tt class="class">SoapOperationBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;soap:operation&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-261"><tt class="class">SoapBodyBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;soap:body&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-262"><tt class="class">SoapFaultBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;soap:fault&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-263"><tt class="class">SoapHeaderBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;soap:header&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-264"><tt class="class">SoapHeaderFaultBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;soap:headerfault&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-265"><tt class="class">HttpBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;http:binding&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-266"><tt class="class">HttpAddressBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;http:address&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-267"><tt class="class">HttpOperationBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;http:operation&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-268"><tt class="class">HttpUrlReplacementBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;http:urlReplacement&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-269"><tt class="class">HttpUrlEncodedBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;http:urlEncoded&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-270"><tt class="class">MimeMultipartRelatedBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;mime:multipartRelated&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-271"><tt class="class">MimePartBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;mime:part&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-272"><tt class="class">MimeContentBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;mime:content&gt;</code> element.
</dl>

<P>
<dl><dt><table cellpadding="0" cellspacing="0"><tr valign="baseline">
  <td><nobr><b><span class="typelabel">class</span>&nbsp;<a name="l2h-273"><tt class="class">MimeXmlBinding</tt></a></b>(</nobr></td>
  <td>)</td></tr></table>
<dd>
Represents a <code>&lt;mime:mimeXml&gt;</code> element.
</dl>

<P>

<H1><A NAME="SECTION0013000000000000000000">
12. ZSI Schema</A>
</H1>

<P>
The <tt class="module">ZSI</tt> schema defines two sets of elements.  One is used to enhance
the SOAP Fault <code>detail</code> element, and to report header errors.
The other is used to define a header element containing a name and
password, for a class of basic authentication.

<P>
<BR>
<PRE  CLASS="verbatim">
&lt;schema xmlns="http://www.w3.org/2001/XMLSchema"
  xmlns:tns="http://www.zolera.com/schemas/ZSI/"
  xmlns:SOAPFAULT="http://schemas.xmlsoap.org/soap/envelope/"
  targetNamespace="http://www.zolera.com/schemas/ZSI/"&gt;

  &lt;import namespace="http://schemas.xmlsoap.org/soap/envelope/"
    schemaLocation="http://schemas.xmlsoap.org/soap/envelope/"/&gt;

  &lt;!--  Soap doesn't define a fault element to use when we want
        to fault because of header problems. --&gt;
  &lt;element name="detail" type="SOAPFAULT:detail"/&gt;

  &lt;!--  A URIFaultDetail element typically reports an unknown
        mustUnderstand element. --&gt;
  &lt;element name="URIFaultDetail" type="tns:URIFaultDetail"/&gt;
  &lt;complexType name="URIFaultDetail"&gt;
    &lt;sequence&gt;
      &lt;element name="URI" type="anyURI" minOccurs="1"/&gt;
      &lt;element name="localname" type="NCName" minOccurs="1"/&gt;
      &lt;any minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

  &lt;!--  An ActorFaultDetail element typically reports an actor
        attribute was found that cannot be processed. --&gt;
  &lt;element name="ActorFaultDetail" type="tns:ActorFaultDetail"/&gt;
  &lt;complexType name="ActorFaultDetail"&gt;
    &lt;sequence&gt;
      &lt;element name="URI" type="anyURI" minOccurs="1"/&gt;
      &lt;any minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

  &lt;!--  A ParseFaultDetail or a FaultDetail element are typically
        used when there was parsing or "business-logic" errors.
        The TracedFault type is intended to provide a human-readable
        string that describes the error (in more detail then the
        SOAP faultstring element, which is becoming codified),
        and a human-readable "trace" (optional) that shows where
        within the application that the fault happened. --&gt;
  &lt;element name="ParseFaultDetail" type="tns:TracedFault"/&gt;
  &lt;element name="FaultDetail" type="tns:TracedFault"/&gt;
  &lt;complexType name="TracedFault"&gt;
    &lt;sequence&gt;
      &lt;element name="string" type="string" minOccurs="1"/&gt;
      &lt;element name="trace" type="string" minOccurs="0"/&gt;
      &lt;!-- &lt;any minOccurs="0" maxOccurs="unbounded"/&gt; --&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

  &lt;!--  An element to hold a name and password, for doing basic-auth. --&gt;
  &lt;complexType name="BasicAuth"&gt;
    &lt;sequence&gt;
      &lt;element name="Name" type="string" minOccurs="1"/&gt;
      &lt;element name="Password" type="string" minOccurs="1"/&gt;
    &lt;/sequence&gt;
  &lt;/complexType&gt;

&lt;/schema&gt;
</PRE>

<P>

<H1><A NAME="SECTION0014000000000000000000">
About this document ...</A>
</H1>
 <strong>ZSI: The Zolera Soap Infrastructure</strong>,
February 16, 2005, Release 1.7.0
<p> This document was generated using the <a
    href="http://saftsack.fs.uni-bayreuth.de/~latex2ht/">
    <strong>LaTeX</strong>2<tt>HTML</tt></a> translator.
</p>

<p> <a
    href="http://saftsack.fs.uni-bayreuth.de/~latex2ht/">
    <strong>LaTeX</strong>2<tt>HTML</tt></a> is Copyright &copy;
  1993, 1994, 1995, 1996, 1997, <a
    href="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos
    Drakos</a>, Computer Based Learning Unit, University of
  Leeds, and Copyright &copy; 1997, 1998, <a
    href="http://www.maths.mq.edu.au/~ross/">Ross
    Moore</a>, Mathematics Department, Macquarie University,
  Sydney.
</p>

<p> The application of <a
    href="http://saftsack.fs.uni-bayreuth.de/~latex2ht/">
    <strong>LaTeX</strong>2<tt>HTML</tt></a> to the Python
  documentation has been heavily tailored by Fred L. Drake,
  Jr.  Original navigation icons were contributed by Christopher
  Petrilli.
</p>

<DIV CLASS="navigation">
<p><hr>
<table align="center" width="100%" cellpadding="0" cellspacing="2">
<tr>
<td><img src='blank.gif'
  border='0' height='32'  alt='' width='32'></td>
<td><img src='blank.gif'
  border='0' height='32'  alt='' width='32'></td>
<td><img src='blank.gif'
  border='0' height='32'  alt='' width='32'></td>
<td align="center" width="100%">ZSI: The Zolera Soap Infrastructure</td>
<td><img src='blank.gif'
  border='0' height='32'  alt='' width='32'></td>
</tr></table>
<hr>
<span class="release-info">Release 1.7.0, documentation updated on February 16, 2005.</span>
</DIV>
<!--End of Navigation Panel-->

</BODY>
</HTML>
