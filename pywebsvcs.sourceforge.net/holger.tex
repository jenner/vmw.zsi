%% LyX 1.3 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[english]{article}
\usepackage[T1]{fontenc}
\usepackage[latin1]{inputenc}
\usepackage{geometry}
\geometry{verbose,a4paper,tmargin=2cm,bmargin=2cm,lmargin=2.5cm,rmargin=2cm}
\setlength\parskip{\medskipamount}
\setlength\parindent{0pt}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\providecommand{\LyX}{L\kern-.1667em\lower.25em\hbox{Y}\kern-.125emX\@}
%% Bold symbol macro for standard LaTeX users
\newcommand{\boldsymbol}[1]{\mbox{\boldmath $#1$}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
 \newenvironment{lyxcode}
   {\begin{list}{}{
     \setlength{\rightmargin}{\leftmargin}
     \setlength{\listparindent}{0pt}% needed for AMS classes
     \raggedright
     \setlength{\itemsep}{0pt}
     \setlength{\parsep}{0pt}
     \normalfont\ttfamily}%
    \item[]}
   {\end{list}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{ae,aecompl}

\usepackage{babel}
\makeatother
\begin{document}

\title{Interoperable WSDL/SOAP web services introduction: Python ZSI, Excel XP, gSOAP C/C++
\& Applix SS}


\author{Holger Joukl\\
LBBW Financial Markets Technologies}

\maketitle
\begin{abstract}
Despite the hype \& buzzword-storm, building web services servers and clients is
still not as easy as promised. This is partly due to the relative newness of technology.
For the most part, though, this stems from the actual complexness of the protocols/specs,
the toolkit magic behind which this complexness is hidden, and the documentation
gaps that exist for the toolkits. This document is intended to be a step-by-step
tutorial/practice report, to ease the use for web services newcomers (like me). \\
It features 
\begin{itemize}
\item the Python ZSI module that is used to build the server side machinery and{\small \par}
\item several clients that access the exposed services from {\small \par}

\begin{itemize}
\item Python (ZSI){\small \par}
\item MS Excel XP (XP Web Services Toolkit 2.0, VB){\small \par}
\item C/C++ (gSOAP){\small \par}
\item Applix spreadsheets (gSOAP+ELF){\small \par}
\end{itemize}
\end{itemize}
\end{abstract}
Copyright © 2005 Holger Joukl. All rights reserved.

Redistribution and use in source (\LyX{}, \LaTeX{}) and 'compiled' forms (SGML, HTML,
PDF, PostScript, RTF and so forth) with or without modification, are permitted provided
that the following conditions are met:

\begin{enumerate}
\item Redistributions of source code (\LyX{}, \LaTeX{}) must retain the above copyright
notice, this list of conditions and the following disclaimer as the first lines of
this file unmodified.
\item Redistributions in compiled form (transformed to other DTDs, converted to PDF, PostScript,
RTF and other formats) must reproduce the above copyright notice, this list of conditions
and the following disclaimer in the documentation and/or other materials provided
with the distribution.
\end{enumerate}
THIS DOCUMENTATION IS PROVIDED \char`\"{}AS IS\char`\"{} AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
HOLDER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED
OF THE POSSIBILITY OF SUCH DAMAGE.

\pagebreak

\tableofcontents{}


\section{Introduction}

We assume the reader is familiar with Python, C/C++ and/or MS Excel/VisualBasic and/or
Applix to a certain degree. The web service server components are implemented in
Python, but any of the client side technologies can be skipped if not of interest.

While some basic concepts regarding WSDL, SOAP, HTTP servers are presented here implicitly,
this document is not a tutorial on these. If you want to know more there´s plenty
of stuff on the web.

The code examples have been developed with the primary goal to {}``make it work
at all'', in a learning-by-doing manner. Thus there is lots of room for enhancements,
e.g. getting rid of hardcoded path names etc. 

Throughout this document, certain host names ({}``dev-b.handel-dev.local'') or
ports ({}``8080'') are used in the examples- you will have to substitute those
with the appropriate setup for your site, of course. Naturally, this also affects
all URLs defined in the example WSDLs and used to retrieve these WSDLs.

These are the toolkit versions discussed here:

\begin{itemize}
\item Python 2.3.4
\item PyXML 0.8.3
\item ZSI 1.6.1
\item gcc 2.95.2, gcc 3.4.3
\item gSOAP 2.7.1
\item MS Office XP Web Services Toolkit 2.0
\end{itemize}
Conceptually, we use a WSDL-centric approach: The starting point for all example
service and client implementations will be the WSDL description. Note that this might
differ from certain toolkits that start out with the service implementation in the
host language and generate the WSDL for you to expose the implemented service. We
regard the latter to have a tendency to not promote interoperability and to tie in
implementation language details, which is certainly not what we want.%
\footnote{This came up partly due to the fact that the chosen server implementation (Python
ZSI) offers no such tool and partly as a gut feeling. Since then, this opinion has
grown stronger and has also been backed up by several practitioners´ readings at
a recent conference (Stuttgarter Softwaretechnik Forum 2005, Stuttgart-Vaihingen,
Germany).%
}

Striving for interoperability, only the WS-I-compliant rpc/literal and document/literal
WSDL styles are presented here.

The DateService WSDL (sect. \ref{sub:The-DateService-WSDL}) and worker code (sect.
\ref{sub:The-DateService-implementation}) and the Applix/ELF macro code (sect. \ref{sub:Applix-client-implementation})
are courtesy of Rainer Kluger (LBBW Financial Markets Technologies).


\section{Interlude: ZSI 1.6.1 code modifications}

The Python server and client side implementations are based on the ZSI 1.6.1 module.%
\footnote{The attempt has been made to move everything on to ZSI 1.7, but unfortunately the
first try on the FinancialService resulted in a \texttt{wsdl2py} error (SF Tracker
\# 1241503), so this has been put off for the moment.%
} Some modifications had to be made in order to get everything to work. This might
not be necessary for newer versions of ZSI, so it´s well worth trying to create or
access your services \emph{without} modifying the ZSI code base.

If needed, the necessary patches to ZSI 1.6.1 for the following example services
can be found in addendum \ref{sec:ZSI-1.6.1-patches}.


\section{Simple datatypes: The rpc/literal SquareService}

This first example will implement an overly simple service that exposes a function
which takes a \texttt{double} argument and returns the square of it ($x{}^{\textrm{2}}$)
as a \texttt{double}. I.e. this examples uses simple scalar datatypes, one single
argument and one single return value.


\subsection{The SquareService WSDL}

This is the WSDL file that determines the contract for the SquareService, called
\texttt{SquareService.wsdl}:

\begin{lyxcode}
<?xml~version=\char`\"{}1.0\char`\"{}?>



<definitions~name=\char`\"{}SquareService\char`\"{}~

~targetNamespace=\char`\"{}http://dev-b.handel-dev.local:8080/SquareService\char`\"{}~~

~xmlns:tns=\char`\"{}http://dev-b.handel-dev.local:8080/SquareService\char`\"{}~~~

~xmlns:xsd=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}~

~xmlns:soap=\char`\"{}http://schemas.xmlsoap.org/wsdl/soap/\char`\"{}~

~xmlns=\char`\"{}http://schemas.xmlsoap.org/wsdl/\char`\"{}>



~~~~<message~name=\char`\"{}getSquareRequest\char`\"{}>

~~~~~~~~<part~name=\char`\"{}x\char`\"{}~type=\char`\"{}xsd:double\char`\"{}/>

~~~~</message>

~~~~<message~name=\char`\"{}getSquareResponse\char`\"{}>

~~~~~~~~<part~name=\char`\"{}return\char`\"{}~type=\char`\"{}xsd:double\char`\"{}/>

~~~~</message>



~~~~<portType~name=\char`\"{}SquarePortType\char`\"{}>

~~~~~~~~<operation~name=\char`\"{}getSquare\char`\"{}>

~~~~~~~~~~~~<documentation>~the~square~method~</documentation>

~~~~~~~~~~~~<input~message=\char`\"{}tns:getSquareRequest\char`\"{}/>

~~~~~~~~~~~~<output~message=\char`\"{}tns:getSquareResponse\char`\"{}/>

~~~~~~~~</operation>

~~~~</portType>



~~~~<binding~name=\char`\"{}SquareBinding\char`\"{}~type=\char`\"{}tns:SquarePortType\char`\"{}>

~~~~~~~~<soap:binding~style=\char`\"{}rpc\char`\"{}~transport=\char`\"{}http://schemas.xmlsoap.org/soap/http\char`\"{}/>

~~~~~~~~<operation~name=\char`\"{}getSquare\char`\"{}>

~~~~~~~~~~~~<soap:operation

~~~~~~~~~~~~~soapAction=\char`\"{}http://dev-b.handel-dev.local:8080/SquareService/getSquare\char`\"{}/>

~~~~~~~~~~~~<input>

~~~~~~~~~~~~~~~~<soap:body~use=\char`\"{}literal\char`\"{}~

~~~~~~~~~~~~~~~~~namespace=\char`\"{}http://dev-b.handel-dev.local:8080/SquareService\char`\"{}/>

~~~~~~~~~~~~</input>

~~~~~~~~~~~~<output>

~~~~~~~~~~~~~~~~<soap:body~use=\char`\"{}literal\char`\"{}~

~~~~~~~~~~~~~~~~~namespace=\char`\"{}http://dev-b.handel-dev.local:8080/SquareService\char`\"{}/>

~~~~~~~~~~~~</output>

~~~~~~~~</operation>

~~~~</binding>



~~~~<service~name=\char`\"{}SquareService\char`\"{}>

~~~~~~~~<documentation>Returns~x\textasciicircum{}2~(x{*}{*}2,~square(x))~for~a~given~float~x</documentation>

~~~~~~~~<port~name=\char`\"{}SquarePort\char`\"{}~binding=\char`\"{}tns:SquareBinding\char`\"{}>

~~~~~~~~~~~~<soap:address~location=\char`\"{}http://dev-b.handel-dev.local:8080/SquareService\char`\"{}/>

~~~~~~~~</port>

~~~~</service>



</definitions>




\end{lyxcode}
Comments:

\begin{itemize}
\item The \texttt{style} {}``rpc'' and the \texttt{use} {}``literal'' are used, to
be WS-I-compliant. WS-I only supports rpc/literal and document/literal.
\end{itemize}

\subsection{A Python ZSI server for the SquareService}

The Python ZSI package \cite{ZSIrefdoc} is one of two pywebsvcs packages implementing
web services for Python, namely SOAP messaging and WSDL capabilities. It is powerful
and very easy to get started with, but lacks some documentation enhancements when
it comes to WSDL-driven service generation. While the tools to do that are already
there, documentation is sparse and examples are hard to find. We hope to close the
gap a bit in the next section.

All examples here are based on ZSI 1.6.1.


\subsubsection{Generating stubs from WSDL}

ZSI comes with two python scripts to generate code from a WSDL file:

\begin{itemize}
\item \texttt{wsdl2py} is used to generate python bindings for the service.
\item \texttt{wsdl2dispatch} generates a server frame for service dispatch where the actual
worker functions will be hooked into.
\end{itemize}
If you have installed ZSI on top of your python installation you can invoke the scripts
like this (change your installation base path according to your setup):%
\footnote{The installation base path for all examples here is /apps/pydev/.%
}

\begin{enumerate}
\item \texttt{wsdl2py}:

\begin{lyxcode}
/apps/pydev/bin/wsdl2py~-f~SquareService.wsdl
\end{lyxcode}
This will generate the file \texttt{SquareService\_services.py}.

\item \texttt{wsdl2dispatch:}

\begin{lyxcode}
/apps/pydev/bin/wsdl2dispatch~-f~SquareService.wsdl
\end{lyxcode}
This will generate the file \texttt{SquareService\_services\_server.py}.

\end{enumerate}
What do we have now? We have bindings to work with the services in python and a skeleton
for dispatching to the actual worker methods. What we

still need is 

\begin{itemize}
\item the main program that runs a (HTTP-) server with a request handler for the services
and
\item the hooks to invoke the worker methods.
\end{itemize}
Luckily, ZSI includes the ZSI.ServiceContainer module which implements the server
for us. 


\subsubsection{Writing the SquareService web server\label{sub:SquareService-web-server}}

This is our main program \texttt{mySquareServer.py}. It basically provides a request
handler addition, puts our service into the ServiceContainer and starts the HTTP
server on a given port:

\begin{lyxcode}
\#!~/apps/pydev/bin/python2.3



from~ZSI.ServiceContainer~import~ServiceContainer,~SOAPRequestHandler

from~SquareService\_services\_server~import~SquareService



import~os





class~MySOAPRequestHandler(SOAPRequestHandler):

~~~~\char`\"{}\char`\"{}\char`\"{}Add~a~do\_GET~method~to~return~the~WSDL~on~HTTP~GET~requests.

~~~~Please~note~that~the~path~to~the~wsdl~file~is~derived~from~what

~~~~the~HTTP~invocation~delivers~(which~is~put~into~the~self.path

~~~~attribute),~so~you~might~want~to~change~this~addressing~scheme.

~~~~\char`\"{}\char`\"{}\char`\"{}

~~~~

~~~~def~do\_GET(self):

~~~~~~~~\char`\"{}\char`\"{}\char`\"{}Return~the~WSDL~file.~We~expect~to~get~the~location~from~the

~~~~~~~~invocation~URL~(\char`\"{}path\char`\"{}).

~~~~~~~~\char`\"{}\char`\"{}\char`\"{}

~~~~~~~~wsdlfile~=~os.path.join('.',~self.path.replace('/',~\char`\"{}\char`\"{},~1)~+~\char`\"{}.wsdl\char`\"{})

~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>\,{}>~using~wsdlfile\char`\"{},~wsdlfile

~~~~~~~~wsdl~=~open(wsdlfile).read()

~~~~~~~~self.send\_xml(wsdl)





\#~Copied~from~ZSI.ServiceContainer,~extended~to~instantiate~with~a~custom

\#~request~handler

def~AsServer(port=80,~services=(),~RequestHandlerClass=SOAPRequestHandler):

~~~~'''port~-{}-

~~~~~~~services~-{}-~list~of~service~instances

~~~~'''

~~~~address~=~('',~port)

~~~~sc~=~ServiceContainer(address,~RequestHandlerClass=RequestHandlerClass)

~~~~for~service~in~services:

~~~~~~~~path~=~service.getPost()

~~~~~~~~sc.setNode(service,~path)

~~~~sc.serve\_forever()





AsServer(port=8080,~services={[}SquareService(){]},~RequestHandlerClass=MySOAPRequestHandler)
\end{lyxcode}
We wouldn´t have needed to write the custom request handler \texttt{MySOAPRequestHandler}
if not for the do\_GET method. But both Python ZSI clients using the \texttt{ServiceProxy}
class and MS VisualBasic SOAP clients expect to receive the WSDL when issueing HTTP
GET, which is actually common behaviour to get the service description (apart from
UDDI).

Similarly, the \texttt{AsServer(...)} function had to be extended to make use of
our custom request handler.


\subsubsection{Hooking-in the service implementation\label{sub:Hooking-in-the-service}}

The only thing left now is to hook the implementation of the service into the generated
server skeleton. We need to 

\begin{itemize}
\item dispatch to the correct service method,
\item feed it the arguments received via a SOAP request and 
\item set the return values for the SOAP response.
\end{itemize}
This is the implementation for the SquareService getSquare method (or operation,
in WSDL terms):

\begin{lyxcode}
from~SquareService\_services~import~{*}

from~ZSI.ServiceContainer~import~ServiceSOAPBinding



class~SquareService(ServiceSOAPBinding):

~~~~

~~~~\#~This~dictionary~is~used~to~dispatch~to~the~appropriate~method.

~~~~\#~Not~that~the~dict~key(s)~are~identical~to~the~soapAction~attributes~of~the

~~~~\#~<soap:operation~...>~field(s)~in~the~WSDL:

~~~~\#~...

~~~~\#~<soap:operation~

~~~~\#~soapAction=\char`\"{}http://dev-b.handel-dev.local:8080/SquareService/getSquare\char`\"{}/>

~~~~\#~...

~~~~\#~The~value(s)~for~the~key(s)~are~the~generated~soap\_<...>~method~names.

~~~~soapAction~=~\{

~~~~~~~~'http://dev-b.handel-dev.local:8080/SquareService/getSquare':~'soap\_getSquare',

~~~~~~~~\}

~~~~

~~~~def~\_\_init\_\_(self,~post='/SquareService',~{*}{*}kw):

~~~~~~~~ServiceSOAPBinding.\_\_init\_\_(self,~post)

~~~~

~~~~def~soap\_getSquare(self,~ps):

~~~~~~~~\#~input~vals~in~request~object

~~~~~~~~\#~MANUALLY~CORRECTED:

~~~~~~~~\#~args~=~ps.Parse(~getSquareRequestWrapper()~)

~~~~~~~~\#~Use~the~class~instead~of~an~instance~of~the~class.

~~~~~~~~\#~Note:~The~erroneous~code~generation~happens~for~rpc/literal,~but~not

~~~~~~~~\#~for~rpc/encoded,~where~using~an~instance~works~(?).

~~~~~~~~

~~~~~~~~args~=~ps.Parse(~getSquareRequestWrapper~)

~~~~~~~~

~~~~~~~~\#~assign~return~values~to~response~object

~~~~~~~~response~=~getSquareResponseWrapper()

~~~~~~~~

~~~~~~~~\#~>\,{}>\,{}>~ADDED~MANUALLY

~~~~~~~~\#~Here~we~hook~in~the~actual~worker~method

~~~~~~~~response.\_return~=~self.getSquare(args.\_x)

~~~~~~~~\#~<\,{}<\,{}<

~~~~~~~~

~~~~~~~~return~response

~~~~

~~~~\#~the~(handwritten)~worker~code

~~~~def~getSquare(self,~x):

~~~~~~~~\char`\"{}\char`\"{}\char`\"{}Return~square(x).

~~~~~~~~\char`\"{}\char`\"{}\char`\"{}

~~~~~~~~return~x{*}{*}2
\end{lyxcode}
Note that ZSI does almost all the work for us, again. The only additions we had to
make are:

\begin{itemize}
\item Implementing the \texttt{getSquare(...)} worker method. We could also have invoked
a function, used a lambda, put the worker code into \texttt{soap\_getSquare}, etc.
\item Hooking \texttt{getSquare} in. This is done in the

\begin{lyxcode}
...

\#~>\,{}>\,{}>~ADDED~MANUALLY

\#~Here~we~hook~in~the~actual~worker~method

response.\_return~=~self.getSquare(args.\_x)

\#~<\,{}<\,{}<

...
\end{lyxcode}
bits where

\begin{itemize}
\item the \texttt{x} input argument is taken from the incoming SOAP request and handed
to the \texttt{getSquare} method
\item the \texttt{return} field of the SOAP response message to be sent out is set with
the \texttt{getSquare} result
\end{itemize}
As you can see in the WSDL above the {}``getSquareRequest'' message has a {}``part''
with the name {}``x''; ZSI exposes this as attribute {}``\_x'' of the incoming
parsed SOAP request message {}``args'' instance. The same applies to the {}``return''
part of the response message. ZSI exposes this to python as attribute {}``\_return''
of the \texttt{getSquareResponseWrapper} instance.

\item Correcting the line

\begin{lyxcode}
\#~args~=~ps.Parse(~getSquareRequestWrapper()~)
\end{lyxcode}
to

\begin{lyxcode}
args~=~ps.Parse(~getSquareRequestWrapper~)
\end{lyxcode}
This seems to be a bug in the code generation.%
\footnote{When experimenting with rpc/encoded-style first, the generated code line worked {}``as
is''.%
}

\end{itemize}
Comments:

\begin{itemize}
\item The dispatch to the appropriate service operation is handled in the \texttt{soapAction}
dictionary. This dictionary maps the action that is requested to the method that
is invoked. The ZSI standard request handler (that we inherit from) takes the HTTP
header field soapAction and propagates its value to this dispatch mechanism. Thus,
everything works out-of-the-box if you use the {}``soapAction'' operation-attribute
in your WSDL file (and if your service client actually provides this header field
with its request). If you want to use different ways to dispatch (e.g. by using the
toplevel node of the incoming SOAP body) you will have to make further modifications
to the ZSI standard request handler.
\end{itemize}

\subsection{A Python ZSI client for the SquareService\label{sub:ZSI-SquareService-client}}

We implement a client that calls getSquare from the SquareService in \texttt{myServiceProxyClient.py}
as follows:

\begin{lyxcode}
\#!/apps/pydev/bin/python2.3

import~sys

import~getopt

from~ZSI~import~ServiceProxy



\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

\#~default~configuration

\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

port~=~8080

host~=~'dev-b'





\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

\#~command~line~parsing

\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

def~usage(rcode=1):

~~~~print~\char`\"{}usage:~myServiceProxyClient.py~{[}-{}-host=<hostname>~-{}-port=,-c<port>~-{}-help,~-h{]}\char`\"{}

~~~~sys.exit(rcode)

try:

~~~~optlist,~args~=~getopt.getopt(sys.argv{[}1:{]},~\char`\"{}hp:\char`\"{},~{[}'help',~'port='{]})

except~getopt.GetoptError:

~~~~usage()

for~opt,~arg~in~optlist:

~~~~print~opt,~arg

~~~~if~opt~in~{[}\char`\"{}-h\char`\"{},~\char`\"{}-{}-help\char`\"{}{]}:

~~~~~~~~usage(0)

~~~~elif~opt~in~{[}\char`\"{}-{}-host\char`\"{}{]}:

~~~~~~~~host~=~arg

~~~~~~~~continue

~~~~elif~opt~in~{[}\char`\"{}-p\char`\"{},~\char`\"{}-{}-port\char`\"{}{]}:

~~~~~~~~port~=~int(arg)

~~~~~~~~continue



\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

\#~Service~client~code

\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

~~~~

url~=~'http://'~+~host~+~':'~+~str(port)~+~'/SquareService'



\#~Hmm,~if~we~want~to~send~to~the~correct~service~location~we

\#~must~set~use\_wsdl.

service~=~ServiceProxy(url,~use\_wsdl=True,~tracefile=sys.stdout)



print~'service~is',~service

print~service.\_\_dict\_\_

print~'\textbackslash{}nAccessing~service~getSquare...'

while~1:

~~~~\#~Must~use~keyword~arguments~if~use\_wsdl~was~set

~~~~x~=~float(raw\_input(\char`\"{}Enter~number:~\char`\"{}))

~~~~result~=~service.getSquare(x=x)

~~~~print~'result:',~result
\end{lyxcode}
This is pretty straightforward. Most of the code handles the command line stuff which
has nothing to do with web services in the first place. The only thing we actually
have to do is to create a \texttt{ServiceProxy} instance with the service URL and
tell it to use the WSDL (which it gets from a HTTP GET request). We can then simply
access the getSquare method; only make sure you give its argument as a keyword argument.

Note that this client does not even use the generated stub code: Everything is accessed
through the \texttt{ServiceProxy} object that gets all necessary information from
the WSDL. 

This is the output of an example client run:

\begin{lyxcode}
\$~./myServiceProxyClient.py

service~is~<ZSI.ServiceProxy.ServiceProxy~instance~at~0x18dbe8>

\{'\_wsdl':~<ZSI.wstools.WSDLTools.WSDL~instance~at~0x192350>,~

'getSquare':~<ZSI.ServiceProxy.MethodProxy~instance~at~0x48d698>,~

'\_typesmodule':~None,~'\_soapAction':~None,~'\_use\_wsdl':~True,~

'\_ns':~None,~

'\_tracefile':~<open~file~'<stdout>',~mode~'w'~at~0x128060>,~

'\_op\_ns':~None,~'\_name':~u'SquareService',~'\_nsdict':~\{\},~

'\_port':~<ZSI.wstools.WSDLTools.Port~instance~at~0x48d5d0>,~

'\_service':~<ZSI.wstools.WSDLTools.Service~instance~at~0x48d580>,~

'\_\_doc\_\_':~u'Returns~x\textasciicircum{}2~(x{*}{*}2,~square(x))~for~a~given~float~x'\}

Accessing~service~getSquare...

Enter~number:~4

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_~Tue~Jul~~5~13:30:42~2005~REQUEST:

<?xml~version=\char`\"{}1.0\char`\"{}~encoding=\char`\"{}utf-8\char`\"{}?>

<SOAP-ENV:Envelope

~~xmlns:SOAP-ENV=\char`\"{}http://schemas.xmlsoap.org/soap/envelope/\char`\"{}

~~xmlns:SOAP-ENC=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}

~~xmlns:xsi=\char`\"{}http://www.w3.org/2001/XMLSchema-instance\char`\"{}

~~xmlns:xsd=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}

~~xmlns:ZSI=\char`\"{}http://www.zolera.com/schemas/ZSI/\char`\"{}

~~SOAP-ENV:encodingStyle=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}~>

<SOAP-ENV:Body>

<getSquare>

<x~xsi:type=\char`\"{}xsd:double\char`\"{}>4.000000</x>

</getSquare>

</SOAP-ENV:Body>

</SOAP-ENV:Envelope>

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_~Tue~Jul~~5~13:30:42~2005~RESPONSE:

Server:~ZSI/1.1~BaseHTTP/0.3~Python/2.3.4

Date:~Tue,~05~Jul~2005~11:30:42~GMT

Content-type:~text/xml;~charset=\char`\"{}utf-8\char`\"{}

Content-Length:~560

<?xml~version=\char`\"{}1.0\char`\"{}~encoding=\char`\"{}utf-8\char`\"{}?>

<SOAP-ENV:Envelope

~~xmlns:SOAP-ENV=\char`\"{}http://schemas.xmlsoap.org/soap/envelope/\char`\"{}

~~xmlns:SOAP-ENC=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}

~~xmlns:xsi=\char`\"{}http://www.w3.org/2001/XMLSchema-instance\char`\"{}

~~xmlns:xsd=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}

~~xmlns:ZSI=\char`\"{}http://www.zolera.com/schemas/ZSI/\char`\"{}

~~SOAP-ENV:encodingStyle=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}~>

<SOAP-ENV:Body>

<getSquareResponse~~xmlns=\char`\"{}\char`\"{}>

<return~xsi:type=\char`\"{}xsd:double\char`\"{}>16.000000

</return>

</getSquareResponse~>

</SOAP-ENV:Body>

</SOAP-ENV:Envelope>

result:~\{u'return':~16.0\}

Enter~number:
\end{lyxcode}

\subsection{An Excel XP Visual Basic client for the SquareService}


\subsubsection{VB stub generation\label{sub:VB-stub-generation-square}}

To generate the stub code you use the Web Service References Tool:

\begin{enumerate}
\item Open the VB Editor (Alt-F11).
\item Read the WSDL:

\begin{enumerate}
\item Tools-->Web Services References...
\item Click {}``Web Service URL'' and enter the web service´s URL. In our example this
is {}``http://dev-b.handel-dev.local:8080/SquareService'' (same as the <soap:address
location=''...''/> in the WSDL). %
\footnote{Note that the server name and port is not sufficient for our server implementation
as we use the RequestHandler path attribute to find the appropriate WSDL file to
serve.%
}Click {}``Search'' (the server must be running, of course). You should see the
SquareService with its single exposed method in the Search Results field now.
\item Activate the SquareService´s checkbox and press {}``Add''. The stub code is being
generated.
\end{enumerate}
\end{enumerate}

\subsubsection{VB client code \& spreadsheet access}

To access the web service, we need to manually write VB functions/sub procedures.%
\footnote{Not quite sure about the terminology here - this has been the first exposure to VB.
Consult your local VB guru for all VB-related questions; all code presented here
has been developed by trial-and-error.%
} For the SquareService with its trivial datatypes this is quite simple:

\begin{enumerate}
\item Insert-->Module
\item Add the module code. We implement a VB function for this purpose:

\begin{lyxcode}
Public~Function~getSquare(ByRef~x~As~Double)~As~Double

~~~~Dim~service~As~New~clsws\_SquareService

~~~~getSquare~=~service.wsm\_getSquare(x)

End~Function
\end{lyxcode}
\end{enumerate}

\paragraph{Excel spreadsheet invocation of the SquareService }

You can now use the \texttt{getSquare} function wherever a builtin function could
be used, without further ado.


\subsection{A gSOAP C++ client for the SquareService}

gSOAP is an open source web services development toolkit for C/C++. It seems to be
very mature and complete and has an impressive record of being used in real-world
applications by major companies. It also features good documentation.


\subsubsection{Generation from WSDL}

With our SquareService server running, we can generate the client stubs:

\begin{enumerate}
\item First, gSOAP needs a header file for the service that is create with the \texttt{wsdl2h}
generator:

\begin{lyxcode}
/apps/pydev/bin/wsdl2h~-o~squareService.h~

http://dev-b.handel-dev.local:8080/SquareService
\end{lyxcode}
Just specify the name for the header file and the URL where the WSDL can be received
with a HTTP GET request. The \texttt{squareService.h} header will be created:

\begin{lyxcode}
{*}{*}~The~gSOAP~WSDL~parser~for~C~and~C++~1.2.0

{*}{*}~Copyright~(C)~2000-2005~Robert~van~Engelen,~Genivia~Inc.

{*}{*}~All~Rights~Reserved.~This~product~is~provided~\char`\"{}as~is\char`\"{},~without~any~warranty.

{*}{*}~The~gSOAP~WSDL~parser~is~released~under~one~of~the~following~two~licenses:

{*}{*}~GPL~or~the~commercial~license~by~Genivia~Inc.~Use~option~-l~for~more~info.

Saving~squareService.h

Connecting~to~'http://dev-b.handel-dev.local:8080/SquareService'~to~retrieve~WSDL...~done

Cannot~open~file~'typemap.dat'

Problem~reading~type~map~file~typemap.dat.

Using~internal~type~definitions~for~C++~instead.

Warning:~part~'x'~uses~literal~style~and~must~refer~to~an~element~rather~than~a~type

Warning:~part~'x'~uses~literal~style~and~must~refer~to~an~element~rather~than~a~type

To~complete~the~process,~compile~with:

soapcpp2~squareService.h~

\$~ls~-l

total~6

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~~5411~Jul~~5~10:54~squareService.h
\end{lyxcode}
Note that gSOAP tells us about what it thinks might cause problems in our WSDL; we
ignore that for this example.

\item Next we let gSOAP create the stub code for us, using the newly-created header:

\begin{lyxcode}
\$~/apps/pydev/bin/soapcpp2~-I~/data/pydev/DOWNLOADS/gsoap-2.7/soapcpp2~~squareService.h

{*}{*}~~The~gSOAP~Stub~and~Skeleton~Compiler~for~C~and~C++~2.7.1

{*}{*}~~Copyright~(C)~2000-2005,~Robert~van~Engelen,~Genivia~Inc.

{*}{*}~~All~Rights~Reserved.~This~product~is~provided~\char`\"{}as~is\char`\"{},~without~any~warranty.

{*}{*}~~The~gSOAP~compiler~is~released~under~one~of~the~following~three~licenses:

{*}{*}~~GPL,~the~gSOAP~public~license,~or~the~commercial~license~by~Genivia~Inc.

Saving~soapStub.h

Saving~soapH.h

Saving~soapC.cpp

Saving~soapClient.cpp

Saving~soapServer.cpp

Saving~soapClientLib.cpp

Saving~soapServerLib.cpp

Using~ns1~service~name:~SquareBinding

Using~ns1~service~style:~document

Using~ns1~service~encoding:~literal

Using~ns1~service~location:~http://dev-b.handel-dev.local:8080/SquareService

Using~ns1~schema~namespace:~http://dev-b.handel-dev.local:8080/SquareService

Saving~soapSquareBindingProxy.h~client~proxy

Saving~soapSquareBindingObject.h~server~object

Saving~SquareBinding.getSquare.req.xml~sample~SOAP/XML~request

Saving~SquareBinding.getSquare.res.xml~sample~SOAP/XML~response

Saving~SquareBinding.nsmap~namespace~mapping~table

Compilation~successful
\end{lyxcode}
We must explicitly give the \texttt{gSOAP/soapcpp2} directory as include directory.
This is not being installed with the gSOAP installation (in the {}``make install''
step) but resides in the path where you extracted the gSOAP tarball. It contains
some special header files gSOAP does not install on your system. 

You might have noticed that \texttt{soapcpp2} says it is using service style {}``document''
as opposed to what´s defined in the WSDL ({}``rpc''); this seems to be a cosmetic
issue only and does not affect the usability of the generated code.

The above command produces the following client stubs (server skeleton code also
by the way, but we will not use it here):

\end{enumerate}
\begin{lyxcode}
\$~ls~-l
\begin{lyxcode}
total~407

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~~~449~Jul~~5~13:01~SquareBinding.getSquare.req.xml

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~~~475~Jul~~5~13:01~SquareBinding.getSquare.res.xml

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~~~561~Jul~~5~13:01~SquareBinding.nsmap

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~40483~Jul~~5~13:01~soapC.cpp

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~~2450~Jul~~5~13:01~soapClient.cpp

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~~~464~Jul~~5~13:01~soapClientLib.cpp

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~10935~Jul~~5~13:01~soapH.h

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~~2846~Jul~~5~13:01~soapServer.cpp

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~~~464~Jul~~5~13:01~soapServerLib.cpp

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~~1258~Jul~~5~13:01~soapSquareBindingObject.h

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~~1507~Jul~~5~13:01~soapSquareBindingProxy.h

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~~5206~Jul~~5~13:01~soapStub.h

-rw-r-{}-r-{}-~~~1~hjoukl~~~intern~~~~~~~5411~Jul~~5~10:54~squareService.h
\end{lyxcode}
\end{lyxcode}
What´s left now is to implement the client program and make use of the generated
code. 


\subsubsection{Client implementation\label{sub:gsoap-square-client}}

This is a sample client to access the SquareService:

\begin{lyxcode}
\$~cat~myCSquareClient.cpp

\#include~\char`\"{}soapH.h\char`\"{}

\#include~\char`\"{}SquareBinding.nsmap\char`\"{}

\#include~<iostream>

int~main(void)

\{

~~~~struct~soap~soap;

~~~~double~x~=~0;

~~~~double~square~=~0;

~~~~soap\_init(\&soap);

~~~~while~(1)~\{

~~~~~~~~std::cout~<\,{}<~\char`\"{}Enter~x~value:~\char`\"{};

~~~~~~~~std::cin~>\,{}>~x;

~~~~~~~~if~(soap\_call\_ns1\_\_getSquare(\&soap,~NULL,~NULL,~x,~square)~==~SOAP\_OK)~\{

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}Result:~\char`\"{}~<\,{}<~square~<\,{}<~std::endl;

~~~~~~~~\}~else~\{

~~~~~~~~~~~~soap\_print\_fault(\&soap,~stderr);

~~~~~~~~\}

~~~~\}

~~~~soap\_destroy(\&soap);

~~~~soap\_end(\&soap);

~~~~soap\_done(\&soap);

~~~~return~0;

\}
\end{lyxcode}
There are also other ways to invoke this service with the gSOAP mechanisms, namely
the \texttt{SquareBinding} class defined in \texttt{SquareServiceBindingProxy.h},
which would take care of the initialization \& destruction activities needed in the
above client code. We will use this (better) approach in the next examples.


\subsubsection{gSOAP client compilation }


\paragraph{gcc 2.95.2}

\begin{lyxcode}
\$~g++~-o~myCSquareClient~-R/apps/prod/lib~-I/apps/pydev/include~

-L/apps/pydev/lib~soapC.cpp~soapClient.cpp~myCSquareClient.cpp~-lgsoap++~-lsocket
\end{lyxcode}

\paragraph{gcc 3.4.3}

Note: Compiling with gcc 3.4.3, the nsl library had to be added to the linked libraries: 

\begin{lyxcode}
/apps/local/gcc/3.4.3/bin/g++~-o~myCSquareClient~-R/apps/pydev/gcc/3.4.3/lib

-I/apps/pydev/gcc/3.4.3/include~-L/apps/pydev/gcc/3.4.3/lib~soapC.cpp~

soapClient.cpp~myCSquareClient.cpp~-lgsoap++~-lsocket~-lnsl
\end{lyxcode}

\section{Strucured datatypes: The rpc/literal DateService}

Let´s move on to a more elaborate service, elaborate in the sense of using structured
datatypes now (not that the service example itself was particularly ingenious). Anyway,
we will now implement the DateService service that exposes two methods:

\begin{itemize}
\item <date structure> getCurrentDate(<string>) takes a string argument and returns the
current date as a datetime structure
\item <date structure> getDate(<int>, <date structure>) takes an integer offset and a date
structure as arguments and returns the given date plus the offset (in days) as a
date structure
\end{itemize}

\subsection{The DateService WSDL\label{sub:The-DateService-WSDL}}

The DateService is described in \texttt{DateService.wsdl}:

\begin{lyxcode}
<?xml~version=\char`\"{}1.0\char`\"{}?>

<definitions~name=\char`\"{}DateService\char`\"{}

~~targetNamespace=\char`\"{}http://dev-b.handel-dev.local:8080/DateService.wsdl\char`\"{}

~~xmlns:tns=\char`\"{}http://dev-b.handel-dev.local:8080/DateService.wsdl\char`\"{}

~~xmlns=\char`\"{}http://schemas.xmlsoap.org/wsdl/\char`\"{}

~~xmlns:soap=\char`\"{}http://schemas.xmlsoap.org/wsdl/soap/\char`\"{}

~~xmlns:myType=\char`\"{}DateType\_NS\char`\"{}

~~xmlns:xsd=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}

~~xmlns:wsdl=\char`\"{}http://schemas.xmlsoap.org/wsdl/\char`\"{}>

~~<types>

~~~~<schema~xmlns=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}

~~~~~~targetNamespace=\char`\"{}DateType\_NS\char`\"{}~>

~~~~~~<complexType~name=\char`\"{}Date\char`\"{}>

~~~~~~~~~~~~<sequence>

~~~~~~~~~~~~~~<element~name=\char`\"{}year\char`\"{}~nillable=\char`\"{}true\char`\"{}~type=\char`\"{}xsd:integer\char`\"{}/>

~~~~~~~~~~~~~~<element~name=\char`\"{}month\char`\"{}~nillable=\char`\"{}true\char`\"{}~type=\char`\"{}xsd:integer\char`\"{}/>

~~~~~~~~~~~~~~<element~name=\char`\"{}day\char`\"{}~nillable=\char`\"{}true\char`\"{}~type=\char`\"{}xsd:integer\char`\"{}/>

~~~~~~~~~~~~~~<element~name=\char`\"{}hour\char`\"{}~nillable=\char`\"{}true\char`\"{}~type=\char`\"{}xsd:integer\char`\"{}/>

~~~~~~~~~~~~~~<element~name=\char`\"{}minute\char`\"{}~nillable=\char`\"{}true\char`\"{}~type=\char`\"{}xsd:integer\char`\"{}/>

~~~~~~~~~~~~~~<element~name=\char`\"{}second\char`\"{}~nillable=\char`\"{}true\char`\"{}~type=\char`\"{}xsd:integer\char`\"{}/>

~~~~~~~~~~~~~~<element~name=\char`\"{}weekday\char`\"{}~nillable=\char`\"{}true\char`\"{}~type=\char`\"{}xsd:integer\char`\"{}/>

~~~~~~~~~~~~~~<element~name=\char`\"{}dayOfYear\char`\"{}~nillable=\char`\"{}true\char`\"{}~type=\char`\"{}xsd:integer\char`\"{}/>

~~~~~~~~~~~~~~<element~name=\char`\"{}dst\char`\"{}~nillable=\char`\"{}true\char`\"{}~type=\char`\"{}xsd:integer\char`\"{}/>

~~~~~~~~~~~~</sequence>

~~~~~~</complexType>~~

~~~~</schema>

~~</types>

~~<message~name=\char`\"{}getCurrentDateRequest\char`\"{}>

~~~~<part~name=\char`\"{}input\char`\"{}~type=\char`\"{}xsd:string\char`\"{}/>

~~</message>

~~<message~name=\char`\"{}getCurrentDateResponse\char`\"{}>

~~~~<part~name=\char`\"{}today\char`\"{}~type=\char`\"{}myType:Date\char`\"{}/>

~~</message>

~~<message~name=\char`\"{}getDateRequest\char`\"{}>

~~~~<part~name=\char`\"{}offset\char`\"{}~type=\char`\"{}xsd:integer\char`\"{}/>

~~~~<part~name=\char`\"{}someday\char`\"{}~type=\char`\"{}myType:Date\char`\"{}/>

~~</message>

~~<message~name=\char`\"{}getDateResponse\char`\"{}>

~~~~<part~name=\char`\"{}day\char`\"{}~type=\char`\"{}myType:Date\char`\"{}/>

~~</message>

~~<portType~name=\char`\"{}DateService\_PortType\char`\"{}>

~~~~<operation~name=\char`\"{}getCurrentDate\char`\"{}>

~~~~~~<input~message=\char`\"{}tns:getCurrentDateRequest\char`\"{}/>

~~~~~~<output~message=\char`\"{}tns:getCurrentDateResponse\char`\"{}/>

~~~~</operation>

~~~~<operation~name=\char`\"{}getDate\char`\"{}>

~~~~~~<input~message=\char`\"{}tns:getDateRequest\char`\"{}/>

~~~~~~<output~message=\char`\"{}tns:getDateResponse\char`\"{}/>

~~~~</operation>

~~</portType>

~~<binding~name=\char`\"{}DateService\_Binding\char`\"{}~type=\char`\"{}tns:DateService\_PortType\char`\"{}>

~~~~<soap:binding~style=\char`\"{}rpc\char`\"{}~transport=\char`\"{}http://schemas.xmlsoap.org/soap/http\char`\"{}/>

~~~~<operation~name=\char`\"{}getCurrentDate\char`\"{}>

~~~~~~<soap:operation~soapAction=\char`\"{}urn:DateService.wsdl\#getCurrentDate\char`\"{}/>

~~~~~~<input>

~~~~~~~~<soap:body~use=\char`\"{}literal\char`\"{}~namespace=\char`\"{}urn:DateService.wsdl\char`\"{}/>

~~~~~~</input>

~~~~~~<output>

~~~~~~~~<soap:body~use=\char`\"{}literal\char`\"{}~namespace=\char`\"{}urn:DateService.wsdl\char`\"{}/>

~~~~~~</output>

~~~~</operation>

~~~~<operation~name=\char`\"{}getDate\char`\"{}>

~~~~~~<soap:operation~soapAction=\char`\"{}urn:DateService.wsdl\#getDate\char`\"{}/>

~~~~~~<input>

~~~~~~~~<soap:body~parts=\char`\"{}offset~someday\char`\"{}~use=\char`\"{}literal\char`\"{}~namespace=\char`\"{}urn:DateService.wsdl\char`\"{}/>

~~~~~~</input>

~~~~~~<output>

~~~~~~~~<soap:body~use=\char`\"{}literal\char`\"{}~namespace=\char`\"{}urn:DateService.wsdl\char`\"{}/>

~~~~~~</output>

~~~~</operation>

~~</binding>

~~<service~name=\char`\"{}simple~Date~Service\char`\"{}>

~~~~<documentation>Date~Web~Service</documentation>

~~~~<port~name=\char`\"{}DateService\_Port\char`\"{}~binding=\char`\"{}tns:DateService\_Binding\char`\"{}>

~~~~~~<soap:address~location=\char`\"{}http://dev-b.handel-dev.local:8080/DateService\char`\"{}/>

~~~~</port>

~~</service>

</definitions>
\end{lyxcode}
Comments:

\begin{itemize}
\item Again, rpc/literal has been chosen.
\item A ComplexType {}``Date'' is defined in the <types> section. This type is being
used as a return type (getCurrentDate, getDate) and as a method argument type (getDate).
\end{itemize}

\subsection{A Python ZSI DateService server}

The tasks at hand are the same as for the SquareService example.


\subsubsection{Code generation from WSDL}

\begin{enumerate}
\item \texttt{wsdl2py}:

\begin{lyxcode}
\$~/apps/pydev/bin/wsdl2py~-f~DateService.wsdl

==>~DateService\_services.py

==>~DateService\_services\_types.py
\end{lyxcode}
\item \texttt{wsdl2dispatch:}

\begin{lyxcode}
/apps/pydev/bin/wsdl2dispatch~-f~DateService.wsdl

==>~DateService\_services\_server.py
\end{lyxcode}
\end{enumerate}

\subsubsection{The DateService web server}

The server implementation is exactly the same as in section \ref{sub:SquareService-web-server},
with the only difference of putting a DateService instance into the ServiceContainer
now:

\begin{lyxcode}
\#!~/apps/pydev/bin/python2.3



from~ZSI.ServiceContainer~import~ServiceContainer,~SOAPRequestHandler

from~DateService\_services\_server~import~DateService

import~os



class~MySOAPRequestHandler(SOAPRequestHandler):

~~~~\char`\"{}\char`\"{}\char`\"{}Add~a~do\_GET~method~to~return~the~WSDL~on~HTTP~GET~requests.

~~~~Please~note~that~the~path~to~the~wsdl~file~is~derived~from~what

~~~~the~HTTP~invocation~delivers~(which~is~put~into~the~self.path

~~~~attribute),~so~you~might~want~to~change~this~addressing~scheme.

~~~~\char`\"{}\char`\"{}\char`\"{}

~~~~

~~~~def~do\_GET(self):

~~~~~~~~\char`\"{}\char`\"{}\char`\"{}Return~the~WSDL~file.~We~expect~to~get~the~location~from~the

~~~~~~~~invocation~URL~(\char`\"{}path\char`\"{}).

~~~~~~~~\char`\"{}\char`\"{}\char`\"{}

~~~~~~~~wsdlfile~=~os.path.join('.',~self.path.replace('/',~\char`\"{}\char`\"{},~1)~+~\char`\"{}.wsdl\char`\"{})

~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>\,{}>~using~wsdlfile\char`\"{},~wsdlfile

~~~~~~~~wsdl~=~open(wsdlfile).read()

~~~~~~~~self.send\_xml(wsdl)



\#~Copied~from~ZSI.ServiceContainer,~extended~to~instantiate~with~a~custom

\#~request~handler

def~AsServer(port=80,~services=(),~RequestHandlerClass=SOAPRequestHandler):

~~~~'''port~-{}-

~~~~~~~services~-{}-~list~of~service~instances

~~~~'''

~~~~address~=~('',~port)

~~~~sc~=~ServiceContainer(address,~RequestHandlerClass=RequestHandlerClass)

~~~~for~service~in~services:

~~~~~~~~path~=~service.getPost()

~~~~~~~~sc.setNode(service,~path)

~~~~sc.serve\_forever()



AsServer(port=8080,~services={[}DateService(){]},~RequestHandlerClass=MySOAPRequestHandler)
\end{lyxcode}

\subsubsection{The DateService implementation\label{sub:The-DateService-implementation}}

As in the previous example, the actual implementation must be hooked into the server
skeleton. This is done in the \texttt{DateService\_services\_server.py} file:

\begin{lyxcode}
from~DateService\_services~import~{*}

from~ZSI.ServiceContainer~import~ServiceSOAPBinding



\#~needed~for~worker~code

import~time



class~DateService(ServiceSOAPBinding):

~~~~soapAction~=~\{

~~~~~~~~'urn:DateService.wsdl\#getCurrentDate':~'soap\_getCurrentDate',

~~~~~~~~'urn:DateService.wsdl\#getDate':~'soap\_getDate',

~~~~~~~~\}



~~~~def~\_\_init\_\_(self,~post='/DateService',~{*}{*}kw):

~~~~~~~~ServiceSOAPBinding.\_\_init\_\_(self,~post)

~~~~

~~~~def~soap\_getCurrentDate(self,~ps):

~~~~~~~~\#~input~vals~in~request~object

~~~~~~~~\#~MANUALLY~CORRECTED:

~~~~~~~~\#~args~=~ps.Parse(~getCurrentDateRequestWrapper()~)

~~~~~~~~\#~Use~the~class~instead~of~an~instance~of~the~class.

~~~~~~~~\#~Note:~The~erroneous~code~generation~happens~for~rpc/literal,~but~not

~~~~~~~~\#~for~rpc/encoded,~where~using~an~instance~works~(?).

~~~~~~~~args~=~ps.Parse(~getCurrentDateRequestWrapper~)

~~~~

~~~~~~~~\#~assign~return~values~to~response~object

~~~~~~~~response~=~getCurrentDateResponseWrapper()

~~~~~~~~

~~~~~~~~\#\#~ADDED

~~~~~~~~response.\_today~=~self.getCurrentDate(args.\_input)

~~~~~~~~\#\#~END~ADDED

~~~~~~~~

~~~~~~~~return~response



~~~~def~soap\_getDate(self,~ps):

~~~~~~~~\#~input~vals~in~request~object

~~~~~~~~\#~MANUALLY~CORRECTED:

~~~~~~~~\#~args~=~ps.Parse(~getDateRequestWrapper()~)

~~~~~~~~\#~Use~the~class~instead~of~an~instance~of~the~class.

~~~~~~~~\#~Note:~The~erroneous~code~generation~happens~for~rpc/literal,~but~not

~~~~~~~~\#~for~rpc/encoded,~where~using~an~instance~works~(?).

~~~~~~~~args~=~ps.Parse(~getDateRequestWrapper~)



~~~~~~~~\#~assign~return~values~to~response~object

~~~~~~~~response~=~getDateResponseWrapper()



~~~~~~~~\#\#~ADDED

~~~~~~~~response.\_day~=~self.getDate(offset=args.\_offset,~date=args.\_someday)~~~~~~~

~~~~~~~~\#\#~END~ADDED



~~~~~~~~return~response



\#\#~ADDED~WORKER~CODE

~~~~def~getCurrentDate(self,~input=None):

~~~~~~~~dt~=~time.localtime(time.time())



~~~~~~~~class~today:

~~~~~~~~~~~~\_year~=~dt{[}0{]}

~~~~~~~~~~~~\_month~=~dt{[}1{]}

~~~~~~~~~~~~\_day~=~dt{[}2{]}

~~~~~~~~~~~~\_hour~=~dt{[}3{]}

~~~~~~~~~~~~\_minute~=~dt{[}4{]}

~~~~~~~~~~~~\_second~=~dt{[}5{]}

~~~~~~~~~~~~\_weekday~=~dt{[}6{]}

~~~~~~~~~~~~\_dayOfYear~=~dt{[}7{]}

~~~~~~~~~~~~\_dst~=~dt{[}8{]}

~~~~~~~~~~~~

~~~~~~~~return~today



~~~def~getDate(self,~offset=None,~date=None):

~~~~~~~~sec~=~3600~{*}~24~~\#\#~seconds/hour~{*}~24h

~~~~~~~~providedDate\_tuple~=~(date.\_year,~date.\_month,~date.\_day,

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~date.\_hour,~date.\_minute,~date.\_second,

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~date.\_weekday,~date.\_dayOfYear,~date.\_dst)

~~~~~~~~providedDate\_sec~=~time.mktime(providedDate\_tuple)

~~~~~~~~offset\_sec~=~sec~{*}~offset

~~~~~~~~newDate\_sec~=~providedDate\_sec~+~offset\_sec

~~~~~~~~newDate\_tuple~=~time.localtime(newDate\_sec)

~~~~~~~~if~not~offset:

~~~~~~~~~~~~offset~=~0

~~~~~~~~if~not~date:

~~~~~~~~~~~~sys.exit()

~~~~~~~~someDay~=~getDateResponse()

~~~~~~~~someDay.\_year~=~newDate\_tuple{[}0{]}

~~~~~~~~someDay.\_month~=~newDate\_tuple{[}1{]}

~~~~~~~~someDay.\_day~=~newDate\_tuple{[}2{]}~

~~~~~~~~someDay.\_hour~=~newDate\_tuple{[}3{]}

~~~~~~~~someDay.\_minute~=~newDate\_tuple{[}4{]}

~~~~~~~~someDay.\_second~=~newDate\_tuple{[}5{]}

~~~~~~~~someDay.\_weekday~=~newDate\_tuple{[}6{]}

~~~~~~~~someDay.\_dayOfYear~=~newDate\_tuple{[}7{]}

~~~~~~~~someDay.\_dst~=~newDate\_tuple{[}8{]}~~~~~~

~~~~~~~~return~someDay



\#\#~END~ADDED
\end{lyxcode}
If you take a closer look at the two method implementations, you will notice that
in \texttt{getCurrentDate(...)} the returned date is just a (nested) python class.
ZSI handles the serialization of that class into the actual SOAP message for us.%
\footnote{The python object must be structurally equivalent to the XML datatype that is defined
in the WSDL and that constitutes ZSI´s typecodes.%
}In \texttt{getDate(...)}, though, we directly use the \texttt{getDateResponse} instance
imported from the generated \texttt{DateService\_services.py}. which already is a
fully fledged ZSI-typecoded representation of the getDate response.


\subsection{A Python ZSI client for the DateService\label{sub:A-Python-ZSI-client-DateService}}


\paragraph{Using generated type mapping}

Instead of using the ServiceProxy class which dynamically fetches the WSDL description
and gets the necessary type-serialization information from it, we can use the generated
code to write a client:

\begin{lyxcode}
\#!~/apps/pydev/bin/python2.3



import~sys,~time



from~DateService\_services~import~{*}





def~main():

~~~~loc~=~simple\_Date\_ServiceLocator()

~~~~portType~=~loc.getDateService\_PortType(tracefile=sys.stdout)

~~~~while~1:

~~~~~~~~offset~=~raw\_input(\char`\"{}Enter~offset~as~int~{[}0{]}:~\char`\"{})

~~~~~~~~try:

~~~~~~~~~~~~offset~=~int(offset)

~~~~~~~~except~ValueError:

~~~~~~~~~~~~offset~=~0



~~~~~~~~x~=~getCurrentDateRequestWrapper()

~~~~~~~~x.\_input~=~'Test'

~~~~~~~~myToday~=~portType.getCurrentDate(x)



~~~~~~~~dateRequest~=~getDateRequestWrapper()

~~~~~~~~

~~~~~~~~\#~We~use~the~current~date~as~input~to~getDate

~~~~~~~~dateRequest.\_someday~=~myToday.\_today

~~~~~~~~dateRequest.\_offset~=~offset

~~~~~~~~date~=~portType.getDate(dateRequest)

~

~~~~~~~~print~'\textbackslash{}n\textbackslash{}nRESULT'

~~~~~~~~print~'\%10s~=~\%s'~\%~('today',~make\_asctime(myToday.\_today))

~~~~~~~~print~'\%6s~+~\%d~=~\%s'~\%~('today',~dateRequest.\_offset,~make\_asctime(date.\_day))





\#~just~a~helper

def~make\_asctime(date\_object):

~~~~timeTuple~=~(date\_object.\_year,~date\_object.\_month,~date\_object.\_day,

~~~~~~~~~~~~~~~~~date\_object.\_hour,~date\_object.\_minute,~date\_object.\_second,

~~~~~~~~~~~~~~~~~date\_object.\_weekday,~date\_object.\_dayOfYear,~date\_object.\_dst

~~~~~~~~~~~~~~~~~)

~~~~return~time.asctime(timeTuple)





if~\_\_name\_\_~==~'\_\_main\_\_':

~~~~main()
\end{lyxcode}
As you can see, ZSI provides us with the getCurrentDateRequestWrapper and getDateRequestWrapper
classes. These handle the serialization transparently and we use them to set the
argument values. Then, we hand them into the corresponding methods of the portType
objects the <service name>\_ServiceLocator returned.

Alternatively, we could use a ServiceProxy again:

\begin{lyxcode}
\#!/apps/pydev/bin/python2.3



import~sys

import~getopt



from~ZSI~import~ServiceProxy

import~ZSI.wstools.WSDLTools



\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

\#~default~configuration

\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

port~=~8080

host~=~'dev-b'



\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

\#~command~line~parsing

\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

def~usage(rcode=1):

~~~~print~\char`\"{}usage:~myServiceProxyClient.py~{[}-{}-host=<hostname>~-{}-port=,-c<port>~-{}-help,~-h{]}\char`\"{}

~~~~sys.exit(rcode)

try:

~~~~optlist,~args~=~getopt.getopt(sys.argv{[}1:{]},~\char`\"{}hp:\char`\"{},~{[}'help',~'port='{]})

except~getopt.GetoptError:

~~~~usage()

for~opt,~arg~in~optlist:

~~~~print~opt,~arg

~~~~if~opt~in~{[}\char`\"{}-h\char`\"{},~\char`\"{}-{}-help\char`\"{}{]}:

~~~~~~~~usage(0)

~~~~elif~opt~in~{[}\char`\"{}-{}-host\char`\"{}{]}:

~~~~~~~~host~=~arg

~~~~~~~~continue

~~~~elif~opt~in~{[}\char`\"{}-p\char`\"{},~\char`\"{}-{}-port\char`\"{}{]}:

~~~~~~~~port~=~int(arg)

~~~~~~~~continue

~~~~

url~=~'http://'~+~host~+~':'~+~str(port)~+~'/DateService'

service~=~ServiceProxy(url,~use\_wsdl=True,~tracefile=sys.stdout,

~~~~~~~~~~~~~~~~~~~~~~~ns='http://dev-b.handel-dev.local:8080/DateService')



print~'\textbackslash{}nAccessing~service~DateService,~method~getCurrentDate...'

while~1:

~~~~\#~Must~use~keyword~arguments~if~use\_wsdl~was~set

~~~~input~=~raw\_input(\char`\"{}Enter~something:~\char`\"{})

~~~~result~=~service.getCurrentDate(input=input)

~~~~print~'getCurrentDate:~result~=',~result



~~~~offset~=~int(raw\_input(\char`\"{}Enter~offset:~\char`\"{}))



\#\#~Hmm,~this~does~not~work.~Why?

\#\#~~~~class~someday:

\#\#~~~~~~~~\_year~=~result{[}'today'{]}{[}'year'{]}

\#\#~~~~~~~~\_month~=~result{[}'today'{]}{[}'month'{]}

\#\#~~~~~~~~\_day~=~result{[}'today'{]}{[}'day'{]}

\#\#~~~~~~~~\_hour~=~result{[}'today'{]}{[}'hour'{]}

\#\#~~~~~~~~\_minute~=~result{[}'today'{]}{[}'minute'{]}

\#\#~~~~~~~~\_second~=~result{[}'today'{]}{[}'second'{]}

\#\#~~~~~~~~\_weekday~=result{[}'today'{]}{[}'weekday'{]}

\#\#~~~~~~~~\_dayOfYear~=~result{[}'today'{]}{[}'dayOfYear'{]}

\#\#~~~~~~~~\_dst~=~result{[}'today'{]}{[}'dst'{]}



~~~someday~=~\{

~~~~~~~~'year':~result{[}'today'{]}{[}'year'{]},

~~~~~~~~'month':~result{[}'today'{]}{[}'month'{]},

~~~~~~~~'day':~result{[}'today'{]}{[}'day'{]},

~~~~~~~~'hour':~result{[}'today'{]}{[}'hour'{]},

~~~~~~~~'minute':~result{[}'today'{]}{[}'minute'{]},

~~~~~~~~'second':~result{[}'today'{]}{[}'second'{]},

~~~~~~~~'weekday':~result{[}'today'{]}{[}'weekday'{]},

~~~~~~~~'dayOfYear':~result{[}'today'{]}{[}'dayOfYear'{]},

~~~~~~~~'dst':~result{[}'today'{]}{[}'dst'{]},

~~~~~~~~\}



~~~print~'getDate:~result~=~',~service.getDate(offset=offset,~someday=soVmeday)
\end{lyxcode}
This is the output of a sample client sesssion of the ServiceProxy solution:

\begin{lyxcode}
\$~./myServiceProxyClient.py

service~is~<ZSI.ServiceProxy.ServiceProxy~instance~at~0x18f418>

\{'\_wsdl':~<ZSI.wstools.WSDLTools.WSDL~instance~at~0x18f648>,~

'\_typesmodule':~None,~

'\_soapAction':~None,~'\_use\_wsdl':~True,~

'\_ns':~'http://dev-b.handel-dev.local:8080/DateService',~

'\_tracefile':~<open~file~'<stdout>',~mode~'w'~at~0x128060>,~

'\_op\_ns':~None,~

'\_name':~u'simple~Date~Service',~'\_nsdict':~\{\},~

'getCurrentDate':~<ZSI.ServiceProxy.MethodProxy~instance~at~0x495f58>,~

'\_port':~<ZSI.wstools.WSDLTools.Port~instance~at~0x495eb8>,~

'\_service':~<ZSI.wstools.WSDLTools.Service~instance~at~0x495e40>,~

'\_\_doc\_\_':~u'Date~Web~Service',~

'getDate':~<ZSI.ServiceProxy.MethodProxy~instance~at~0x49e058>\}

Accessing~service~DateService,~method~getCurrentDate...

Enter~something:

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_~Tue~Jul~19~09:08:51~2005~REQUEST:

<?xml~version=\char`\"{}1.0\char`\"{}~encoding=\char`\"{}utf-8\char`\"{}?>

<SOAP-ENV:Envelope

~~xmlns:SOAP-ENV=\char`\"{}http://schemas.xmlsoap.org/soap/envelope/\char`\"{}

~~xmlns:SOAP-ENC=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}

~~xmlns:xsi=\char`\"{}http://www.w3.org/2001/XMLSchema-instance\char`\"{}

~~xmlns:xsd=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}

~~xmlns:ZSI=\char`\"{}http://www.zolera.com/schemas/ZSI/\char`\"{}

~~xmlns=\char`\"{}http://dev-b.handel-dev.local:8080/DateService\char`\"{}

~~SOAP-ENV:encodingStyle=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}~>

<SOAP-ENV:Body>

<getCurrentDate>

<input~id=\char`\"{}124038\char`\"{}~xsi:type=\char`\"{}xsd:string\char`\"{}></input>

</getCurrentDate>

</SOAP-ENV:Body>

</SOAP-ENV:Envelope>

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_~Tue~Jul~19~09:08:53~2005~RESPONSE:

Server:~ZSI/1.1~BaseHTTP/0.3~Python/2.3.4

Date:~Tue,~19~Jul~2005~07:08:53~GMT

Content-type:~text/xml;~charset=\char`\"{}utf-8\char`\"{}

Content-Length:~955

<?xml~version=\char`\"{}1.0\char`\"{}~encoding=\char`\"{}utf-8\char`\"{}?>

<SOAP-ENV:Envelope

~~xmlns:SOAP-ENV=\char`\"{}http://schemas.xmlsoap.org/soap/envelope/\char`\"{}

~~xmlns:SOAP-ENC=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}

~~xmlns:xsi=\char`\"{}http://www.w3.org/2001/XMLSchema-instance\char`\"{}

~~xmlns:xsd=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}

~~xmlns:ZSI=\char`\"{}http://www.zolera.com/schemas/ZSI/\char`\"{}

~~SOAP-ENV:encodingStyle=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}~>

<SOAP-ENV:Body>

<getCurrentDateResponse~xmlns=\char`\"{}urn:DateService.wsdl\char`\"{}>

<today~xmlns=\char`\"{}urn:DateService.wsdl\char`\"{}>

<year~xsi:type=\char`\"{}xsd:integer\char`\"{}>2005</year>

<month~xsi:type=\char`\"{}xsd:integer\char`\"{}>7</month>

<day~xsi:type=\char`\"{}xsd:integer\char`\"{}>19</day>

<hour~xsi:type=\char`\"{}xsd:integer\char`\"{}>9</hour>

<minute~xsi:type=\char`\"{}xsd:integer\char`\"{}>8</minute>

<second~xsi:type=\char`\"{}xsd:integer\char`\"{}>53</second>

<weekday~xsi:type=\char`\"{}xsd:integer\char`\"{}>1</weekday>

<dayOfYear~xsi:type=\char`\"{}xsd:integer\char`\"{}>200</dayOfYear>

<dst~xsi:type=\char`\"{}xsd:integer\char`\"{}>1</dst>

</today>

</getCurrentDateResponse>

</SOAP-ENV:Body>

</SOAP-ENV:Envelope>

getCurrentDate:~result~=~\{u'today':~\{u'hour':~9,~u'dst':~1,~u'month':~7,~u'second':~53,

u'dayOfYear':~200,~u'weekday':~1,~u'year':~2005,~u'day':~19,~u'minute':~8\}\}

Enter~offset:~9

getDate:~result~=~~\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_~Tue~Jul~19~09:11:51~2005~REQUEST:

<?xml~version=\char`\"{}1.0\char`\"{}~encoding=\char`\"{}utf-8\char`\"{}?>

<SOAP-ENV:Envelope

~~xmlns:SOAP-ENV=\char`\"{}http://schemas.xmlsoap.org/soap/envelope/\char`\"{}

~~xmlns:SOAP-ENC=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}

~~xmlns:xsi=\char`\"{}http://www.w3.org/2001/XMLSchema-instance\char`\"{}

~~xmlns:xsd=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}

~~xmlns:ZSI=\char`\"{}http://www.zolera.com/schemas/ZSI/\char`\"{}

~~xmlns=\char`\"{}http://dev-b.handel-dev.local:8080/DateService\char`\"{}

~~SOAP-ENV:encodingStyle=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}~>

<SOAP-ENV:Body>

<getDate>

<offset~xsi:type=\char`\"{}xsd:integer\char`\"{}>9</offset>

<someday>

<year~xsi:type=\char`\"{}xsd:integer\char`\"{}>2005</year>

<month~xsi:type=\char`\"{}xsd:integer\char`\"{}>7</month>

<day~xsi:type=\char`\"{}xsd:integer\char`\"{}>19</day>

<hour~xsi:type=\char`\"{}xsd:integer\char`\"{}>9</hour>

<minute~xsi:type=\char`\"{}xsd:integer\char`\"{}>8</minute>

<second~xsi:type=\char`\"{}xsd:integer\char`\"{}>53</second>

<weekday~xsi:type=\char`\"{}xsd:integer\char`\"{}>1</weekday>

<dayOfYear~xsi:type=\char`\"{}xsd:integer\char`\"{}>200</dayOfYear>

<dst~xsi:type=\char`\"{}xsd:integer\char`\"{}>1</dst>

</someday>

</getDate>

</SOAP-ENV:Body>

</SOAP-ENV:Envelope>

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_~Tue~Jul~19~09:11:52~2005~RESPONSE:

Server:~ZSI/1.1~BaseHTTP/0.3~Python/2.3.4

Date:~Tue,~19~Jul~2005~07:11:52~GMT

Content-type:~text/xml;~charset=\char`\"{}utf-8\char`\"{}

Content-Length:~937

<?xml~version=\char`\"{}1.0\char`\"{}~encoding=\char`\"{}utf-8\char`\"{}?>

<SOAP-ENV:Envelope

~~xmlns:SOAP-ENV=\char`\"{}http://schemas.xmlsoap.org/soap/envelope/\char`\"{}

~~xmlns:SOAP-ENC=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}

~~xmlns:xsi=\char`\"{}http://www.w3.org/2001/XMLSchema-instance\char`\"{}

~~xmlns:xsd=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}

~~xmlns:ZSI=\char`\"{}http://www.zolera.com/schemas/ZSI/\char`\"{}

~~SOAP-ENV:encodingStyle=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}~>

<SOAP-ENV:Body>

<getDateResponse~xmlns=\char`\"{}urn:DateService.wsdl\char`\"{}>

<day~xmlns=\char`\"{}urn:DateService.wsdl\char`\"{}>

<year~xsi:type=\char`\"{}xsd:integer\char`\"{}>2005</year>

<month~xsi:type=\char`\"{}xsd:integer\char`\"{}>7</month>

<day~xsi:type=\char`\"{}xsd:integer\char`\"{}>28</day>

<hour~xsi:type=\char`\"{}xsd:integer\char`\"{}>9</hour>

<minute~xsi:type=\char`\"{}xsd:integer\char`\"{}>8</minute>

<second~xsi:type=\char`\"{}xsd:integer\char`\"{}>53</second>

<weekday~xsi:type=\char`\"{}xsd:integer\char`\"{}>3</weekday>

<dayOfYear~xsi:type=\char`\"{}xsd:integer\char`\"{}>209</dayOfYear>

<dst~xsi:type=\char`\"{}xsd:integer\char`\"{}>1</dst>

</day>

</getDateResponse>

</SOAP-ENV:Body>

</SOAP-ENV:Envelope>

\{u'day':~\{u'hour':~9,~u'dst':~1,~u'month':~7,~u'second':~53,~u'dayOfYear':~209,~

u'weekday':~3,~u'year':~2005,~u'day':~28,~u'minute':~8\}\}
\end{lyxcode}

\subsection{An Excel XP Visual Basic client for the DateService}


\subsubsection{VB stub generation}

Refer to \ref{sub:VB-stub-generation-square} for details. The URL to receive the
WSDL file is {}``http://dev-b.handel-dev.local:8080/DateService'' in our example.

The Web Services References toolkit creates the class \texttt{clsws\_simpleDateService}
for us, with these methods:

\begin{lyxcode}
Public~Function~wsm\_getCurrentDate(ByVal~str\_input~As~String)~As~struct\_Date

...



Public~Function~wsm\_getDate(ByVal~dcml\_offset~As~Double,~

ByVal~obj\_someday~As~struct\_Date)~As~struct\_Date

...
\end{lyxcode}
Also, the class struct\_Date is generated to represent our structured datatype:

\begin{lyxcode}
'{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}

'This~class~was~created~by~the~Web~Service~References~Tool~2.0.

'

'Created:~6/29/2005~12:54:18~AM

'

'Description:

'This~class~is~a~Visual~Basic~for~Applications~class~representation~of~the~user-defined

'type~as~defined~by~http://dev-b.handel-dev.local:8080Plus/DateService.

'

'This~class~only~contains~the~Date,

'as~defined~in~the~WSDL.

'

'Changes~to~the~code~in~this~class~may~result~in~incorrect~behavior.

'

'{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}

Public~year~As~Long

Public~month~As~Long

Public~day~As~Long

Public~hour~As~Long

Public~minute~As~Long

Public~second~As~Long

Public~weekday~As~Long

Public~dayOfYear~As~Long

Public~dst~As~Long
\end{lyxcode}

\subsubsection{VB client implementation \& spreadsheet access\label{sub:VB-client-implementation-DateService}}

There are 2 ways to make the web service available in a spreadsheet: Using a sub
procedure (also called macro) or using a function. Note that

\begin{itemize}
\item a macro can not be called directly from a worksheet cell, so you need a command button
to call it
\item a function called directly or indirectly from a worksheet cell can not change another
cell´s value
\end{itemize}

\paragraph{Sub procedures (macros)}

While macros \emph{can} accept passed arguments, you can´t pass such arguments from
within a spreadsheet using command buttons. This leaves us with the possibility to
hard-wire the cell adresses we want to use to store our result values or to use {}``defined
names'' - we opt for the latter. To add the following client code, insert a command
button into the spreadsheet and double-click it while still in design mode. This
will add sub procedure stubs to the sheet objects of the VBA project:%
\footnote{By default, the stubs are called like the command buttons (e.g. {}``CommandButton\_Click()'').
Note that we changed the command button names here to reflect their purpose, which
results in this example´s macro names.%
}

\begin{lyxcode}
Private~Sub~getCurrentDateButton2\_Click()

~~~~Dim~inputRange~As~Range

~~~~Dim~outputRange~As~Range

~~~~Set~inputRange~=~Range(\char`\"{}input\_3\char`\"{})

~~~~Set~outputRange~=~Range(\char`\"{}today\_2\char`\"{})

~~~~Dim~dateObj~As~struct\_Date

~~~~Dim~service~As~New~clsws\_simpleDateService

~~~~

~~~~Set~dateObj~=~service.wsm\_getCurrentDate(str\_input)

~~~~

~~~~fillRangeFromDateStructure~outputRange,~dateObj

~~~

End~Sub





Private~Sub~getDateButton2\_Click()

~~~~Dim~inputDateRange~As~Range

~~~~Dim~inputOffsetRange~As~Range

~~~~Dim~outputRange~As~Range

~~~~

~~~~Set~inputOffsetRange~=~Range(\char`\"{}offset\_3\char`\"{})

~~~~Set~inputDateRange~=~Range(\char`\"{}someday\_3\char`\"{})

~~~~Set~outputRange~=~Range(\char`\"{}day\_2\char`\"{})

~~~~

~~~~Dim~dateRes~As~struct\_Date

~~~~Dim~dateInput~As~New~struct\_Date

~~~

~~~~fillDateStructureFromRange~dateInput,~inputDateRange

~~~~Dim~service~As~New~clsws\_simpleDateService

~~~~Set~dateRes~=~service.wsm\_getDate(inputOffsetRange.Value,~dateInput)

~~~~

~~~~fillRangeFromDateStructure~outputRange,~dateRes

~~~~

End~Sub





Private~Sub~fillDateStructureFromRange(ByRef~dateRes~As~struct\_Date,~

ByRef~inputDateRange~As~Range)

~~~~

~~~~dateRes.year~=~inputDateRange.Item(1,~1)

~~~~dateRes.month~=~inputDateRange.Item(2,~1)

~~~~dateRes.day~=~inputDateRange.Item(3,~1)

~~~~dateRes.hour~=~inputDateRange.Item(4,~1)

~~~~dateRes.minute~=~inputDateRange.Item(5,~1)

~~~~dateRes.second~=~inputDateRange.Item(6,~1)

~~~~dateRes.weekday~=~inputDateRange.Item(7,~1)

~~~~dateRes.dayOfYear~=~inputDateRange.Item(8,~1)

~~~~dateRes.dst~=~inputDateRange.Item(9,~1)

End~Sub





Private~Sub~fillRangeFromDateStructure(ByRef~outputRange~As~Range,~

ByRef~inputDate~As~struct\_Date)

~~~~outputRange.Item(1,~1)~=~inputDate.year

~~~~outputRange.Item(2,~1)~=~inputDate.month

~~~~outputRange.Item(3,~1)~=~inputDate.day

~~~~outputRange.Item(4,~1)~=~inputDate.hour

~~~~outputRange.Item(5,~1)~=~inputDate.minute

~~~~outputRange.Item(6,~1)~=~inputDate.second

~~~~outputRange.Item(7,~1)~=~inputDate.weekday

~~~~outputRange.Item(8,~1)~=~inputDate.dayOfYear

~~~~outputRange.Item(9,~1)~=~inputDate.dst

End~Sub
\end{lyxcode}
This code defines two macros (and two helpers) to access the DateService methods.
They can be invoked from a spreadsheet by the corresponding command buttons. Note
that both macros rely on hardcoded defined names. To use the macros, you have to
define these names in the spreadsheet. Moreover, the names must refer to appropriate
cell ranges: The range {}``input\_3'' used in the \texttt{getCurrentDateButton2\_Click()}
macro refers to a single-cell range, whereas the {}``someday\_3'' and {}``day\_2''
ranges are expected to contain 8 elements (cells).


\paragraph{Functions}

Of course it would be much nicer if no hardcoded names were needed. And indeed, there
are solutions to do this. A simple approach is to return a single string value that
is a concatenation of a date´s fields (insert those functions with Insert->Module...):

\begin{lyxcode}
Public~Function~getCurrentDate(ByVal~str\_input~As~String)~As~String

~~~~'{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}

~~~~'Excel~Sheet~entry~point~to~call~wsm\_getCurrentDate~Proxy~function,

~~~~'manually~created.

~~~~'{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}

~~~~Dim~dateObj~As~struct\_Date

~~~~Dim~service~As~New~clsws\_simpleDateService

~~~~

~~~~Set~dateObj~=~service.wsm\_getCurrentDate(str\_input)

~~~~getCurrentDate~=~Str(dateObj.year)~+~\char`\"{}/\char`\"{}~+~Str(dateObj.month)~+~\char`\"{}/\char`\"{}~+

Str(dateObj.day)~+~\char`\"{}~\char`\"{}~+~Str(dateObj.hour)~+~\char`\"{}:\char`\"{}~+~Str(dateObj.minute)~+~\char`\"{}:\char`\"{}~+~

Str(dateObj.second)

~~~~

End~Function



Public~Function~getDate(ByVal~i\_offset~As~Integer,~ByRef~inputDateRange~As~Range)

As~String

~~~~'{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}

~~~~'Excel~Sheet~entry~point~to~call~wsm\_getCurrentDate~Proxy~function,

~~~~'manually~created.

~~~~'{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}{*}

~~~~

~~~~

~~~~Dim~dateRes~As~struct\_Date

~~~~Dim~dateInput~As~New~struct\_Date

~~~~

~~~~

~~~~dateInput.year~=~inputDateRange.Item(1,~1)

~~~~dateInput.month~=~inputDateRange.Item(2,~1)

~~~~dateInput.day~=~inputDateRange.Item(3,~1)

~~~~dateInput.hour~=~inputDateRange.Item(4,~1)

~~~~dateInput.minute~=~inputDateRange.Item(5,~1)

~~~~dateInput.second~=~inputDateRange.Item(6,~1)

~~~~dateInput.weekday~=~inputDateRange.Item(7,~1)

~~~~dateInput.dayOfYear~=~inputDateRange.Item(8,~1)

~~~~dateInput.dst~=~inputDateRange.Item(9,~1)

~

~~~~Dim~service~As~New~clsws\_simpleDateService

~~~~Set~dateRes~=~service.wsm\_getDate(i\_offset,~dateInput)

~~~~

~~~~getDate~=~Str(dateRes.year)~+~\char`\"{}/\char`\"{}~+~Str(dateRes.month)~+~\char`\"{}/\char`\"{}~+

Str(dateRes.day)~+~\char`\"{}~\char`\"{}~+~Str(dateRes.hour)~+~\char`\"{}:\char`\"{}~+~Str(dateRes.minute)~+~\char`\"{}:\char`\"{}~+

Str(dateRes.second)

~~~~

End~Function
\end{lyxcode}
Unfortunately, the structure of a date is lost with this approach, as well as the
actual fields´ datatypes (imagine a struct consisting of different datatypes). There
is a better possibility:

\begin{lyxcode}
Public~Function~getCurrentDateAsArray(ByRef~inputR~As~Range)~As~Variant

~~~~Dim~resArr(8,~0)~As~Variant

~~~~

~~~~

~~~~Dim~dateObj~As~struct\_Date

~~~~Dim~service~As~New~clsws\_simpleDateService

~~~~

~~~~Set~dateObj~=~service.wsm\_getCurrentDate(str\_input)

~~~~resArr(0,~0)~=~dateObj.year

~~~~resArr(1,~0)~=~dateObj.month

~~~~resArr(2,~0)~=~dateObj.day

~~~~resArr(3,~0)~=~dateObj.hour

~~~~resArr(4,~0)~=~dateObj.minute

~~~~resArr(5,~0)~=~dateObj.second

~~~~resArr(6,~0)~=~dateObj.weekday

~~~~resArr(7,~0)~=~dateObj.dayOfYear

~~~~resArr(8,~0)~=~dateObj.dst

~~~~getCurrentDateAsArray~=~resArr

~~~~

End~Function

Public~Function~getDateAsArray(ByVal~i\_offset~As~Integer,~ByRef~inputDateRange~As~Range)

As~Variant

~~~~

~~~~Dim~resArr(8,~0)~As~Variant

~~~~Dim~dateRes~As~struct\_Date

~~~~Dim~dateInput~As~New~struct\_Date

~~~~

~~~~

~~~~dateInput.year~=~inputDateRange.Item(1,~1)

~~~~dateInput.month~=~inputDateRange.Item(2,~1)

~~~~dateInput.day~=~inputDateRange.Item(3,~1)

~~~~dateInput.hour~=~inputDateRange.Item(4,~1)

~~~~dateInput.minute~=~inputDateRange.Item(5,~1)

~~~~dateInput.second~=~inputDateRange.Item(6,~1)

~~~~dateInput.weekday~=~inputDateRange.Item(7,~1)

~~~~dateInput.dayOfYear~=~inputDateRange.Item(8,~1)

~~~~dateInput.dst~=~inputDateRange.Item(9,~1)

~~~~

~~~~Dim~service~As~New~clsws\_simpleDateService

~~~~Set~dateRes~=~service.wsm\_getDate(i\_offset,~dateInput)

~~~~

~~~~resArr(0,~0)~=~dateRes.year

~~~~resArr(1,~0)~=~dateRes.month

~~~~resArr(2,~0)~=~dateRes.day

~~~~resArr(3,~0)~=~dateRes.hour

~~~~resArr(4,~0)~=~dateRes.minute

~~~~resArr(5,~0)~=~dateRes.second

~~~~resArr(6,~0)~=~dateRes.weekday

~~~~resArr(7,~0)~=~dateRes.dayOfYear

~~~~resArr(8,~0)~=~dateRes.dst

~~~~getDateAsArray~=~resArr

~~~~

End~Function
\end{lyxcode}
To make use of these functions, you have to insert them into the spreadsheet as so-called
{}``array formulas''. This means you must enter the formula like this:

\begin{enumerate}
\item Select the desired result cells (which would normally mean a range of cells in this
case).
\item Enter the function call, e.g.:

\begin{lyxcode}
=getCurrentDateAsArray(A1)
\end{lyxcode}
\item Press CTRL+SHIFT+ENTER.
\end{enumerate}
You´ll now see the entered formula in brackets if you select one of the range´s cells,
e.g.:

\begin{lyxcode}
\{=getCurrentDateAsArray(input\_4)\}
\end{lyxcode}

\subsubsection{Web Service References Toolkit pitfalls}

An early version of the DateService WSDL brought up a problem with the WS References
Toolkit. This version featured an input parameter with the same name as the return
value for one of the service methods:

\begin{lyxcode}
~~...

~~<message~name=\char`\"{}getDateRequest\char`\"{}>

~~~~<part~name=\char`\"{}offset\char`\"{}~type=\char`\"{}xsd:integer\char`\"{}/>

~~~~<part~name=\char`\"{}someday\char`\"{}~type=\char`\"{}myType:Date\char`\"{}/>

~~</message>

~~<message~name=\char`\"{}getDateResponse\char`\"{}>

~~~~<part~name=\char`\"{}someday\char`\"{}~type=\char`\"{}myType:Date\char`\"{}/>

~~</message>

~~...
\end{lyxcode}
The generated VB stubs for this WSDL did not work. They seemed to implicate modifying
the input object (handed in \texttt{ByRef}) instead of returning a new return value:

\begin{lyxcode}
Public~Sub~wsm\_getDate(ByVal~dcml\_offset~As~Double,~ByRef~obj\_someday~As~struct\_Date)

...
\end{lyxcode}
While the code looked ok, it just didn´t work, for whatever reason.


\subsection{A gSOAP C++ client for the DateService}


\subsubsection{Code generation from WSDL\label{sub:Code-generation-gsoap_DateService}}

\begin{enumerate}
\item Header:

\begin{lyxcode}
\$~/apps/pydev/bin/wsdl2h~-o~dateService.h~http://dev-b.handel-dev.local:8080/DateService

{*}{*}~The~gSOAP~WSDL~parser~for~C~and~C++~1.2.0

{*}{*}~Copyright~(C)~2000-2005~Robert~van~Engelen,~Genivia~Inc.

{*}{*}~All~Rights~Reserved.~This~product~is~provided~\char`\"{}as~is\char`\"{},~without~any~warranty.

{*}{*}~The~gSOAP~WSDL~parser~is~released~under~one~of~the~following~two~licenses:

{*}{*}~GPL~or~the~commercial~license~by~Genivia~Inc.~Use~option~-l~for~more~info.

Saving~dateService.h

Connecting~to~'http://dev-b.handel-dev.local:8080/DateService'~to~retrieve~WSDL...~done

Cannot~open~file~'typemap.dat'

Problem~reading~type~map~file~typemap.dat.

Using~internal~type~definitions~for~C++~instead.

Warning:~part~'today'~uses~literal~style~and~must~refer~to~an~element~rather~than~a~type

Warning:~part~'input'~uses~literal~style~and~must~refer~to~an~element~rather~than~a~type

Warning:~part~'input'~uses~literal~style~and~must~refer~to~an~element~rather~than~a~type

Warning:~part~'day'~uses~literal~style~and~must~refer~to~an~element~rather~than~a~type

Warning:~part~'offset'~uses~literal~style~and~must~refer~to~an~element~rather~than~a~type

Warning:~part~'someday'~uses~literal~style~and~must~refer~to~an~element~rather~than~a~type

Warning:~part~'offset'~uses~literal~style~and~must~refer~to~an~element~rather~than~a~type

Warning:~part~'someday'~uses~literal~style~and~must~refer~to~an~element~rather~than~a~type

To~complete~the~process,~compile~with:

soapcpp2~dateService.h
\end{lyxcode}
\item Stub code:

\begin{lyxcode}
0~hjoukl@dev-b~.../C++~\$~/apps/pydev/bin/soapcpp2~

-I~/data/pydev/DOWNLOADS/gsoap-2.7/soapcpp2~dateService.h

{*}{*}~The~gSOAP~Stub~and~Skeleton~Compiler~for~C~and~C++~2.7.1

{*}{*}~Copyright~(C)~2000-2005,~Robert~van~Engelen,~Genivia~Inc.

{*}{*}~All~Rights~Reserved.~This~product~is~provided~\char`\"{}as~is\char`\"{},~without~any~warranty.

{*}{*}~The~gSOAP~compiler~is~released~under~one~of~the~following~three~licenses:

{*}{*}~GPL,~the~gSOAP~public~license,~or~the~commercial~license~by~Genivia~Inc.

Saving~soapStub.h

Saving~soapH.h

Saving~soapC.cpp

Saving~soapClient.cpp

Saving~soapServer.cpp

Saving~soapClientLib.cpp

Saving~soapServerLib.cpp

Using~ns3~service~name:~DateService\_USCOREBinding

Using~ns3~service~style:~document

Using~ns3~service~encoding:~literal

Using~ns3~service~location:~http://dev-b.handel-dev.local:8080/DateService

Using~ns3~schema~namespace:~urn:DateService.wsdl

Saving~soapDateService\_USCOREBindingProxy.h~client~proxy

Saving~soapDateService\_USCOREBindingObject.h~server~object

Saving~DateService\_USCOREBinding.getCurrentDate.req.xml~sample~SOAP/XML~request

Saving~DateService\_USCOREBinding.getCurrentDate.res.xml~sample~SOAP/XML~response

Saving~DateService\_USCOREBinding.getDate.req.xml~sample~SOAP/XML~request

Saving~DateService\_USCOREBinding.getDate.res.xml~sample~SOAP/XML~response

Saving~DateService\_USCOREBinding.nsmap~namespace~mapping~table

Compilation~successful

0~hjoukl@dev-b~.../C++~\$
\end{lyxcode}
\end{enumerate}

\subsubsection{Client implementation}

As already announced in section \ref{sub:gsoap-square-client} we´ll now access the
service through the DateService proxy class, which can be found in \texttt{soapDateService\_USCOREBindingProxy.h}.
We use it to call the two WS-methods in our sample client:

\begin{lyxcode}
//~Contents~of~file~\char`\"{}myclient\_use\_proxy.cpp\char`\"{}

\#include~\char`\"{}soapDateService\_USCOREBindingProxy.h\char`\"{}

\#include~\char`\"{}DateService\_USCOREBinding.nsmap\char`\"{}

int~main()

\{

~~~~DateService~ds;

~~~~ns2\_\_Date~{*}today,~{*}someday;

~~~~ns3\_\_getCurrentDateResponse~today\_response;

~~~~ns3\_\_getDateResponse~someday\_response;

~~~~std::string~text,~input;

~~~~text=\char`\"{}TEST\char`\"{};

~~~~std::cout~<\,{}<~\char`\"{}(1)~Calling~'getCurrentDate()'-~Web~Service~method:\char`\"{}~<\,{}<~std::endl;

~~~~if(ds.ns3\_\_getCurrentDate(text,~today\_response)~==~SOAP\_OK)

~~~~~~~~\{

~~~~~~~~~~~~today~=~today\_response.today;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}nCurrent~date:\char`\"{}~<\,{}<~std::endl;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}tyear:~\char`\"{}~~<\,{}<~{*}today->year~~<\,{}<~std::endl;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}tmonth:~\char`\"{}~<\,{}<~{*}today->month~<\,{}<~std::endl;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}tday:~\char`\"{}~~~<\,{}<~{*}today->day~~~<\,{}<~std::endl;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}thour:~\char`\"{}~~~<\,{}<~{*}today->hour~~~<\,{}<~std::endl;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}tminute:~\char`\"{}~~~<\,{}<~{*}today->minute~~~<\,{}<~std::endl;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}tsecond:~\char`\"{}~~~<\,{}<~{*}today->second~~~<\,{}<~std::endl;

~~~~~~~~\}

~~~~else

~~~~~~~~soap\_print\_fault(ds.soap,~stderr);

~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}n(2)~Calling~'getDate()'-~Web~Service~method:\char`\"{}~<\,{}<~std::endl;

~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}n(2)Please~enter~an~integer~for~the~'offset'\char`\"{}<\,{}<~std::endl;

~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}toffset~=~\char`\"{};

~~~~std::cin~>\,{}>~input;

~~~~someday~=~today;

~~~~if(ds.ns3\_\_getDate(input,~someday,~someday\_response)~==~SOAP\_OK)

~~~~~~~~\{

~~~~~~~~~~~~someday~=~someday\_response.day;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}nSome~Day:\char`\"{}~<\,{}<~std::endl;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}tyear:~\char`\"{}~<\,{}<~{*}someday->year~<\,{}<~std::endl;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}tmonth:~\char`\"{}<\,{}<~{*}someday->month~<\,{}<~std::endl;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}tday:~\char`\"{}~<\,{}<~{*}someday->day~<\,{}<~std::endl;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}thour:~\char`\"{}~~~<\,{}<~{*}today->hour~~~<\,{}<~std::endl;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}tminute:~\char`\"{}~~~<\,{}<~{*}today->minute~~~<\,{}<~std::endl;

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}\textbackslash{}tsecond:~\char`\"{}~~~<\,{}<~{*}today->second~~~<\,{}<~std::endl;

~~~~~~~~\}

~~~~else

~~~~return~0;

\}
\end{lyxcode}
You can find the classes/structs that represent the WSDL input and output datatypes
in the generated file \texttt{soapStub.h}. This file is really pretty much self-explaining,
so the usage in client implementations should be straightforward.


\subsubsection{gSOAP Client compilation }


\paragraph{gcc 2.95.2}

\begin{lyxcode}
~\$~g++~-o~myClient\_use\_proxy~-I/apps/pydev/include~-L/apps/pydev/lib~

-R~/apps/prod/lib~myClient\_use\_proxy.cpp~soapC.cpp~soapClient.cpp~

-lsocket~-lgsoap++
\end{lyxcode}

\paragraph{gcc 3.4.3}

\begin{lyxcode}
\$~/apps/pydev/gcc/3.4.3/bin/g++~-o~myClient\_use\_proxy~-I/apps/pydev/include

-L/apps/pydev/gcc/3.4.3/lib~-R~/apps/pydev/gcc/3.4.3/lib~

myClient\_use\_proxy.cpp~soapC.cpp~soapClient.cpp~

-lsocket~-lgsoap++~-lnsl
\end{lyxcode}

\subsection{Applix spreadsheets as DateService clients}

While Applix does not come with built-in web services support it is extensible with
C shared libraries. We can use this feature to wrap gSOAP client code, making web
services accessible from within Applix spreadsheets.


\subsubsection{Code generation from WSDL}

The C/C++ client stubs must be generated as described in section\ref{sub:Code-generation-gsoap_DateService}.


\subsubsection{Applix client implementation\label{sub:Applix-client-implementation}}


\paragraph{ELF C extension}

To make the DateService callable from Applix we need to write an ELF shared library
C extension. The \texttt{ax\_DateService.cpp} extension implements the gSOAP web
services access:

\begin{lyxcode}
\#include~\char`\"{}elfapi.h\char`\"{}

\#include~\char`\"{}soapDateService\_USCOREBindingProxy.h\char`\"{}

\#include~\char`\"{}DateService\_USCOREBinding.nsmap\char`\"{}

\#define~TRUE~1



extern~\char`\"{}C\char`\"{}~elfData~getCurrentDate();

extern~\char`\"{}C\char`\"{}~elfData~getCurrentDate\_2();

extern~\char`\"{}C\char`\"{}~elfData~getDate();

extern~\char`\"{}C\char`\"{}~elfData~getDate\_2();

/{*}

{*}~~~~~~~Define~the~function~table

{*}/

AxCallInfo\_t~~~~funcTable{[}{]}=\{

~~~~~~~~\{~\char`\"{}Web~Services\char`\"{},~/{*}~func~type~...~\char`\"{}financial\char`\"{},~\char`\"{}math\char`\"{}~...~{*}/

~~~~~~~~~~getCurrentDate,~~/{*}~The~C~routine~to~call~~{*}/

~~~~~~~~~~\char`\"{}getCurrentDate\char`\"{},~/{*}~name~to~use~in~Applixware~(usually~identical~to~the~function~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~name)~~~{*}/

~~~~~~~~~~\char`\"{}string~getCurrentDate(string)\char`\"{},~~/{*}~shows~the~function~name~and~its~arguments~{*}/

~~~~~~~~~~TRUE~~/{*}~An~integer~that~governs~the~treatment~of~ERROR~and~NA~values,

~~~~~~~~~~~~~~~~~~~and~whether~the~function~is~displayed~in~the~Spreadsheets~Functions~

~~~~~~~~~~~~~~~~~~~dialog~box.~{*}/

~~~~~~~~\},

~~~~~~~~\{~\char`\"{}Web~Services\char`\"{},~/{*}~func~type~...~\char`\"{}financial\char`\"{},~\char`\"{}math\char`\"{}~...~{*}/

~~~~~~~~~~getCurrentDate\_2,~~~~/{*}~The~C~routine~to~call~~{*}/

~~~~~~~~~~\char`\"{}getCurrentDate\_2\char`\"{},~~/{*}~name~to~use~in~Applixware~(usually~identical~to~the~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~function~name)~~~{*}/

~~~~~~~~~~\char`\"{}date~getCurrentDate\_2(string)\char`\"{},~~/{*}~shows~the~function~name~and~its~arguments~{*}/

~~~~~~~~~~TRUE~~~~~~~~~~~~/{*}~An~integer~that~governs~the~treatment~of~ERROR~and~NA~values,

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~and~whether~the~function~is~displayed~in~the~Spreadsheets~~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~Functions~dialog~box.~{*}/

~~~~~~~~\},

~~~~~~~~\{~\char`\"{}Web~Services\char`\"{},~/{*}~func~type~...~\char`\"{}financial\char`\"{},~\char`\"{}math\char`\"{}~...~{*}/

~~~~~~~~~~getDate,~~~~~~~~/{*}~The~C~routine~to~call~~{*}/

~~~~~~~~~~\char`\"{}getDate\char`\"{},~~~~~~/{*}~name~to~use~in~Applixware~(usually~identical~to~the~function~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~name)~~~{*}/

~~~~~~~~~~\char`\"{}date\_string~getDate(int,~date)\char`\"{},~/{*}~shows~the~function~name~and~its~arguments~{*}/

~~~~~~~~~~TRUE~~~/{*}~An~integer~that~governs~the~treatment~of~ERROR~and~NA~values,

~~~~~~~~~~~~~~~~~~~~and~whether~the~function~is~displayed~in~the~Spreadsheets~Functions~

~~~~~~~~~~~~~~~~~~~~dialog~box.~{*}/

~~~~~~~~\},

~~~~~~~~\{~\char`\"{}Web~Services\char`\"{},~/{*}~func~type~...~\char`\"{}financial\char`\"{},~\char`\"{}math\char`\"{}~...~{*}/

~~~~~~~~~~getDate\_2,~~~~~~/{*}~The~C~routine~to~call~~{*}/

~~~~~~~~~~\char`\"{}getDate\_2\char`\"{},~~~~/{*}~name~to~use~in~Applixware~(usually~identical~to~the~function~

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~name)~~~{*}/

~~~~~~~~~~\char`\"{}date~getDate\_2(int,~date)\char`\"{},~~~/{*}~shows~the~function~name~and~its~arguments~{*}/

~~~~~~~~~~TRUE~~/{*}~An~integer~that~governs~the~treatment~of~ERROR~and~NA~values,

~~~~~~~~~~~~~~~~~~~and~whether~the~function~is~displayed~in~the~Spreadsheets~Functions

~~~~~~~~~~~~~~~~~~~dialog~box.~{*}/

~~~~~~~~\},

~~~~~~~~\{~~NULL,

~~~~~~~~~~~NULL,

~~~~~~~~~~~NULL,

~~~~~~~~~~~NULL,

~~~~~~~~~~~NULL

~~~~~~~~\}

\};

/{*}

{*}~~~~~~~Function~AxGetCallInfo~returns~the~function~table.

{*}~~~~~~~This~function~is~called~by~Applixware~when~you~run~the~macro

{*}~~~~~~~RPC\_CONNECT@~or~INSTALL\_C\_LIBRARY@.~This~function~must~exist

{*}~~~~~~~in~the~RPC~program~or~Shared~Library.

{*}/

DLL\_EXPORT~AxCallInfo\_t~{*}AxGetCallInfo()

\{

~~~~~~~~return(funcTable);

\}

/{*}========================================={*}/

/{*}~func~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~{*}/

/{*}========================================={*}/



extern~\char`\"{}C\char`\"{}~elfData~getCurrentDate(elfData~args)~~~~~

/{*}~args~is~an~array~of~arguments~passed~from~ELF~{*}/

\{

~~~~elfData~arrayElem;

~~~~elfData~retValue;

~~~~char~{*}val;

~~~~/{*}~Check~argument~number~\&~types~{*}/

~~~~if~(AxArraySize(args)~!=~1)~\{

~~~~~~~~AxError(1,~\char`\"{}function~takes~one~single~argument\char`\"{},~\char`\"{}getCurrentDate\char`\"{});

~~~~\}

~~~~arrayElem~=~AxArrayElement(args,~0);

~~~~if~(!AxIsString(arrayElem))~AxError(1,~\char`\"{}argument~must~be~a~string\char`\"{},~\char`\"{}getCurrentDate\char`\"{});

~~~~DateService~ds;

~~~~ns2\_\_Date~{*}today;

~~~~ns3\_\_getCurrentDateResponse~today\_response;

~~~~val~=~AxStrFromDataPtr(arrayElem);

~~~~std::string~text(val);

~~~~std::string~soapError~=~\char`\"{}SOAP~Error\char`\"{};

~~~~std::string~result~=~\char`\"{}\char`\"{};

~~~~if(ds.ns3\_\_getCurrentDate(text,~today\_response)~==~SOAP\_OK)

~~~~~~~~\{

~~~~~~~~~~~~today~=~today\_response.today;

~~~~~~~~~~~~result~=~{*}today->year

~~~~~~~~~~~~~~~~+~\char`\"{}/\char`\"{}~+~{*}today->month

~~~~~~~~~~~~~~~~+~\char`\"{}/\char`\"{}~+~{*}today->day

~~~~~~~~~~~~~~~~+~\char`\"{}~\char`\"{}~+~{*}today->hour

~~~~~~~~~~~~~~~~+~\char`\"{}:\char`\"{}~+~{*}today->minute

~~~~~~~~~~~~~~~~+~\char`\"{}:\char`\"{}~+~{*}today->second;

~~~~~~~~~\}

~~~~else

~~~~~~~~\{

~~~~~~~~~~~~//soap\_print\_fault(ds.soap,~stderr);~~//~gSOAP~error

~~~~~~~~~~~~soapError~=~\char`\"{}SOAP~error\char`\"{};

~~~~~~~~~~~~AxError(1,~soapError.c\_str(),~\char`\"{}getCurrentDate\char`\"{});

~~~~~~~~~~~~//AxError(1,~\char`\"{}SOAP~error\char`\"{},~\char`\"{}getCurrentDate\char`\"{});

~~~~~~~~\}

~~~~~retValue~=~AxMakeStrData(result.length(),~result.c\_str());

~~~~~return~retValue;

\}

extern~\char`\"{}C\char`\"{}~elfData~getCurrentDate\_2(elfData~args)~~~~~

/{*}~args~is~an~array~of~arguments~passed~from~ELF~{*}/

\{

~~~~elfData~arrayElem;

~~~~elfData~retArray;

~~~~char~{*}val;

~~~~/{*}~Check~argument~number~\&~types~{*}/

~~~~if~(AxArraySize(args)~!=~1)~\{

~~~~~~~~AxError(1,~\char`\"{}function~takes~one~single~argument\char`\"{},~\char`\"{}getCurrentDate\char`\"{});

~~~~\}

~~~~arrayElem~=~AxArrayElement(args,~0);

~~~~if~(!AxIsString(arrayElem))~AxError(1,~\char`\"{}argument~must~be~a~string\char`\"{},~\char`\"{}getCurrentDate\char`\"{});

~~~~DateService~ds;

~~~~ns2\_\_Date~{*}today;

~~~~ns3\_\_getCurrentDateResponse~today\_response;

~~~~val~=~AxStrFromDataPtr(arrayElem);

~~~~std::string~text(val);

~~~~std::string~soapError~=~\char`\"{}\char`\"{};

~~~~if(ds.ns3\_\_getCurrentDate(text,~today\_response)~==~SOAP\_OK)

~~~~~~~~\{

~~~~~~~~~~~~today~=~today\_response.today;

~~~~~~~~~~~~retArray~=~AxMakeArray(0);

~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~0,~atoi(({*}today->year).c\_str()));

~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~1,~atoi(({*}today->month).c\_str()));

~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~2,~atoi(({*}today->day).c\_str()));

~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~3,~atoi(({*}today->hour).c\_str()));

~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~4,~atoi(({*}today->minute).c\_str()));

~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~5,~atoi(({*}today->second).c\_str()));

~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~6,~atoi(({*}today->weekday).c\_str()));

~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~7,~atoi(({*}today->dayOfYear).c\_str()));

~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~8,~atoi(({*}today->dst).c\_str()));

~~~~~~~~~\}

~~~~else

~~~~~~~~\{

~~~~~~~~~~~~//soap\_print\_fault(ds.soap,~stderr);~~//~gSOAP~error

~~~~~~~~~~~~soapError~=~\char`\"{}SOAP~error\char`\"{};

~~~~~~~~~~~~AxError(1,~soapError.c\_str(),~\char`\"{}getCurrentDate\char`\"{});

~~~~~~~~~~~~//AxError(1,~\char`\"{}SOAP~error\char`\"{},~\char`\"{}getCurrentDate\char`\"{});

~~~~~~~~\}

~~~~return~retArray;

\}



extern~\char`\"{}C\char`\"{}~elfData~getDate(elfData~args)~~~~~

/{*}~args~is~an~array~of~arguments~passed~from~ELF~{*}/

\{

~~~~elfData~elf\_offset,~elf\_date,~retValue;

~~~~/{*}~Check~argument~number~\&~types~{*}/

~~~~if~(AxArraySize(args)~!=~2)~\{

~~~~~~~~AxError(1,~\char`\"{}function~takes~2~arguments\char`\"{},~\char`\"{}getCurrentDate\char`\"{});

~~~~\}

~~~~elf\_offset~=~AxArrayElement(args,~0);

~~~~if~(!AxIsInt(elf\_offset))~AxError(1,~\char`\"{}argument~must~be~an~integer\char`\"{},~\char`\"{}getDate\char`\"{});

~~~~elf\_date~=~AxArrayElement(args,~1);

~~~~if~(!AxIsArray(elf\_date))~AxError(1,~\char`\"{}argument~must~be~an~array\char`\"{},~\char`\"{}getDate\char`\"{});

~~~~DateService~ds;

~~~~//ns2\_\_Date~someday,~date;

~~~~ns2\_\_Date~{*}someday,~date;

~~~~ns3\_\_getDateResponse~someday\_response;

~~~~std::string~offset(AxStrFromDataPtr(elf\_offset));

~~~~std::string~year(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~0),~0)));

~~~~std::string~month(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~1),~0)));

~~~~std::string~day(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~2),~0)));

~~~~std::string~hour(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~3),~0)));

~~~~std::string~minute(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~4),~0)));

~~~~std::string~second(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~5),~0)));

~~~~std::string~weekday(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~6),~0)));

~~~~std::string~dayOfYear(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~7),~0)));

~~~~std::string~dst(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~8),~0)));

~~~~date.year~=~\&year;

~~~~date.month~=~\&month;

~~~~date.day~=~\&day;

~~~~date.hour~=~\&hour;

~~~~date.minute~=~\&minute;

~~~~date.second~=~\&second;

~~~~date.weekday~=~\&weekday;

~~~~date.dayOfYear~=~\&dayOfYear;

~~~~date.dst~=~\&dst;

~~~~std::string~result~=~\char`\"{}\char`\"{};

~~~~//retValue~=~AxMakeStrData(offset.length(),~offset.c\_str());

~~~~//return~retValue;

~~~~//std::cout~<\,{}<~\char`\"{}(1)~Calling~'getCurrentDate()'-~Web~Service~method:\char`\"{}~<\,{}<~std::endl;

~~~~if(ds.ns3\_\_getDate(offset,~\&date,~someday\_response)~==~SOAP\_OK)

~~~~~~~~\{

~~~~~~~~~~~~someday~=~someday\_response.day;

~~~~~~~~~~~~result~=~{*}someday->year

~~~~~~~~~~~~~~~~+~\char`\"{}/\char`\"{}~+~{*}someday->month

~~~~~~~~~~~~~~~~+~\char`\"{}/\char`\"{}~+~{*}someday->day

~~~~~~~~~~~~~~~~+~\char`\"{}~\char`\"{}~+~{*}someday->hour

~~~~~~~~~~~~~~~~+~\char`\"{}:\char`\"{}~+~{*}someday->minute

~~~~~~~~~~~~~~~~+~\char`\"{}:\char`\"{}~+~{*}someday->second;

~~~~~~~~~~\}

~~~~else

~~~~~~~~\{

~~~~~~~~~~~~//soap\_print\_fault(ds.soap,~stderr);~~//~gSOAP~error

~~~~~~~~~~~~AxError(1,~\char`\"{}SOAP~error\char`\"{},~\char`\"{}getCurrentDate\char`\"{});

~~~~~~~~\}

~~~~retValue~=~AxMakeStrData(result.length(),~result.c\_str());

~~~~return~retValue;

\}



extern~\char`\"{}C\char`\"{}~elfData~getDate\_2(elfData~args)~~~~~

/{*}~args~is~an~array~of~arguments~passed~from~ELF~{*}/

\{

~~~~elfData~elf\_offset,~elf\_date,~retArray;

~~~~/{*}~Check~argument~number~\&~types~{*}/

~~~~if~(AxArraySize(args)~!=~2)~\{

~~~~~~~~AxError(1,~\char`\"{}function~takes~2~arguments\char`\"{},~\char`\"{}getCurrentDate\char`\"{});

~~~~\}

~~~~elf\_offset~=~AxArrayElement(args,~0);

~~~~if~(!AxIsInt(elf\_offset))~AxError(1,~\char`\"{}argument~must~be~an~integer\char`\"{},~\char`\"{}getDate\char`\"{});

~~~~elf\_date~=~AxArrayElement(args,~1);

~~~~if~(!AxIsArray(elf\_date))~AxError(1,~\char`\"{}argument~must~be~an~array\char`\"{},~\char`\"{}getDate\char`\"{});

~~~~DateService~ds;

~~~~//ns2\_\_Date~someday,~date;

~~~~ns2\_\_Date~{*}someday,~date;

~~~~ns3\_\_getDateResponse~someday\_response;

~~~~std::string~offset(AxStrFromDataPtr(elf\_offset));

~~~~std::string~year(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~0),~0)));

~~~~std::string~month(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~1),~0)));

~~~~std::string~day(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~2),~0)));

~~~~std::string~hour(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~3),~0)));

~~~~std::string~minute(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~4),~0)));

~~~~std::string~second(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~5),~0)));

~~~~std::string~weekday(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~6),~0)));

~~~~std::string~dayOfYear(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~7),~0)));

~~~~std::string~dst(AxStrFromDataPtr(AxArrayElement(AxArrayElement(elf\_date,~8),~0)));

~~~~date.year~=~\&year;

~~~~date.month~=~\&month;

~~~~date.day~=~\&day;

~~~~date.hour~=~\&hour;

~~~~date.minute~=~\&minute;

~~~~date.second~=~\&second;

~~~~date.weekday~=~\&weekday;

~~~~date.dayOfYear~=~\&dayOfYear;

~~~~date.dst~=~\&dst;

~~~~std::string~result~=~\char`\"{}\char`\"{};

~~~~int~return\_integer~=~TRUE;

~~~~//std::cout~<\,{}<~\char`\"{}(1)~Calling~'getCurrentDate()'-~Web~Service~method:\char`\"{}~<\,{}<~std::endl;

~~~~if(ds.ns3\_\_getDate(offset,~\&date,~someday\_response)~==~SOAP\_OK)

~~~~~~~~\{

~~~~~~~~~~~~someday~=~someday\_response.day;

~~~~~~~~~~~~retArray~=~AxMakeArray(0);

~~~~~~~~~~~~if~(return\_integer~==~TRUE)

~~~~~~~~~~~~~~~~\{

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~0,~atoi(({*}someday->year).c\_str()));

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~1,~atoi(({*}someday->month).c\_str()));

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~2,~atoi(({*}someday->day).c\_str()));

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~3,~atoi(({*}someday->hour).c\_str()));

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~4,~atoi(({*}someday->minute).c\_str()));

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~5,~atoi(({*}someday->second).c\_str()));

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~6,~atoi(({*}someday->weekday).c\_str()));

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~7,~atoi(({*}someday->dayOfYear).c\_str()));

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddIntToArray(retArray,~8,~atoi(({*}someday->dst).c\_str()));

~~~~~~~~~~~~~~~~\}

~~~~~~~~~~~~else

~~~~~~~~~~~~~~~~\{

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddStrToArray(retArray,~0,~({*}someday->year).c\_str());

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddStrToArray(retArray,~1,~({*}someday->month).c\_str());

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddStrToArray(retArray,~2,~({*}someday->day).c\_str());

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddStrToArray(retArray,~3,~({*}someday->hour).c\_str());

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddStrToArray(retArray,~4,~({*}someday->minute).c\_str());

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddStrToArray(retArray,~5,~({*}someday->second).c\_str());

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddStrToArray(retArray,~6,~({*}someday->weekday).c\_str());

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddStrToArray(retArray,~7,~({*}someday->dayOfYear).c\_str());

~~~~~~~~~~~~~~~~~~~~retArray~=~AxAddStrToArray(retArray,~8,~({*}someday->dst).c\_str());

~~~~~~~~~~~~~~~~\}

~~~~~~~~~~\}

~~~~else

~~~~~~~~\{

~~~~~~~~~~~~AxError(1,~\char`\"{}SOAP~error\char`\"{},~\char`\"{}getCurrentDate\char`\"{});

~~~~~~~~\}

~~~~return~retArray;

\}
\end{lyxcode}
The code above implements the following functions:

\begin{itemize}
\item getCurrentDate: Return a string containing the current date. Takes a string argument.
\item getCurrentDate\_2: Return the current date as an array. Takes a string argument.
\item getDate: Return the input date + offset as a string. Takes an integer offset and
a 9-element date array as arguments.
\item getDate\_2: Return input date + offset as an array. Takes an integer offset and a
9-element date array as arguments.
\end{itemize}
To compile the code, you have to add the Applix ELF headers to the include path:

\begin{lyxcode}
g++~-shared~-o~ax\_DateService.so~-R/apps/prod/lib~

-I/apps/prod/applix/applix/versions/4.43.1021.544.343/axdata/elf~

-I/apps/pydev/include~-L/apps/pydev/lib~soapC.cpp~soap~ax\_DateService.cpp

-lgsoap++~-lsocket
\end{lyxcode}
The resulting shared library \texttt{ax\_DateService.so} must be loaded into Applix
before it can be used. This is done with the \texttt{install\_c\_library@(<extension
lib>)} macro:

\begin{lyxcode}
\#define~path~\char`\"{}/data/pydev/WebServicesPresentation/DateService\_rpc\_literal/Applix/\char`\"{}

macro~load()

~~~~~~~~install\_c\_library@(path++\char`\"{}ax\_DateService.so\char`\"{})

endmacro

macro~unload()

~~~~~~~~unbind\_c\_library@(path++\char`\"{}ax\_DateService.so\char`\"{})

endmacro

macro~reload()

~~~~~~~~unbind\_c\_library@(path++\char`\"{}ax\_DateService.so\char`\"{})

~~~~~~install\_c\_library@(path++\char`\"{}ax\_DateService.so\char`\"{})

endmacro
\end{lyxcode}
After the shared library has been dynamically loaded, the functions can be used like
built-in function inside the spreadsheet. To make sensible use of the \texttt{getDate\_2}
function which returns the date struct as an array, you have to invoke it as an array
function:%
\footnote{Compare to section \ref{sub:VB-client-implementation-DateService}.%
}

\begin{enumerate}
\item Select an array with the appropriate number of cells (9 cells, one-dimensional in
our case).
\item Enter the function call, e.g.:

\begin{lyxcode}
=getDate\_2(offset\_5,~someday\_5)
\end{lyxcode}
\item Press CTRL-SHIFT-ENTER to insert the formula as array function.
\end{enumerate}
The actual extension function calls might also be wrapped into additional macro code.
This makes it possible to invoke the functions from command buttons or to populate
predefined, hardcoded result ranges with the results of a service call. Compared
to Excel, an additional possibility for Applix is the definition of an extra argument
for the output range \emph{name} (as a string). Given the name, this range can then
be filled with the result value structure, removing the need to hardcode range names
in the macro code.%
\footnote{In Applix, macros can be called from spreadsheet cells but places restrictions on
modifying spreadsheet cells from within a macro.%
}

The following macro code show some of the possibilities. Refer to the code comments
for explanations:

\begin{lyxcode}
\#include~\char`\"{}spsheet\_.am\char`\"{}

/{*}~

{*}~Macros~for~Web~Service~getCurrentDate()

{*}/



/{*}~<\,{}<\,{}<\,{}<~~getCurrentDate\_Macro~>\,{}>\,{}>\,{}>\,{}>~{*}/

'~~~~~~~~~~~~~-{}->~~Returning~ASCII~string

'~~~~~~~~~~~~~-{}->~~called~from~within~a~cell

'~~~~~~~~~~~~~-{}->~~providing~an~input~parameter



Macro~getCurrentDate\_Macro(text)

var~retStr

/{*}~Web~Service~call~{*}/

retStr~=~getCurrentDate(text)

return(retStr)

endmacro

/{*}~<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<~END~>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>{*}/



/{*}~<\,{}<\,{}<\,{}<~~getCurrentDate\_2\_Macro~>\,{}>\,{}>\,{}>\,{}>~{*}/

'~~~~~~~~~~~~~~-{}->~no~return~value:~returning~ASCII~string~with~population

'~~~~~~~~~~~~~~~-{}->~~called~by~Buttons~

'~~~~~~~~~~~~~~~-{}->~~no~input~parameter~possible

'~~~~~~~~~~~~~~~-{}->~~hard-coded~input-parameter'

'~~~~~~~~~~~~~~~-{}->~~hard~coded~named~range~for~result~population



Macro~getCurrentDate\_2\_Macro()

var~format~ss\_cell\_~cellInfo

var~celladdr,~cell

var~retStr,~text

cellAddr~=~ss\_extract\_range\_info@(\char`\"{}input\_3\char`\"{})

cellInfo~=~ss\_get\_cell@(cellAddr{[}0{]},~cellAddr{[}1{]},~0)

text=cellInfo.display\_str

/{*}~Web~Service~call~{*}/

retStr~=~getCurrentDate(text)

/{*}~Result~Population~{*}/

cellAddr~=~ss\_extract\_range\_info@(\char`\"{}today\_1\char`\"{})

~ss\_put\_cell@(ss\_coordinate@(cellAddr{[}0{]},~cellAddr{[}1{]},~0),~retStr)

'Alternativ

'cell=ss\_coordinate@(cellAddr{[}0{]},~cellAddr{[}1{]},~0)

'new\_task@(\char`\"{}ss\_put\_cell@\char`\"{},~cell,~retStr)

endmacro

/{*}~<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<~END~>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>{*}/



/{*}~<\,{}<\,{}<\,{}<~~getCurrentDate\_3\_Macro~>\,{}>\,{}>\,{}>\,{}>~{*}/

'~~~~~~~~~~~~~~-{}->~no~return~value:~returning~date~array~~with~population

'~~~~~~~~~~~~~~~-{}->~~called~by~cell

'~~~~~~~~~~~~~~~-{}->~~input~parameter~for~result~population



Macro~getCurrentDate\_3\_Macro(text,~today)

'for~parameter~today~the~name~(string)~of~a~named~range~has~to~be~passed,~not~the~named

'~ranged~object~by~itself~-{}->~this~would~pass~an~array~to~the~macro,~where~the

'content~of~the~named~range~is~provided.~But~we~need~the~coordinates~of~the~cells~of~the

'named~range

var~format~ss\_cell\_~cellInfo

var~celladdr,~cell

var~retStr,~date,~rowStart,~rowEnd,~col

var~k,~i

/{*}~Web~Service~call~{*}/

date~=~getCurrentDate\_2(text)

/{*}~Result~Population~{*}/

'cellAddr~=~ss\_extract\_range\_info@(\char`\"{}today\char`\"{})

'~-{}->~hardcoded~if~no~parameter~is~allowed

cellAddr~=~ss\_extract\_range\_info@(today)

'~-{}->~not~possible~to~get~named~range~as~parameter~for~result~because~

'~the~content~of~the~named~range~is~used~by~APPLIX~NOT~THE~COORDINATES

rowStart=cellAddr{[}1{]}~

rowEnd=cellAddr{[}3{]}

col=cellAddr{[}2{]}

k=0

for~i=rowStart~to~rowEnd~~~~~~~~

~~~~~~~~cellInfo=~ss\_get\_cell@(col,~i,~0)

~~~~~~~~'date{[}k{]}=~\{~cellInfo.display\_str+0~\}

~~~~~~~~'ss\_put\_cell@(ss\_coordinate@(cellAddr{[}col{]},~cellAddr{[}i{]},~0),~date{[}k{]})

~~~~~~~~'Alternativ

~~~~~~~~cell=ss\_coordinate@(col,~i,~0)

~~~~~~~~new\_task@(\char`\"{}ss\_put\_cell@\char`\"{},~cell,~date{[}k{]})

~~~~~~~~'ss\_put\_cell@(col,i,date{[}k{]})

~~~~~~~~k=k+1

next~i

endmacro

/{*}~<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<~END~>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>{*}/



/{*}~

{*}~Macros~for~Web~Service~getDate()

{*}/

/{*}~<\,{}<\,{}<\,{}<~~getDate\_Macro~>\,{}>\,{}>\,{}>\,{}>~{*}/

'~~~~~~~~~~~~~-{}->~~Returning~ASCII~string

'~~~~~~~~~~~~~-{}->~~called~from~within~a~cell

'~~~~~~~~~~~~~-{}->~~providing~~input~parameter



Macro~getDate\_macro(offset,~someday)

var~retStr,~date

date=someday

/{*}~Web~Service~call~{*}/

retStr~=~getDate(offset,~date)

return(retStr)

endmacro

/{*}~<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<~END~>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>{*}/



/{*}~<\,{}<\,{}<\,{}<~~getDate\_1\_Macro~>\,{}>\,{}>\,{}>\,{}>~{*}/

'~~~~~~~~~~~~~~~~-{}->~Not~used

'~~~~~~~~~~~~~~-{}->~no~return~value:~returning~ASCII~string~with~population

'~~~~~~~~~~~~~~~-{}->~~called~by~Buttons~~or~from~within~a~cell

'~~~~~~~~~~~~~~~-{}->~~no~input~parameter~possible

'~~~~~~~~~~~~~~~-{}->~~hard-coded~input-parameter'

'~~~~~~~~~~~~~~~-{}->~~hard~coded~named~range~for~result~population



Macro~getDate\_1\_macro()

var~format~ss\_cell\_~cellInfo

var~retStr,~offset,~date,~rowStart,~rowEnd,~col

var~cellAddr,~k,~i,~cell

/{*}~Preparing~Web~Service~input~parameter~{*}/

cellAddr~=~ss\_extract\_range\_info@(\char`\"{}offset\char`\"{})

cellInfo~=~ss\_get\_cell@(cellAddr{[}0{]},~cellAddr{[}1{]},~0)

offset=cellInfo.display\_str+0

cellAddr~=~ss\_extract\_range\_info@(\char`\"{}someday\char`\"{})

rowStart=cellAddr{[}1{]}~

rowEnd=cellAddr{[}3{]}

col=cellAddr{[}2{]}

k=0

for~i=rowStart~to~rowEnd~~~~~~~~

~~~~~~~~cellInfo=~ss\_get\_cell@(col,~i,~0)

~~~~~~~~date{[}k{]}=~\{~cellInfo.display\_str+0~\}

~~~~~~~~k=k+1

next~i

/{*}~Web~Service~call~{*}/

retStr~=~getDate(offset,~date)

/{*}~Result~Population~{*}/

cellAddr~=~ss\_extract\_range\_info@(\char`\"{}result\_macro1\char`\"{})

/{*}~Gilt~fuer~Start~des~Makros~ueber~Button~~{*}/

'~ss\_put\_cell@(ss\_coordinate@(cellAddr{[}0{]},~cellAddr{[}1{]},~0),~retStr)

/{*}~Gilt~fuer~Start~des~Makros~in~einer~Zelle~~{*}/

cell=ss\_coordinate@(cellAddr{[}0{]},~cellAddr{[}1{]},~0)

'cell=\char`\"{}A:E12\char`\"{}

new\_task@(\char`\"{}ss\_put\_cell@\char`\"{},~cell,~retStr)

return(retStr)

endmacro

/{*}~<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<~END~>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>{*}/



/{*}~<\,{}<\,{}<\,{}<~~getDate\_2\_Macro~>\,{}>\,{}>\,{}>\,{}>~{*}/

'~~~~~~~~~~~~~~-{}->~no~return~value:~returning~date~array~with~population

'~~~~~~~~~~~~~~~-{}->~~called~by~Buttons

'~~~~~~~~~~~~~~~-{}->~~no~input~parameter~possible

'~~~~~~~~~~~~~~~-{}->~~hard-coded~input-parameter'

'~~~~~~~~~~~~~~~-{}->~~hard~coded~named~range~for~result~population



Macro~getDate\_2\_macro()

var~format~ss\_cell\_~cellInfo

var~celladdr,~cell

var~date,~rowStart,~rowEnd,~col

var~k,~i

var~~offset,~someday

/{*}~Perparing~Web~Service~input~parameter~{*}/

cellAddr~=~ss\_extract\_range\_info@(\char`\"{}offset\_3\char`\"{})

cellInfo~=~ss\_get\_cell@(cellAddr{[}0{]},~cellAddr{[}1{]},~0)

'offset=cellInfo.display\_str~+~0

offset=cellInfo.value

cellAddr~=~ss\_extract\_range\_info@(\char`\"{}someday\_3\char`\"{})

rowStart=cellAddr{[}1{]}~

rowEnd=cellAddr{[}3{]}

col=cellAddr{[}2{]}

k=0

for~i=rowStart~to~rowEnd

~~~~~~~~cellInfo~=~ss\_get\_cell@(col,~i,~0)

~~~~~~~~someday{[}k{]}~=~\{cellInfo.value\}

~~~~~~~~'someday{[}k{]}=ss\_coordinate@(col,~i,~0)

~~~~~~~~'new\_task@(\char`\"{}ss\_put\_cell@\char`\"{},~cell,~date{[}k{]})

~~~~~~~~'ss\_put\_cell@(col,i,date{[}k{]})~~-{}->~not~working

~~~~~~~~k=k+1

next~i

'DUMP\_ARRAY@(someday)

/{*}~Web~Serviuce~call~{*}/

date~=~getDate\_2(offset,~someday)

/{*}~Result~Population~{*}/

cellAddr~=~ss\_extract\_range\_info@(\char`\"{}day\_1\char`\"{})

'~-{}->~not~possible~to~get~named~range~as~parameter~for~result~because

'~the~content~of~the~named~range~is~used~by~APPLIX~NOT~THE~COORDINATES

rowStart=cellAddr{[}1{]}~

rowEnd=cellAddr{[}3{]}

col=cellAddr{[}2{]}

k=0

for~i=rowStart~to~rowEnd~~~~~~~~

~~~~~~~~cell=ss\_coordinate@(col,~i,~0)

~~~~~~~~new\_task@(\char`\"{}ss\_put\_cell@\char`\"{},~cell,~date{[}k{]})

~~~~~~~~'ss\_put\_cell@(col,i,date{[}k{]})~~-{}->~not~working

~~~~~~~~k=k+1

next~i

/{*}

{*}~DUMP\_ARRAY@(retStruct)

{*}/

endmacro

/{*}~<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<~END~>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>{*}/



/{*}~<\,{}<\,{}<\,{}<~~getDate\_3\_Macro~>\,{}>\,{}>\,{}>\,{}>~{*}/

'~~~~~~~~~~~~~~-{}->~no~return~value:~returning~date~array~with~population

'~~~~~~~~~~~~~~~-{}->~~called~by~cells

'~~~~~~~~~~~~~~~-{}->~~input~parameter~for~WebService~call

'~~~~~~~~~~~~~~~-{}->~named~range~input-parameter~for~result~population

'

Macro~getDate\_3\_macro(offset,~someday,~day)

var~format~ss\_cell\_~cellInfo

var~celladdr,~cell

var~date,~rowStart,~rowEnd,~col

var~k,~i

/{*}~Preparation~Web~Service~input~parameter~not~necessary~-{}->~provided~by~call~{*}/

/{*}~Web~Service~call~{*}/

date~=~getDate\_2(offset,~someday)

/{*}~Result~Population~{*}/

'cellAddr~=~ss\_extract\_range\_info@(\char`\"{}day\char`\"{})

'~-{}->~hardcoded~if~no~parameter~is~allowed

cellAddr~=~ss\_extract\_range\_info@(day)

'~-{}->~not~possible~to~get~named~range~as~parameter~for~result~because~

'~the~content~of~the~named~range~is~used~by~APPLIX~NOT~THE~COORDINATES

rowStart=cellAddr{[}1{]}~

rowEnd=cellAddr{[}3{]}

col=cellAddr{[}2{]}

k=0

for~i=rowStart~to~rowEnd~~~~~~~~

~~~~~~~~cell=ss\_coordinate@(col,~i,~0)

~~~~~~~~new\_task@(\char`\"{}ss\_put\_cell@\char`\"{},~cell,~date{[}k{]})

~~~~~~~~'ss\_put\_cell@(col,i,date{[}k{]})~~-{}->~not~working

~~~~~~~~k=k+1

next~i

/{*}

{*}~DUMP\_ARRAY@(retStruct)

{*}/

endmacro

/{*}~<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<\,{}<~END~>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>\,{}>{*}/
\end{lyxcode}

\section{A document/literal service: The FinancialService}

The previous example services had in common that they used rpc/literal binding. While
this is WS-I-compliant, there is a tendency to propagate the usage of the document/literal
fashion. With rpc/literal, you might define types or elements to be used in the request
and response messages, in the \texttt{<types>} section. We did that for the DateService,
see section \ref{sub:The-DateService-WSDL}. You use these elements or types as arguments
or receive them as return value of the service call. They are {}``packed'' into
the request or the response tags in the actual SOAP message, as can be seen in the
sample client output in \ref{sub:A-Python-ZSI-client-DateService}.

The difference with document/literal binding is that the \emph{complete} message
inside \texttt{<SOAP-ENV:Body>} is described in the \texttt{<types>} section, as
an XML schema - not only the call parameters/return values. The big advantage is
obvious: Such a message can be XML Schema-validated. 

As it is quite possible with document/literal to leave the service method name out
of the request/response message at all, depending on your \texttt{<types>} definitions,
there can also be a downside to this. Because if you do so, it might be difficult
for the server implementation to dispatch correctly.%
\footnote{At least if dispatching does not rely on the SOAPAction header field.%
} To avoid this, we explicitly model the method name into our request, as a toplevel
element. This is called {}``document-wrapped'' style.

Most of the steps from WSDL to implementation should be familiar by now; we will
thus concentrate on the doc/literal differences and mainly present the (commented)
code. 


\subsection{The FinancialService WSDL}

The FinancialService is described in \texttt{FinancialService.wsdl}:

\begin{lyxcode}
<?xml~version=\char`\"{}1.0\char`\"{}?>

<definitions~name=\char`\"{}FinancialService\char`\"{}

~~targetNamespace=\char`\"{}http://dev-b.handel-dev.local:8080/FinancialService.wsdl\char`\"{}

~~xmlns:tns=\char`\"{}http://dev-b.handel-dev.local:8080/FinancialService.wsdl\char`\"{}

~~xmlns=\char`\"{}http://schemas.xmlsoap.org/wsdl/\char`\"{}

~~xmlns:soap=\char`\"{}http://schemas.xmlsoap.org/wsdl/soap/\char`\"{}

~~xmlns:finType=\char`\"{}http://dev-b.handel-dev.local:8080/FinancialService\_NS\char`\"{}

~~xmlns:xsd=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}

~~xmlns:wsdl=\char`\"{}http://schemas.xmlsoap.org/wsdl/\char`\"{}>



~~<types>

~~~~<schema~xmlns=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}

~~~~~~targetNamespace=\char`\"{}http://dev-b.handel-dev.local:8080/FinancialService\_NS\char`\"{}~>

~~~~~~<!-{}-~the~getPV~operation~request~message~content,~in~doc-wrapped~manner

~~~~~~~~(with~toplevel~element~that~explicitly~names~the~operation)~-{}->

~~~~~~<element~name=\char`\"{}getPV\char`\"{}>

~~~~~~~~<complexType>

~~~~~~~~~~<sequence>

~~~~~~~~~~~~<element~name=\char`\"{}irate\char`\"{}~type=\char`\"{}xsd:float\char`\"{}/>

~~~~~~~~~~~~<element~name=\char`\"{}CFSequence\char`\"{}>

~~~~~~~~~~~~~~<complexType>

~~~~~~~~~~~~~~~~<sequence>

~~~~~~~~~~~~~~~~~~<element~name=\char`\"{}CF\char`\"{}~minOccurs=\char`\"{}0\char`\"{}~maxOccurs=\char`\"{}unbounded\char`\"{}~type=\char`\"{}xsd:float\char`\"{}/>

~~~~~~~~~~~~~~~~</sequence>

~~~~~~~~~~~~~~</complexType>

~~~~~~~~~~~~</element>

~~~~~~~~~~</sequence>

~~~~~~~~</complexType>

~~~~~~</element>

~~~~~~<!-{}-~the~answer~to~the~getPV~operation~request~-{}->

~~~~~~<element~name=\char`\"{}PV\char`\"{}~type=\char`\"{}xsd:float\char`\"{}/>

~~~~</schema>

~~</types>



~~<message~name=\char`\"{}getPVRequest\char`\"{}>

~~~~<part~name=\char`\"{}msg\char`\"{}~element=\char`\"{}finType:getPV\char`\"{}/>

~~</message>



~~<message~name=\char`\"{}getPVResponse\char`\"{}>

~~~~<part~name=\char`\"{}msg\char`\"{}~element=\char`\"{}finType:PV\char`\"{}/>

~~</message>



~~<portType~name=\char`\"{}FinancialService\_PortType\char`\"{}>

~~~~<operation~name=\char`\"{}getPV\char`\"{}>

~~~~~~<input~message=\char`\"{}tns:getPVRequest\char`\"{}/>

~~~~~~<output~message=\char`\"{}tns:getPVResponse\char`\"{}/>

~~~~</operation>

~~</portType>



~~<binding~name=\char`\"{}FinancialService\_Binding\char`\"{}~type=\char`\"{}tns:FinancialService\_PortType\char`\"{}>

~~~~<soap:binding~style=\char`\"{}document\char`\"{}~transport=\char`\"{}http://schemas.xmlsoap.org/soap/http\char`\"{}/>

~~~~<operation~name=\char`\"{}getPV\char`\"{}>

~~~~~~<soap:operation~soapAction=\char`\"{}\char`\"{}/>

~~~~~~<input>

~~~~~~~~<soap:body~use=\char`\"{}literal\char`\"{}/>

~~~~~~</input>

~~~~~~<output>

~~~~~~~~<soap:body~use=\char`\"{}literal\char`\"{}/>

~~~~~~</output>

~~~~</operation>

~~</binding>



~~<service~name=\char`\"{}FinancialService\char`\"{}>

~~~~<documentation>Financial~Web~Service.~Methods:~-getPV(irate,~CFSequence):

Return~present~value~for~given~interest~rate~and~Cash~Flows.</documentation>

~~~~<port~name=\char`\"{}FinancialService\_Port\char`\"{}~binding=\char`\"{}tns:FinancialService\_Binding\char`\"{}>

~~~~~~<soap:address~location=\char`\"{}http://dev-b.handel-dev.local:8080/FinancialService\char`\"{}/>

~~~~</port>

~~</service>



</definitions>
\end{lyxcode}
Notes:

\begin{itemize}
\item The FinancialService´s getPV operation returns the net present value for a given
interest rate $r$ and a series of cash flows. It uses document/literal binding,
so the full ingoing and outgoing message structure is defined in the WSDL \texttt{<types>}
section.
\item The \texttt{soapAction} attribute is empty (\texttt{<soap:operation soapAction=\char`\"{}\char`\"{}/>}).
This means the server will have to use a different way to dispatch to the method
implementation.
\end{itemize}

\subsection{A Python ZSI FinancialService server}


\subsubsection{Code generation from WSDL}

\begin{enumerate}
\item \texttt{wsdl2py}:

\begin{lyxcode}
\$~/apps/pydev/bin/wsdl2py~-f~FinancialService.wsdl

==>~FinancialService\_services.py

==>~FinancialService\_services\_types.py
\end{lyxcode}
\item \texttt{wsdl2dispatch:}

\begin{lyxcode}
/apps/pydev/bin/wsdl2dispatch~-f~FinancialService.wsdl

==>~FinancialService\_services\_server.py
\end{lyxcode}
\end{enumerate}

\subsubsection{The DateService web server}

As mentioned above, the server implementation will need to use a different dispatch
mechanism due to the lacking \texttt{soapAction} specification. Therefore, the do\_POST
method of the standard ZSI.ServiceContainer has been modified:

\begin{lyxcode}
\#!/apps/pydev/bin/python2.3



\_\_doc\_\_~=~\char`\"{}\char`\"{}\char`\"{}

~~~This~module~started~out~from~the~ZSI.ServiceContainer~implementation,~but

~~~uses~a~different~approach~to~address~the~service~methods~(which~is~actually

~~~more~like~in~the~ZSI.dispatch~module).~In~the~ZSI.ServiceContainer~module

~~~service~method~('action'),~look-up~is~based~on~the~SOAPAction~SOAP~header

~~~field.~As~this~field~is~not~set~by~most~clients~(not~even~by~standard~ZSI

~~~clients~used~in~the~ServiceProxy~class~and~of~course~not~by~Excel~XP

~~~clients),~this~had~to~be~changed.

~~~Update:~If~your~WSDL~file~features~the~<soap:operation~soapAction=.../>~tags

~~~in~its~bindings~sections,~then~the~ZSI.ServiceContainer~approach~actually

~~~does~work.~In~this~case,~a~client~using~ZSI.ServiceProxy~will~set~the

~~~SOAPAction~header~field.~Hmm,~do~not~know~yet~about~Excel...

~~~Workflow~is~as~follows:

~~~-~the~server~(ZSI.ServiceContainer)~dispatches~the~incoming~HTTP~connections

~~~~~to~the~request~handler~(MySOAPRequestHandler)

~~~-~the~request~handler~implements~methods~for~GET~(return~the~service~WSDL)~and

~~~POST~(dispatch~the~apppropriate~service)

~~~-~the~\_Dispatch~function~delegates~service~invocation~to~the~ServiceContainer

~~~-~ServiceContainer~looks~up~the~service~and~invokes~the~service~method~(=action)

~~~-~the~service~which~inherits~from~ServiceSOAPBinding~returns~the~answer~message

~~~that~is~then~sent~back~by~the~\_Dispatch~function

~~~Personally~I~think~the~workflow~is~a~bit~strange~(why~does~the~server~invoke

~~~the~service,~not~the~service~request~handler,~why~separate~the~dispatch~into~the

~~~\_Dispach~function),~but~that~is~the~way~it~is~done~in~the~ZSI~example.

\char`\"{}\char`\"{}\char`\"{}



import~getopt

import~os

import~sys

import~cStringIO~as~StringIO



from~ZSI~import~ParseException,~FaultFromException

from~ZSI~import~\_copyright,~\_seqtypes,~resolvers

from~ZSI.parse~import~ParsedSoap

from~ZSI.writer~import~SoapWriter

from~ZSI.dispatch~import~SOAPRequestHandler~as~BaseSOAPRequestHandler

from~ZSI.ServiceContainer~import~ServiceContainer

from~ZSI.ServiceContainer~import~PostNotSpecified

from~ZSI.wstools.WSDLTools~import~WSDLReader

from~FinancialService\_services\_server~import~FinancialService





\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

\#~default~configuration

\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

port~=~8080

host~=~'http://dev-b.handel-dev.local'





\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

\#~command~line~parsing

\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

def~usage(rcode=1):

~~~~print~\char`\"{}usage:~./myDateServer.py~-{}-port=,-c<port>~{[}-{}-help,~-h{]}\char`\"{}

~~~~sys.exit(rcode)

try:

~~~~optlist,~args~=~getopt.getopt(sys.argv{[}1:{]},~\char`\"{}hp:\char`\"{},~{[}'help',~'port='{]})

except~getopt.GetoptError:

~~~~usage()

for~opt,~arg~in~optlist:

~~~~if~opt~in~{[}\char`\"{}-h\char`\"{},~\char`\"{}-{}-help\char`\"{}{]}:

~~~~~~~~usage(0)

~~~~elif~opt~in~{[}\char`\"{}-p\char`\"{},~\char`\"{}-{}-port\char`\"{}{]}:

~~~~~~~~port~=~int(arg)

~~~~~~~~continue





\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

\#~module~code

\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

class~MySOAPRequestHandler(BaseSOAPRequestHandler):

~~~~\char`\"{}\char`\"{}\char`\"{}SOAP~handler.

~~~~Dispatching~is~delegated~to~the~\_Dispatch~function~which~wants~a~post

~~~~and~an~action~attribute~to~specify~the~service~object~and~a~service~method.

~~~~Post~is~determined~using~the~self.path~attribute~inherited~from

~~~~BaseHTTPRequestHandler,~containing~the~incoming~request~path.~Action~is~taken

~~~~from~body~root~element~of~the~parsed~SOAP~message,~similar~to~what~is~done

~~~~in~the~ZSI.dispatch~module.

~~~~\char`\"{}\char`\"{}\char`\"{}



~~~~def~do\_POST(self):

~~~~~~~~'''The~POST~command.

~~~~~~~~'''

\#\#~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>\,{}>~\%s.do\_POST\char`\"{}~\%~self

\#\#~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>\,{}>~\%s.path:~\%s\char`\"{}~\%~(self,~self.path)

\#\#~~~~~~~~print~\char`\"{}\%s.headers:\char`\"{}~\%~self

\#\#~~~~~~~~print~self.headers

~~~~~~~~\#~SOAPAction~is~a~SOAP~header~field.~Should~read~the~SOAP~specs...

~~~~~~~~\#~We~strip~off~the~quotation~marks.~Why~ZSI~puts~them~in~anyway

~~~~~~~~\#~is~not~clear~to~me~(gSOAP~does~not,~same~as~VB~WSR~toolkit).

~~~~~~~~soapAction~=~self.headers.getheader('SOAPAction').strip('\textbackslash{}'\char`\"{}')

~~~~~~~~action~=~soapAction

~~~~~~~~post~=~self.path

~~~~~~~~if~not~post:

~~~~~~~~~~~~raise~PostNotSpecified,~'HTTP~POST~not~specified~in~request'

~~~~~~~~post~=~post.strip('\textbackslash{}'\char`\"{}')

~~~~~~~~try:

~~~~~~~~~~~~ct~=~self.headers{[}'content-type'{]}

~~~~~~~~~~~~if~ct.startswith('multipart/'):

~~~~~~~~~~~~~~~~cid~=~resolvers.MIMEResolver(ct,~self.rfile)

~~~~~~~~~~~~~~~~xml~=~cid.GetSOAPPart()

~~~~~~~~~~~~~~~~ps~=~ParsedSoap(xml,~resolver=cid.Resolve)

~~~~~~~~~~~~else:

~~~~~~~~~~~~~~~~length~=~int(self.headers{[}'content-length'{]})

~~~~~~~~~~~~~~~~payload~=~self.rfile.read(length)

~~~~~~~~~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>~Request~message:\char`\"{}

~~~~~~~~~~~~~~~~print~payload

~~~~~~~~~~~~~~~~ps~=~ParsedSoap(payload)

~~~~~~~~except~ParseException,~e:

~~~~~~~~~~~~self.send\_fault(FaultFromZSIException(e))

~~~~~~~~except~Exception,~e:

~~~~~~~~~~~~\#~Faulted~while~processing;~assume~it's~in~the~header.

~~~~~~~~~~~~self.send\_fault(FaultFromException(e,~1,~sys.exc\_info(){[}2{]}))

~~~~~~~~else:

~~~~~~~~~~~~\#~Take~the~action~from~the~parsed~SOAP~body~root~element

\#\#~~~~~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>~post~=\char`\"{},~post

\#\#~~~~~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>~action~=\char`\"{},~ps.body\_root.localName

\#\#~~~~~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>~namespaceURI~=\char`\"{},~ps.body\_root.namespaceURI

\#\#~~~~~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>~ps.body\_root~=\char`\"{},~ps.body\_root.\_\_dict\_\_

\#\#~~~~~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>~ps.GetElementNSdict:\char`\"{},~ps.GetElementNSdict(ps.body\_root)

~~~~~~~~~~~~\#~This~time,~we~try~to~dispatch~the~actual~worker~methods~with~a~fully

~~~~~~~~~~~~\#~namespace-qualified~name...

~~~~~~~~~~~~\#~...~but~only~if~SOAPAction~was~not~given...

~~~~~~~~~~~~\#~Trying~to~leave~soapAction~attribute~out~of~the~wsdl~completely~lead

~~~~~~~~~~~~\#~ZSI~to~put~a~SOAPAction~of~\char`\"{}None\char`\"{}~into~the~header,~as~a~string.

~~~~~~~~~~~~\#~Should~probably~better~be~left~empty~in~this~case.

~~~~~~~~~~~~if~not~action~or~action~==~\char`\"{}None\char`\"{}:

~~~~~~~~~~~~~~~~if~ps.body\_root.namespaceURI:

~~~~~~~~~~~~~~~~~~~~action~=~ps.body\_root.namespaceURI~+~':'~+~ps.body\_root.localName

~~~~~~~~~~~~~~~~else:

~~~~~~~~~~~~~~~~~~~~action~=~ps.body\_root.localName

~~~~~~~~~~~~\_Dispatch(ps,~self.server,~self.send\_xml,~self.send\_fault,

~~~~~~~~~~~~~~~~post=post,~action=action)



~~~~def~do\_GET(self):

~~~~~~~~\char`\"{}\char`\"{}\char`\"{}Return~the~WSDL~file.~We~expect~one~WSDL~file~per~service,

~~~~~~~~and~the~file~path~is~determined~by~the~incoming~HTTP~GET~request

~~~~~~~~path.~Thus,~if~you~want~to~use~the~service~from~Excel~XP,~you

~~~~~~~~have~to~add~the~service~name~to~the~service~address,~e.g.:

~~~~~~~~http://dev-b.handel-dev.local:8080/FinancialService

~~~~~~~~\char`\"{}\char`\"{}\char`\"{}

\#\#~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>\,{}>~\%s.do\_GET\char`\"{}~\%~self

\#\#~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>\,{}>~\%s.path:~\%s\char`\"{}~\%~(self,~self.path)

~~~~~~~~wsdlfile~=~os.path.join('.',~self.path.replace('/',~\char`\"{}\char`\"{},~1)~+~\char`\"{}.wsdl\char`\"{})

\#\#~~~~~~~~print~\char`\"{}>\,{}>\,{}>\,{}>\,{}>~using~wsdlfile\char`\"{},~wsdlfile

~~~~~~~~wsdl~=~open(wsdlfile).read()

~~~~~~~~self.send\_xml(wsdl)



def~\_Dispatch(ps,~server,~SendResponse,~SendFault,~post,~action,~nsdict=\{\},~{*}{*}kw):

~~~~\char`\"{}\char`\"{}\char`\"{}Send~ParsedSoap~instance~to~ServiceContainer,~which~dispatches~to

~~~~appropriate~service~via~post,~and~method~via~action.~~Response~is~a

~~~~self-describing~pyobj,~which~is~passed~to~a~SoapWriter.

~~~~Call~SendResponse~or~SendFault~to~send~the~reply~back,~appropriately.

~~~~~~~~server~-{}-~ServiceContainer~instance

~~~~\char`\"{}\char`\"{}\char`\"{}

~~~~try:

~~~~~~~~result~=~server(ps,~post,~action)

~~~~except~Exception,~e:

~~~~~~~~return~SendFault(FaultFromException(e,~0,~sys.exc\_info(){[}2{]}),~{*}{*}kw)

~~~~if~result~==~None:

~~~~~~~~return

~~~~reply~=~StringIO.StringIO()

~~~~try:

~~~~~~~~SoapWriter(reply,~nsdict=nsdict).serialize(result)

~~~~~~~~return~SendResponse(reply.getvalue(),~{*}{*}kw)

~~~~except~Exception,~e:

~~~~~~~~return~SendFault(FaultFromException(e,~0,~sys.exc\_info(){[}2{]}),~{*}{*}kw)





def~AsServer(port=80,~services=()):

~~~~'''port~-{}-

~~~~~~~services~-{}-~list~of~service~instances

~~~~'''

~~~~address~=~('',~port)

~~~~sc~=~ServiceContainer(address,~RequestHandlerClass=MySOAPRequestHandler)

~~~~for~service~in~services:

~~~~~~~~path~=~service.getPost()

~~~~~~~~sc.setNode(service,~path)

~~~~sc.serve\_forever()





\#~Put~the~service~classes~you~want~to~expose~in~here.

\#~We~expect~one~WSDL~file~for~each~service,~and~only~one~port~defined

\#~for~the~service.

expose\_services~=~{[}

~~~~FinancialService,

~~~~{]}



service\_instances~=~{[}{]}



for~serviceclass~in~expose\_services:

~~~~service\_instances.append(serviceclass())



AsServer(port,~service\_instances)
\end{lyxcode}
This code should be pretty self-explanatory. The modified do\_POST method will now
use the namespace-qualified toplevel element as dispatch action, if no SOAPAction
HTTP header field was given (which won´t be the case due to our WSDL file). Apart
from that, it is very similar to the server implementation in section \ref{sub:SquareService-web-server}.


\subsubsection{The FinancialService implementation}

Once again, the implentation is hooked into the \texttt{<...>\_services\_server.py}
skeleton. This time, the generated \texttt{soapAction} dictionary is empty. We add
the \texttt{'<ns>:<operation>'} key here that maps to the \texttt{soap\_getPV} method:

\begin{lyxcode}
from~FinancialService\_services~import~{*}

from~ZSI.ServiceContainer~import~ServiceSOAPBinding



class~FinancialService(ServiceSOAPBinding):

~~~~soapAction~=~\{

~~~~~~~~\#~This~would~be~used~if~soapAction~was~specified~in~WSDL

~~~~~~~~'urn:FinancialService/getPV':~'soap\_getPV',

~~~~~~~~\#~If~no~soapAction~is~in~WSDL,~we~dispatch~using~the~root~element~name

~~~~~~~~\#~(namespace-qualified)

~~~~~~~~'http://dev-b.handel-dev.local:8080/FinancialService\_NS:getPV':~'soap\_getPV',

~~~~~~~~\}



~~~~def~\_\_init\_\_(self,~post='/FinancialService',~{*}{*}kw):

~~~~~~~~ServiceSOAPBinding.\_\_init\_\_(self,~post)



~~~~def~soap\_getPV(self,~ps):

~~~~~~~~\#~input~vals~in~request~object

~~~~~~~~args~=~ps.Parse(~getPVRequestWrapper()~)



~~~~~~~~\#~Worker~code:~Actual~present~value~calculation

~~~~~~~~t~=~0

~~~~~~~~PV~=~0.0

~~~~~~~~for~CF~in~args.\_CFSequence.\_CF:

~~~~~~~~~~~~PV~+=~(CF~or~0.0)~{*}~((args.\_irate~/~100.0~+~1)~{*}{*}~(-t))~

~~~~~~~~~~~~t~+=~1

~~~~~~~~print~\char`\"{}Present~value~is:~\char`\"{},~PV



~~~~~~~~\#~assign~return~values~to~response~object

~~~~~~~~class~SimpleTypeWrapper(float):~typecode~=~getPVResponseWrapper()



~~~~~~~~\#~WARNING~specify~value~eg.~SimpleTypeWrapper(1)

~~~~~~~~response~=~SimpleTypeWrapper(PV)

~~~~~~~~return~response
\end{lyxcode}
The request message fields are accessed through \texttt{args}, which is a \texttt{FinancialService\_services.getPVRequestWrapper}
instance, in the same {}``\_<name>''-syntax as before.

\begin{lyxcode}

\end{lyxcode}

\subsection{A Python ZSI client for the FinancialService}

We use the generated stub code in the client implementation \texttt{myClient\_FinancialService.py}:

\begin{lyxcode}
\#!/apps/pydev/bin/python2.3



import~sys

import~getopt

import~ZSI.wstools.WSDLTools



from~FinancialService\_services~import~{*}





\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

\#~default~configuration

\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

port~=~8080

host~=~'dev-b'





\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

\#~command~line~parsing

\#-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-{}-

def~usage(rcode=1):

~~~~print~\char`\"{}usage:~myClient\_FinancialService.py~{[}-{}-host=<hostname>~-{}-port=,-c<port>~-{}-help,~-h{]}\char`\"{}

~~~~sys.exit(rcode)

try:

~~~~optlist,~args~=~getopt.getopt(sys.argv{[}1:{]},~\char`\"{}hp:\char`\"{},~{[}'help',~'port='{]})

except~getopt.GetoptError:

~~~~usage()

for~opt,~arg~in~optlist:

~~~~print~opt,~arg

~~~~if~opt~in~{[}\char`\"{}-h\char`\"{},~\char`\"{}-{}-help\char`\"{}{]}:

~~~~~~~~usage(0)

~~~~elif~opt~in~{[}\char`\"{}-{}-host\char`\"{}{]}:

~~~~~~~~host~=~arg

~~~~~~~~continue

~~~~elif~opt~in~{[}\char`\"{}-p\char`\"{},~\char`\"{}-{}-port\char`\"{}{]}:

~~~~~~~~port~=~int(arg)

~~~~~~~~continue

~~~~

url~=~'http://'~+~host~+~':'~+~str(port)~+~'/FinancialService'



service~=~FinancialServiceLocator().getFinancialService\_PortType(tracefile=sys.stdout)



print~'\textbackslash{}nAccessing~service~FinancialService,~method~getPV...'

while~1:

~~~~\#~Must~use~keyword~arguments~if~use\_wsdl~was~set

~~~~irate~=~None

~~~~while~not~(0.0~<=~irate~<=~100.0):

~~~~~~~~try:

~~~~~~~~~~~~irate~=~float(raw\_input(\char`\"{}Enter~interest~rate~in~percent:~\char`\"{}))

~~~~~~~~except~ValueError,~e:

~~~~~~~~~~~~print~e

~~~~CFSequence~=~{[}{]}

~~~~period~=~0

~~~~while~1:

~~~~~~~~try:

~~~~~~~~~~~~CFSequence.append(float(raw\_input(\char`\"{}Enter~CF(t=\%s)~{[}Ctrl-C~to~end{]}:~\char`\"{}~\%~(period,))))

~~~~~~~~~~~~period~+=~1

~~~~~~~~except~ValueError,~e:

~~~~~~~~~~~~print~e

~~~~~~~~except~KeyboardInterrupt:

~~~~~~~~~~~~print~\char`\"{}...done.\char`\"{}

~~~~~~~~~~~~break



~~~~print~\char`\"{}CF~sequence~is:\char`\"{},~CFSequence

~~~~print~\char`\"{}Calculation~interest~rate~is:\char`\"{},~irate



~~~~getPV~=~getPVRequestWrapper()

~~~~\#print~\char`\"{}getPV\char`\"{},~getPV

~~~~\#print~\char`\"{}getPV.\_\_dict\_\_\char`\"{},~getPV.\_\_dict\_\_



~~~~getPV.\_irate~=~irate

~~~~class~CFSequence\_class:

~~~~~~~~\_CF~=~CFSequence



~~~~getPV.\_CFSequence~=~CFSequence\_class

~~~~

~~~~\#print~\char`\"{}getPV\char`\"{},~getPV

~~~~\#print~\char`\"{}getPV.\_\_dict\_\_\char`\"{},~getPV.\_\_dict\_\_

~~~~result~=~service.getPV(getPV)

~~~~print~'result:',~result
\end{lyxcode}
After the necessary data has been read from the user, the appropriate attributes
of the \texttt{getPVRequestWrapper} instance are set. To model the sequence of cash
flow elements, the local class \texttt{CFSequence\_class} is used. This class is
{}``structurally equivalent'' to the XML Schema \texttt{CFSequence} complexType
as defined in the WSDL. ZSI then handles all the type mapping and serialization issues
for us.

Sample client session output:

\begin{lyxcode}
Accessing~service~FinancialService,~method~getPV...

Enter~interest~rate~in~percent:~4

Enter~CF~(t=0):~-100

Enter~CF~(t=1):~5

Enter~CF~(t=2):~5

Enter~CF~(t=3):~105

Enter~CF~(t=4):~\textasciicircum{}C...done.

CF~sequence~is:~{[}-100.0,~5.0,~5.0,~105.0{]}

Calculation~interest~rate~is:~4.0



\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_~Wed~Jul~20~15:39:14~2005~REQUEST:

<?xml~version=\char`\"{}1.0\char`\"{}~encoding=\char`\"{}utf-8\char`\"{}?>

<SOAP-ENV:Envelope

~~xmlns:SOAP-ENV=\char`\"{}http://schemas.xmlsoap.org/soap/envelope/\char`\"{}

~~xmlns:SOAP-ENC=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}

~~xmlns:xsi=\char`\"{}http://www.w3.org/2001/XMLSchema-instance\char`\"{}

~~xmlns:xsd=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}

~~xmlns:ZSI=\char`\"{}http://www.zolera.com/schemas/ZSI/\char`\"{}

~~SOAP-ENV:encodingStyle=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}~>

<SOAP-ENV:Body>

<getPV~xmlns=\char`\"{}http://dev-b.handel-dev.local:8080/FinancialService\_NS\char`\"{}>

<irate~xsi:type=\char`\"{}xsd:float\char`\"{}>4.000000</irate>

<CFSequence~xmlns=\char`\"{}http://dev-b.handel-dev.local:8080/FinancialService\_NS\char`\"{}>

<CF~xsi:type=\char`\"{}xsd:float\char`\"{}>-100.000000</CF>

<CF~xsi:type=\char`\"{}xsd:float\char`\"{}>5.000000</CF>

<CF~xsi:type=\char`\"{}xsd:float\char`\"{}>5.000000</CF>

<CF~xsi:type=\char`\"{}xsd:float\char`\"{}>105.000000</CF>

</CFSequence>

</getPV>

</SOAP-ENV:Body>

</SOAP-ENV:Envelope>

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_~Wed~Jul~20~15:39:15~2005~RESPONSE:

Server:~ZSI/1.1~BaseHTTP/0.3~Python/2.3.4

Date:~Wed,~20~Jul~2005~13:39:14~GMT

Content-type:~text/xml;~charset=\char`\"{}utf-8\char`\"{}

Content-Length:~560

<?xml~version=\char`\"{}1.0\char`\"{}~encoding=\char`\"{}utf-8\char`\"{}?>

<SOAP-ENV:Envelope

~~xmlns:SOAP-ENV=\char`\"{}http://schemas.xmlsoap.org/soap/envelope/\char`\"{}

~~xmlns:SOAP-ENC=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}

~~xmlns:xsi=\char`\"{}http://www.w3.org/2001/XMLSchema-instance\char`\"{}

~~xmlns:xsd=\char`\"{}http://www.w3.org/2001/XMLSchema\char`\"{}

~~xmlns:ZSI=\char`\"{}http://www.zolera.com/schemas/ZSI/\char`\"{}

~~SOAP-ENV:encodingStyle=\char`\"{}http://schemas.xmlsoap.org/soap/encoding/\char`\"{}~>

<SOAP-ENV:Body>

<PV~xmlns=\char`\"{}http://dev-b.handel-dev.local:8080/FinancialService\_NS\char`\"{}~

xsi:type=\char`\"{}xsd:float\char`\"{}>2.775091</PV>

</SOAP-ENV:Body>

</SOAP-ENV:Envelope>

result:~2.775091
\end{lyxcode}

\subsection{An Excel XP VB client for the FinancialService}


\subsubsection{VB FinancialService stub generation}

Refer to \ref{sub:VB-stub-generation-square} for details. The URL to receive the
WSDL description is {}``http://dev-b.handel-dev.local:8080/FinancialService'' for
this example.


\subsubsection{VB FinancialService client implementation \& spreadsheet access}

Insert the following code (Insert->Module...):

\begin{lyxcode}
Public~Function~getPV(ByRef~irate~As~Double,~ByRef~CFs~As~Range)~As~Single

~~~~

~~~~Dim~xml\_getPV~As~MSXML2.IXMLDOMNodeList

~~~~

~~~~Set~xml\_document~=~CreateObject(\char`\"{}Microsoft.XMLDOM\char`\"{})

~~~~Dim~xml\_root~As~MSXML2.IXMLDOMNode

~~~~Set~xml\_root~=~xml\_document.createElement(\char`\"{}getPV\char`\"{})

~~~~xml\_document.appendChild~xml\_root

~~~~

~~~~Dim~irateNode~As~IXMLDOMNode

~~~~Set~irateNode~=~xml\_document.createElement(\char`\"{}irate\char`\"{})

~~~~Dim~irateVar~As~Variant

~~~~irateVar~=~irate

~~~~irateNode.nodeTypedValue~=~irate

~~~~xml\_root.appendChild~irateNode

~~~~

~~~~Dim~CFSeqNode~As~IXMLDOMNode

~~~~Set~CFSeqNode~=~xml\_document.createElement(\char`\"{}CFSequence\char`\"{})

~~~~xml\_root.appendChild~CFSeqNode

~~~~

~~~~Dim~CFNode~As~IXMLDOMNode

~~~~For~Each~cf~In~CFs

~~~~~~Set~CFNode~=~xml\_document.createElement(\char`\"{}CF\char`\"{})

~~~~~~CFNode.Text~=~cf.Value

~~~~~~CFSeqNode.appendChild~CFNode

~~~~Next~cf

~~~~

~~~~'Set~xml\_getPV~=~xml\_document.getElementsByTagName(\char`\"{}getPV\char`\"{})

~~~~Set~xml\_getPV~=~xml\_document.getElementsByTagName(\char`\"{}getPV/{*}\char`\"{})

~~~~

~~~~Dim~myFinancialService~As~New~clsws\_FinancialService

~~~~getPV~=~myFinancialService.wsm\_getPV(xml\_getPV)

~~~~

~~~~

End~Function
\end{lyxcode}
This implements the function \texttt{getPV} that can be invoked from within a spreadsheet.
It expects the interest rate and a range of cells (containing the cash flows) as
input parameters. As opposed to the previous rpc/literal examples, the generated
VB client stubs expect us to build up the DOM structure for the request message on
our own this time. The function does so and calls the \texttt{wsm\_getPV} method
of the \texttt{clsws\_FinancialService} object - the {}``service proxy'' instance
of the actual web service. The resulting return value of the web service - the net
present value of the cash flows - is then given back to the caller.


\subsection{A gSOAP C++ client for the FinancialService}


\subsubsection{Code generation from WSDL}

\begin{enumerate}
\item Header:

\begin{lyxcode}
\$~/apps/pydev/bin/wsdl2h~-o~financialService.h~

http://dev-b.handel-dev.local:8080/FinancialService

{*}{*}~~The~gSOAP~WSDL~parser~for~C~and~C++~1.2.0

{*}{*}~~Copyright~(C)~2000-2005~Robert~van~Engelen,~Genivia~Inc.

{*}{*}~~All~Rights~Reserved.~This~product~is~provided~\char`\"{}as~is\char`\"{},~without~any~warranty.

{*}{*}~~The~gSOAP~WSDL~parser~is~released~under~one~of~the~following~two~licenses:

{*}{*}~~GPL~or~the~commercial~license~by~Genivia~Inc.~Use~option~-l~for~more~info.

Saving~financialService.h

Connecting~to~'http://dev-b.handel-dev.local:8080/FinancialService'~

to~retrieve~WSDL...~done

Cannot~open~file~'typemap.dat'

Problem~reading~type~map~file~typemap.dat.

Using~internal~type~definitions~for~C++~instead.

To~complete~the~process,~compile~with:

soapcpp2~financialService.h


\end{lyxcode}
\item Stub code:

\begin{lyxcode}
\$~/apps/pydev/bin/soapcpp2~-I~/data/pydev/DOWNLOADS/gsoap-2.7/soapcpp2/~

financialService.h

{*}{*}~~The~gSOAP~Stub~and~Skeleton~Compiler~for~C~and~C++~2.7.1

{*}{*}~~Copyright~(C)~2000-2005,~Robert~van~Engelen,~Genivia~Inc.

{*}{*}~~All~Rights~Reserved.~This~product~is~provided~\char`\"{}as~is\char`\"{},~without~any~warranty.

{*}{*}~~The~gSOAP~compiler~is~released~under~one~of~the~following~three~licenses:

{*}{*}~~GPL,~the~gSOAP~public~license,~or~the~commercial~license~by~Genivia~Inc.

{*}{*}WARNING{*}{*}:~anonymous~struct~will~be~named~'\_Struct\_1'~(detected~at~line~73~in

financialService.h)

Saving~soapStub.h

Saving~soapH.h

Saving~soapC.cpp

Saving~soapClient.cpp

Saving~soapServer.cpp

Saving~soapClientLib.cpp

Saving~soapServerLib.cpp

Using~ns1~service~name:~FinancialService\_USCOREBinding

Using~ns1~service~style:~document

Using~ns1~service~encoding:~literal

Using~ns1~service~location:~http://dev-b.handel-dev.local:8080/FinancialService

Using~ns1~schema~namespace:~http://dev-b.handel-dev.local:8080/FinancialService.wsdl

Saving~soapFinancialService\_USCOREBindingProxy.h~client~proxy

Saving~soapFinancialService\_USCOREBindingObject.h~server~object

Saving~FinancialService\_USCOREBinding.getPV.req.xml~sample~SOAP/XML~request

Saving~FinancialService\_USCOREBinding.getPV.res.xml~sample~SOAP/XML~response

Saving~FinancialService\_USCOREBinding.nsmap~namespace~mapping~table

Compilation~successful~(1~warning)
\end{lyxcode}
\end{enumerate}

\subsubsection{Client implementation}

\begin{lyxcode}
\#include~\char`\"{}soapFinancialService\_USCOREBindingProxy.h\char`\"{}

\#include~\char`\"{}FinancialService\_USCOREBinding.nsmap\char`\"{}

int~main()

\{

~~~~FinancialService~fs;

~~~~\_ns2\_\_getPV~getPV;

~~~~float~PV;

~~~~float~irate;

~~~~float~CFval;

~~~~std::string~input;

~~~~while~(1)~\{

~~~~~~~~std::cout~<\,{}<~\char`\"{}Enter~interest~rate~in~\%:~\char`\"{};

~~~~~~~~std::cin~>\,{}>~irate;

~~~~~~~~std::vector<float>~CF;

~~~~~~~~for~(int~t=0;;~t++)~\{

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}Enter~CF(t=\char`\"{}~<\,{}<~t~<\,{}<~\char`\"{}){[}e~to~exit{]}:~\char`\"{};

~~~~~~~~~~~~std::cin~>\,{}>~input;

~~~~~~~~~~~~if~(input~!=~\char`\"{}e\char`\"{})~\{

~~~~~~~~~~~~~~~~CFval~=~atof(input.c\_str());

~~~~~~~~~~~~~~~~CF.push\_back(CFval);

~~~~~~~~~~~~\}~else~\{

~~~~~~~~~~~~~~~~break;

~~~~~~~~~~~~\}

~~~~~~~~\}

~~~~~~~~getPV.irate~=~irate;

~~~~~~~~getPV.CFSequence.CF~=~CF;

~~~~~~~~if~(fs.\_\_ns1\_\_getPV(\&getPV,~PV)~==~SOAP\_OK)~\{

~~~~~~~~~~~~std::cout~<\,{}<~\char`\"{}PV=\char`\"{}~<\,{}<~PV~<\,{}<~endl;

~~~~~~~~\}~else

~~~~~~~~~~~~soap\_print\_fault(fs.soap,~stderr);

~~~~\}

\}
\end{lyxcode}

\subsubsection{gSOAP Client compilation}


\paragraph{gcc 2.95.2}

\begin{lyxcode}
g++~-o~myClient~-R/apps/prod/lib~~-I/apps/pydev/include~-L/apps/pydev/lib~

soapC.cpp~soapClient.cpp~myClient\_use\_proxy.cpp~-lgsoap++~-lsocket
\end{lyxcode}

\paragraph{gcc 3.4.3}

\begin{lyxcode}
/apps/pydev/gcc/3.4.3/bin/g++~-o~myClient\_use\_proxy~-I/apps/pydev/include~

-L/apps/pydev/gcc/3.4.3/lib~-R~/apps/pydev/gcc/3.4.3/lib~

myClient\_use\_proxy.cpp~soapC.cpp~soapClient.cpp~-lsocket~-lgsoap++~-lnsl
\end{lyxcode}

\section{Aftertoughts}

\cite{whichWSDL} states that one of the advantages of {}``literal'' binding is
a reduced SOAP message payload, as unnecessary type information can be left out.
This type information is not needed any more, as it is specified in the WSDL and
thus known to both service producer and consumer. A closer look at the messages that
ZSI produces, however, shows that the \texttt{xsi:type=''...''} attributes are
packed into the SOAP message anyway (e.g. sample session output in section \ref{sub:ZSI-SquareService-client}).
While you can set an attribute \texttt{typed=0} for the typecode information, it
remains unclear if you have to do that for every single message element.

Example: A modified SquareService implementation:

\begin{lyxcode}
~~~~~~~~...

~~~~~~~~\#~>\,{}>\,{}>~ADDED~MANUALLY

~~~~~~~~\#~Here~we~hook~in~the~actual~worker~method

~~~~~~~~response.\_return~=~self.getSquare(args.\_x)

~~~~~~~~\#~<\,{}<\,{}<

~~~~~~~~response.typecode.typed~=~0

~~~~~~~~response.typecode.ofwhat{[}0{]}.typed~=~0

~~~~~~~~return~response

~~~~~~~~....
\end{lyxcode}
\appendix

\section{ZSI 1.6.1 patches\label{sec:ZSI-1.6.1-patches}}

The following patches to ZSI 1.6.1 made all the examples {}``just work'' for me.
One would have to read up on/know the specs to decide if they are actually correct;
I guess this is up to the ZSI specialists.

\begin{description}
\item [wsdl2python.py.patch](based on revision: \# \$Id: wsdl2python.py,v 1.69 2004/11/30
00:28:38 boverhof Exp \$)

\begin{itemize}
\item Fixes the problem that namespaces are not put into the generated code for rpc/literal
and document/literal. Note that ZSI clients seem not to care too much about these
issues, but a gSOAP client will not accept the answer of a ZSI-based server if the
namespace is not correct.
\item For doc/literal, adds xmlns=\char`\"{}..\char`\"{} to top level simple elements
\end{itemize}
Code:

\begin{minipage}[c]{1.0\columnwidth}%
\begin{lyxcode}
{\tiny 775,776c775,777}{\tiny \par}

{\tiny <~~~~~~~~~~~~~~~~~~~~~namespace~=~''}{\tiny \par}

{\tiny <~~~~~~~~~~~~~~~self.typecode~+=~'\textbackslash{}n\%s\%s.typecode~=~Struct(\%s,{[}\%s{]},~pname=name,~aname=\char`\"{}\_\%\%s\char`\"{}~\%\%~name,~oname=\char`\"{}\%\%s~~xmlns=\textbackslash{}\textbackslash{}\char`\"{}\%s\textbackslash{}\textbackslash{}\char`\"{}\char`\"{}~\%\%~name~)'\textbackslash{}}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~~~~~~~~~~~~~if~namespace:}{\tiny \par}

{\tiny >~~~~~~~~~~~~~~~~~~~~~~~~~namespace~=~\char`\"{}'\char`\"{}~+~namespace~+~\char`\"{}'\char`\"{}}{\tiny \par}

{\tiny >~~~~~~~~~~~~~~~self.typecode~+=~'\textbackslash{}n\%s\%s.typecode~=~Struct(\%s,{[}\%s{]},~pname=name,~aname=\char`\"{}\_\%\%s\char`\"{}~\%\%~name,~oname=\char`\"{}\%\%s~xmlns=\textbackslash{}\textbackslash{}\char`\"{}\%\%s\textbackslash{}\textbackslash{}\char`\"{}\char`\"{}~\%\%~(name,~ns)~)'\textbackslash{}}{\tiny \par}

{\tiny 778c779}{\tiny \par}

{\tiny <~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~tcs,namespace)}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~tcs)}{\tiny \par}

{\tiny 783a785,786}{\tiny \par}

{\tiny >~~~~~~~~~~~~~~~~~if~namespace:}{\tiny \par}

{\tiny >~~~~~~~~~~~~~~~~~~~~~namespace~=~\char`\"{}'\char`\"{}~+~namespace~+~\char`\"{}'\char`\"{}}{\tiny \par}

{\tiny 795,796c798,799}{\tiny \par}

{\tiny <~~~~~~~~~~~~~self.typecode~+=~'\%stypecode~=~\%s(~name=\%s,~ns=None~).typecode'\textbackslash{}}{\tiny \par}

{\tiny <~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\%~(ID1,~message.getName(),~name~)}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~~~~~self.typecode~+=~'\%stypecode~=~\%s(~name=\%s,~ns=\%s~).typecode'\textbackslash{}}{\tiny \par}

{\tiny >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\%~(ID1,~message.getName(),~name,~namespace~)}{\tiny \par}

{\tiny 799,800c802,803}{\tiny \par}

{\tiny <~~~~~~~~~~~~~self.typecode~+=~'\textbackslash{}n\%s\%s.\_\_init\_\_(~self,~name=\%s,~ns=None~)'~\textbackslash{}}{\tiny \par}

{\tiny <~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\%~(ID2,~message.getName(),~name~)}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~~~~~self.typecode~+=~'\textbackslash{}n\%s\%s.\_\_init\_\_(~self,~name=\%s,~ns=\%s~)'~\textbackslash{}}{\tiny \par}

{\tiny >~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\%~(ID2,~message.getName(),~name,~namespace)}{\tiny \par}

{\tiny 1233c1236,1238}{\tiny \par}

{\tiny <~~~~~~~~~~~~~self.basector.set('\textbackslash{}n\textbackslash{}n\%s\%s.\_\_init\_\_(self,pname=name,~aname=\char`\"{}\_\%\%s\char`\"{}~\%\%~name,~~{*}{*}kw)'~\%~(ID3,tpc))}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~~~~~\#~If~the~element~has~a~non-empty~ns~attribute,~add~xmlns~to~the~tag~oname}{\tiny \par}

{\tiny >~~~~~~~~~~~~~self.basector.set('\textbackslash{}n\textbackslash{}n\%s\%s.\_\_init\_\_(self,~pname=name,~aname=\char`\"{}\_\%\%s\char`\"{}~\%\%~name,~oname=\char`\"{}\%\%s\char`\"{}~\%\%~(name~+~(ns~and~\textbackslash{}'}{\tiny \par}

{\tiny xmlns=\char`\"{}\%\%s\char`\"{}\textbackslash{}'~\%\%~ns)),~{*}{*}kw)'~\%~(ID3,tpc))}{\tiny \par}

{\scriptsize >}\end{lyxcode}
\end{minipage}%


\item [ServiceProxy.py.patch](no revision information in file)

\begin{itemize}
\item Fixes a problem with rash conversion of toplevel element maxOccurs attribute value
to int. This attribute might be None, so we need to check if conversion is possible.
\end{itemize}
Code:

\begin{minipage}[c]{1.0\columnwidth}%
\begin{lyxcode}
{\tiny 224c224,232}{\tiny \par}

{\tiny <~minOccurs~=~int(element.getAttribute('minOccurs'))}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >}{\tiny \par}

{\tiny >~\#~toplevel~elements~(=ElementDeclaration)~must~not~have~minOccurs~and}{\tiny \par}

{\tiny >~\#~maxOccurs~attributes,~as~opposed~to~local~elements.~So~while~we~can}{\tiny \par}

{\tiny >~\#~query~these,~direct~conversion~to~int~might~prove~fatal.}{\tiny \par}

{\tiny >~\#~Maybe~this~should~be~handled~in~the~XMLSchema~module?~Hmm,~while~the}{\tiny \par}

{\tiny >~\#~attributes~themselves~are~prohibited~in~the~schema~spec,~what~is~the}{\tiny \par}

{\tiny >~\#~intended~value~for~toplevel~components?}{\tiny \par}

{\tiny >}{\tiny \par}

{\tiny >~minOccurs~=~element.getAttribute('minOccurs')}{\tiny \par}

{\tiny 228c236}{\tiny \par}

{\tiny <~typeObj.repeatable~=~(maxOccurs~==~'unbounded')~or~(int(maxOccurs)~>~1)}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~typeObj.repeatable~=~(maxOccurs~==~'unbounded')~or~(maxOccurs~and~int(maxOccurs)~>~1)}\end{lyxcode}
\end{minipage}%


\item [TC.py.patch](based on revision: \# \$Header: /cvsroot/pywebsvcs/zsi/ZSI/TC.py,v
1.35 2004/11/04 19:44:17 boverhof Exp \$)

\begin{itemize}
\item When using doc/literal and returning a message that just consists of a simple element,
a possible xmlns='...' attribute in the name must not occur in the closing tag, so
we remove it. This patch fixes the serialize method, where necessary.\\
Note: Did not change the serialize method for class Any, as I am not sure about the
different naming options that seem to happen there (e.g. if {}``rpc'' is used instead
of {}``name'', can it also contain 'xmlns=...'? If so, is 'xmlns=...' also guaranteed
to be the last attr?)
\end{itemize}
Code:

\begin{minipage}[c]{1.0\columnwidth}%
\begin{lyxcode}
{\tiny 28a29,38}{\tiny \par}

{\tiny >~def~\_without\_trailing\_xmlns\_attr(name):}{\tiny \par}

{\tiny >~~~~~\char`\"{}\char`\"{}\char`\"{}Return~name~with~xmlns='...'~attribute~removed,~for~use~in~closing}{\tiny \par}

{\tiny >~~~~~tags.~xmlns~must~be~the~last~attr~in~name.}{\tiny \par}

{\tiny >~~~~~\char`\"{}\char`\"{}\char`\"{}}{\tiny \par}

{\tiny >~~~~~i~=~name.find('xmlns')}{\tiny \par}

{\tiny >~~~~~if~i~>~0:}{\tiny \par}

{\tiny >~~~~~~~~~return~name{[}:i~-~1{]}}{\tiny \par}

{\tiny >~~~~~else:}{\tiny \par}

{\tiny >~~~~~~~~~return~name}{\tiny \par}

{\tiny >}{\tiny \par}

{\tiny 276d285}{\tiny \par}

{\tiny <}{\tiny \par}

{\tiny 451,456c460}{\tiny \par}

{\tiny <~~~~~~~~~i~=~n.find('xmlns')}{\tiny \par}

{\tiny <~~~~~~~~~if~i~>~0:}{\tiny \par}

{\tiny <~~~~~~~~~~~~~ctag~=~'</\%s>'~\%~n{[}:i~-~1{]}}{\tiny \par}

{\tiny <~~~~~~~~~else:}{\tiny \par}

{\tiny <~~~~~~~~~~~~~ctag~=~'</\%s>'~\%~n}{\tiny \par}

{\tiny <}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~ctag~=~'</\%s>'~\%~\_without\_trailing\_xmlns\_attr(name)}{\tiny \par}

{\tiny 627c631}{\tiny \par}

{\tiny <~~~~~~~~~~~~~~~~~(n,~attrtext,~tstr,~pyobj,~n)}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~~~~~~~~~(n,~attrtext,~tstr,~pyobj,~\_without\_trailing\_xmlns\_attr(n))}{\tiny \par}

{\tiny 751a756}{\tiny \par}

{\tiny >~~~~~~~~~ctagn~=~\_without\_trailing\_xmlns\_attr(n)}{\tiny \par}

{\tiny 757c762}{\tiny \par}

{\tiny <~~~~~~~~~~~~~print~>\,{}>sw,~('<\%s\%s\%s>INF</\%s>')~\%~(n,~attrtext,~tstr,~n)}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~~~~~print~>\,{}>sw,~('<\%s\%s\%s>INF</\%s>')~\%~(n,~attrtext,~tstr,~ctagn)}{\tiny \par}

{\tiny 759c764}{\tiny \par}

{\tiny <~~~~~~~~~~~~~print~>\,{}>sw,~('<\%s\%s\%s>-INF</\%s>')~\%~(n,~attrtext,~tstr,~n)}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~~~~~print~>\,{}>sw,~('<\%s\%s\%s>-INF</\%s>')~\%~(n,~attrtext,~tstr,~ctagn)}{\tiny \par}

{\tiny 761c766}{\tiny \par}

{\tiny <~~~~~~~~~~~~~print~>\,{}>sw,~('<\%s\%s\%s>NaN</\%s>')~\%~(n,~attrtext,~tstr,~n)}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~~~~~print~>\,{}>sw,~('<\%s\%s\%s>NaN</\%s>')~\%~(n,~attrtext,~tstr,~ctagn)}{\tiny \par}

{\tiny 764c769}{\tiny \par}

{\tiny <~~~~~~~~~~~~~~~~~(n,~attrtext,~tstr,~pyobj,~n)}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~~~~~~~~~(n,~attrtext,~tstr,~pyobj,~ctagn)}{\tiny \par}

{\tiny 798c803}{\tiny \par}

{\tiny <~~~~~~~~~print~>\,{}>sw,~'<\%s\%s\%s>\%d</\%s>'~\%~(n,~attrtext,~tstr,~pyobj,~n)}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~print~>\,{}>sw,~'<\%s\%s\%s>\%d</\%s>'~\%~(n,~attrtext,~tstr,~pyobj,~\_without\_trailing\_xmlns\_attr(n))}{\tiny \par}

{\tiny 867c872}{\tiny \par}

{\tiny <~~~~~~~~~print~>\,{}>sw,~'</\%s>'~\%~n}{\tiny \par}

{\tiny -{}-{}-}{\tiny \par}

{\tiny >~~~~~~~~~print~>\,{}>sw,~'</\%s>'~\%~\_without\_trailing\_xmlns\_attr(n)}\end{lyxcode}
\end{minipage}%


\end{description}
\begin{thebibliography}{1}
\bibitem{ZSIrefdoc}Salz, Rich; Blunck, Christopher: ZSI: The Zolera Soap Infrastructure. <http://pywebsvcs.sourceforge.net/zsi.html>,
Release 1.6.1, December 08, 2004.
\bibitem{gSOAPdoc}van Engelen, Robert: gSOAP 2.7.3 User Guide. <http://www.cs.fsu.edu/\textasciitilde{}engelen/soap.html>,
Jun 27, 2005.
\bibitem{whichWSDL}Butek, Russell: Which style of WSDL should I use? <http://www-106.ibm.com/developerworks/webservices/library/ws-whichwsdl>,
May 24, 2005.\end{thebibliography}

\end{document}
